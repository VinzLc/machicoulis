{"ast":null,"code":"import _objectSpread from \"C:/Users/vinzl/workspace/machicoulis/daily-image-collector/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { resolveOwnerFields } from '../utils/resolveOwnerFields.mjs';\nimport { capitalize } from '../utils/stringTransformation.mjs';\nimport { selfAwareAsync } from '../utils/selfAwareAsync.mjs';\nimport { extendCancellability } from './cancellation.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nconst connectionType = {\n  HAS_ONE: 'HAS_ONE',\n  HAS_MANY: 'HAS_MANY',\n  BELONGS_TO: 'BELONGS_TO'\n};\n// When generating an SK's KeyConditionInput name, string-like types map to String\nconst skGraphQlFieldTypeMap = {\n  ID: 'ID',\n  String: 'String',\n  AWSDate: 'String',\n  AWSTime: 'String',\n  AWSDateTime: 'String',\n  AWSTimestamp: 'Int',\n  AWSEmail: 'String',\n  AWSPhone: 'String',\n  AWSURL: 'String',\n  AWSIPAddress: 'String',\n  AWSJSON: 'String',\n  Boolean: 'Boolean',\n  Int: 'Int',\n  Float: 'Float'\n};\n// move to util\nconst resolvedSkName = sk => {\n  if (sk.length === 1) {\n    return sk[0];\n  } else {\n    return sk.reduce((acc, curr, idx) => {\n      if (idx === 0) {\n        return curr;\n      } else {\n        return acc + capitalize(curr);\n      }\n    }, '');\n  }\n};\n/**\n * Crawls a model tree, starting with a given **individual** model instance record, looking\n * for related hasMany children to extract from their `items` containers.\n *\n * E.g., if we have a record like this:\n *\n * ```js\n * {\n *   id: 'some-id',\n *   children: {\n *     items: [\n *       { name: 'a' }\n *       { name: 'b' }\n *       { name: 'c' }\n *     ]\n *   }\n * }\n * ```\n *\n * And if `children` refers to *an array of another model* (as opposed to a custom type),\n * the `items` will be extracted. We do this because `items` is just the mechanism for nesting\n * child records -- we don't want customers to have to dig the items out in application code.\n * Ultimately, we return this \"flattened\" structure:\n *\n * ```js\n * {\n *   id: 'some-id',\n *   children: [\n *     { name: 'a' }\n *     { name: 'b' }\n *     { name: 'c' }\n *   ]\n * }\n * ```\n *\n * Notably, an identical record could be the result of a nested custom type that contains an\n * `items` property. This will *not* be flattened, because in that case the `items` property is\n * actually part of the customer's schema. Similarly if a model contains an explicit `items` field.\n *\n * @param modelIntrospection Top-level model introspection schema.\n * @param modelName The name of the model. Can be `undefined`. E.g., for customOperation return types.\n * @param modelRecord The individual \"model instance record\" to normalize.\n */\nconst flattenItems = (modelIntrospection, modelName, modelRecord) => {\n  if (!modelRecord) return null;\n  const mapped = {};\n  for (const [fieldName, value] of Object.entries(modelRecord)) {\n    var _modelIntrospection$m;\n    const fieldDef = modelName ? (_modelIntrospection$m = modelIntrospection.models[modelName]) === null || _modelIntrospection$m === void 0 ? void 0 : _modelIntrospection$m.fields[fieldName] : undefined;\n    const dvPair = {\n      fieldDef,\n      value\n    };\n    if (isRelatedModelItemsArrayPair(dvPair)) {\n      mapped[fieldName] = dvPair.value.items.map(itemValue => flattenItems(modelIntrospection, dvPair.fieldDef.type.model, itemValue));\n    } else if (isRelatedModelProperty(fieldDef)) {\n      mapped[fieldName] = flattenItems(modelIntrospection, fieldDef.type.model, value);\n    } else {\n      mapped[fieldName] = value;\n    }\n  }\n  return mapped;\n};\n/**\n * Determines whether the given field definition and associated result value\n * represent a related model array from a HasMany-type relationship.\n *\n * @param dv Pair of field definition and associated result value\n * @returns\n */\nfunction isRelatedModelItemsArrayPair(dv) {\n  var _dv$fieldDef, _dv$value;\n  return typeof ((_dv$fieldDef = dv.fieldDef) === null || _dv$fieldDef === void 0 ? void 0 : _dv$fieldDef.type) === 'object' && 'model' in dv.fieldDef.type && typeof dv.fieldDef.type.model === 'string' && dv.fieldDef.isArray && Array.isArray((_dv$value = dv.value) === null || _dv$value === void 0 ? void 0 : _dv$value.items);\n}\n/**\n * Determines whether the given field definition represents a relationship\n * to another model.\n *\n * @param fieldDef\n * @returns\n */\nfunction isRelatedModelProperty(fieldDef) {\n  return typeof (fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.type) === 'object' && 'model' in fieldDef.type && typeof fieldDef.type.model === 'string';\n}\n// TODO: this should accept single result to support CRUD methods; create helper for array/list\nfunction initializeModel(client, modelName, result, modelIntrospection, authMode, authToken) {\n  let context = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  const introModel = modelIntrospection.models[modelName];\n  const introModelFields = introModel.fields;\n  const modelFields = Object.entries(introModelFields).filter(_ref => {\n    var _field$type;\n    let [_, field] = _ref;\n    return (field === null || field === void 0 || (_field$type = field.type) === null || _field$type === void 0 ? void 0 : _field$type.model) !== undefined;\n  }).map(_ref2 => {\n    let [fieldName] = _ref2;\n    return fieldName;\n  });\n  return result.map(record => {\n    if (record === null || record === undefined) {\n      return record;\n    }\n    const initializedRelationshipFields = {};\n    for (const fieldName of modelFields) {\n      var _modelField$associati;\n      const modelField = introModelFields[fieldName];\n      const modelFieldType = modelField === null || modelField === void 0 ? void 0 : modelField.type;\n      const relatedModelName = modelFieldType.model;\n      const relatedModel = modelIntrospection.models[relatedModelName];\n      const relatedModelPKFieldName = relatedModel.primaryKeyInfo.primaryKeyFieldName;\n      const relatedModelSKFieldNames = relatedModel.primaryKeyInfo.sortKeyFieldNames;\n      const relationType = (_modelField$associati = modelField.association) === null || _modelField$associati === void 0 ? void 0 : _modelField$associati.connectionType;\n      let connectionFields = [];\n      if (modelField.association && 'associatedWith' in modelField.association) {\n        connectionFields = modelField.association.associatedWith;\n      }\n      const targetNames = [];\n      if (modelField.association && 'targetNames' in modelField.association) {\n        targetNames.push(...modelField.association.targetNames);\n      }\n      switch (relationType) {\n        case connectionType.BELONGS_TO:\n          {\n            var _client$models$relate;\n            const sortKeyValues = relatedModelSKFieldNames.reduce(\n            // TODO(Eslint): is this implementation correct?\n            // eslint-disable-next-line array-callback-return\n            (acc, curVal) => {\n              if (record[curVal]) {\n                acc[curVal] = record[curVal];\n              }\n              return acc;\n            }, {});\n            // if get is disabled on the related model\n            if (((_client$models$relate = client.models[relatedModelName]) === null || _client$models$relate === void 0 ? void 0 : _client$models$relate.get) === undefined) {\n              break;\n            }\n            if (context) {\n              initializedRelationshipFields[fieldName] = (contextSpec, options) => {\n                if (record[targetNames[0]]) {\n                  return client.models[relatedModelName].get(contextSpec, _objectSpread({\n                    [relatedModelPKFieldName]: record[targetNames[0]]\n                  }, sortKeyValues), {\n                    authMode: (options === null || options === void 0 ? void 0 : options.authMode) || authMode,\n                    authToken: (options === null || options === void 0 ? void 0 : options.authToken) || authToken\n                  });\n                }\n                return {\n                  data: null\n                };\n              };\n            } else {\n              initializedRelationshipFields[fieldName] = options => {\n                if (record[targetNames[0]]) {\n                  return client.models[relatedModelName].get(_objectSpread({\n                    [relatedModelPKFieldName]: record[targetNames[0]]\n                  }, sortKeyValues), {\n                    authMode: (options === null || options === void 0 ? void 0 : options.authMode) || authMode,\n                    authToken: (options === null || options === void 0 ? void 0 : options.authToken) || authToken\n                  });\n                }\n                return {\n                  data: null\n                };\n              };\n            }\n            break;\n          }\n        case connectionType.HAS_ONE:\n        case connectionType.HAS_MANY:\n          {\n            var _client$models$relate3;\n            /**\n             * If the loader is a HAS_ONE, we just need to attempt to grab the first item\n             * from the result.\n             */\n            const mapResult = relationType === connectionType.HAS_ONE ? result => {\n              return {\n                data: (result === null || result === void 0 ? void 0 : result.data.shift()) || null,\n                errors: result.errors,\n                extensions: result.extensions\n              };\n            } : result => result;\n            const parentPk = introModel.primaryKeyInfo.primaryKeyFieldName;\n            const parentSK = introModel.primaryKeyInfo.sortKeyFieldNames;\n            // M:N check - TODO: refactor\n            const relatedModelField = relatedModel.fields[connectionFields[0]];\n            const relatedModelFieldType = relatedModelField.type;\n            if (relatedModelFieldType.model) {\n              var _client$models$relate2;\n              let relatedTargetNames = [];\n              if (relatedModelField.association && 'targetNames' in relatedModelField.association) {\n                var _relatedModelField$as;\n                relatedTargetNames = (_relatedModelField$as = relatedModelField.association) === null || _relatedModelField$as === void 0 ? void 0 : _relatedModelField$as.targetNames;\n              }\n              const hasManyFilter = relatedTargetNames.map((field, idx) => {\n                if (idx === 0) {\n                  return {\n                    [field]: {\n                      eq: record[parentPk]\n                    }\n                  };\n                }\n                return {\n                  [field]: {\n                    eq: record[parentSK[idx - 1]]\n                  }\n                };\n              });\n              // if list is disabled on the related model\n              if (((_client$models$relate2 = client.models[relatedModelName]) === null || _client$models$relate2 === void 0 ? void 0 : _client$models$relate2.list) === undefined) {\n                break;\n              }\n              if (context) {\n                initializedRelationshipFields[fieldName] = (contextSpec, options) => {\n                  if (record[parentPk]) {\n                    return selfAwareAsync(async resultPromise => {\n                      const basePromise = client.models[relatedModelName].list(contextSpec, {\n                        filter: {\n                          and: hasManyFilter\n                        },\n                        limit: options === null || options === void 0 ? void 0 : options.limit,\n                        nextToken: options === null || options === void 0 ? void 0 : options.nextToken,\n                        authMode: (options === null || options === void 0 ? void 0 : options.authMode) || authMode,\n                        authToken: (options === null || options === void 0 ? void 0 : options.authToken) || authToken\n                      });\n                      const extendedBase = extendCancellability(basePromise, resultPromise);\n                      return mapResult(await extendedBase);\n                    });\n                  }\n                  return [];\n                };\n              } else {\n                initializedRelationshipFields[fieldName] = options => {\n                  if (record[parentPk]) {\n                    return selfAwareAsync(async resultPromise => {\n                      const basePromise = client.models[relatedModelName].list({\n                        filter: {\n                          and: hasManyFilter\n                        },\n                        limit: options === null || options === void 0 ? void 0 : options.limit,\n                        nextToken: options === null || options === void 0 ? void 0 : options.nextToken,\n                        authMode: (options === null || options === void 0 ? void 0 : options.authMode) || authMode,\n                        authToken: (options === null || options === void 0 ? void 0 : options.authToken) || authToken\n                      });\n                      const extendedBase = extendCancellability(basePromise, resultPromise);\n                      return mapResult(await extendedBase);\n                    });\n                  }\n                  return [];\n                };\n              }\n              break;\n            }\n            const hasManyFilter = connectionFields.map((field, idx) => {\n              if (idx === 0) {\n                return {\n                  [field]: {\n                    eq: record[parentPk]\n                  }\n                };\n              }\n              return {\n                [field]: {\n                  eq: record[parentSK[idx - 1]]\n                }\n              };\n            });\n            // if list is disabled on the related model\n            if (((_client$models$relate3 = client.models[relatedModelName]) === null || _client$models$relate3 === void 0 ? void 0 : _client$models$relate3.list) === undefined) {\n              break;\n            }\n            if (context) {\n              initializedRelationshipFields[fieldName] = (contextSpec, options) => {\n                if (record[parentPk]) {\n                  return selfAwareAsync(async resultPromise => {\n                    const basePromise = client.models[relatedModelName].list(contextSpec, {\n                      filter: {\n                        and: hasManyFilter\n                      },\n                      limit: options === null || options === void 0 ? void 0 : options.limit,\n                      nextToken: options === null || options === void 0 ? void 0 : options.nextToken,\n                      authMode: (options === null || options === void 0 ? void 0 : options.authMode) || authMode,\n                      authToken: (options === null || options === void 0 ? void 0 : options.authToken) || authToken\n                    });\n                    const extendedBase = extendCancellability(basePromise, resultPromise);\n                    return mapResult(await extendedBase);\n                  });\n                }\n                return [];\n              };\n            } else {\n              initializedRelationshipFields[fieldName] = options => {\n                if (record[parentPk]) {\n                  return selfAwareAsync(async resultPromise => {\n                    const basePromise = client.models[relatedModelName].list({\n                      filter: {\n                        and: hasManyFilter\n                      },\n                      limit: options === null || options === void 0 ? void 0 : options.limit,\n                      nextToken: options === null || options === void 0 ? void 0 : options.nextToken,\n                      authMode: (options === null || options === void 0 ? void 0 : options.authMode) || authMode,\n                      authToken: (options === null || options === void 0 ? void 0 : options.authToken) || authToken\n                    });\n                    const extendedBase = extendCancellability(basePromise, resultPromise);\n                    return mapResult(await extendedBase);\n                  });\n                }\n                return [];\n              };\n            }\n            break;\n          }\n      }\n    }\n    return _objectSpread(_objectSpread({}, record), initializedRelationshipFields);\n  });\n}\nconst graphQLOperationsInfo = {\n  CREATE: {\n    operationPrefix: 'create',\n    usePlural: false\n  },\n  GET: {\n    operationPrefix: 'get',\n    usePlural: false\n  },\n  UPDATE: {\n    operationPrefix: 'update',\n    usePlural: false\n  },\n  DELETE: {\n    operationPrefix: 'delete',\n    usePlural: false\n  },\n  LIST: {\n    operationPrefix: 'list',\n    usePlural: true\n  },\n  INDEX_QUERY: {\n    operationPrefix: '',\n    usePlural: false\n  },\n  ONCREATE: {\n    operationPrefix: 'onCreate',\n    usePlural: false\n  },\n  ONUPDATE: {\n    operationPrefix: 'onUpdate',\n    usePlural: false\n  },\n  ONDELETE: {\n    operationPrefix: 'onDelete',\n    usePlural: false\n  },\n  OBSERVEQUERY: {\n    operationPrefix: 'observeQuery',\n    usePlural: false\n  }\n};\nconst SELECTION_SET_WILDCARD = '*';\nconst getDefaultSelectionSetForNonModelWithIR = (nonModelDefinition, modelIntrospection) => {\n  const {\n    fields\n  } = nonModelDefinition;\n  const mappedFields = Object.values(fields).map(_ref3 => {\n    let {\n      type,\n      name\n    } = _ref3;\n    if (typeof type.enum === 'string') {\n      return [name, FIELD_IR];\n    }\n    if (typeof type.nonModel === 'string') {\n      return [name, getDefaultSelectionSetForNonModelWithIR(modelIntrospection.nonModels[type.nonModel], modelIntrospection)];\n    }\n    if (typeof type === 'string') {\n      return [name, FIELD_IR];\n    }\n    return undefined;\n  }).filter(pair => pair !== undefined);\n  return Object.fromEntries(mappedFields);\n};\nconst getDefaultSelectionSetForModelWithIR = (modelDefinition, modelIntrospection) => {\n  const {\n    fields\n  } = modelDefinition;\n  const mappedFields = Object.values(fields).map(_ref4 => {\n    let {\n      type,\n      name\n    } = _ref4;\n    if (typeof type.enum === 'string' || typeof type === 'string') {\n      return [name, FIELD_IR];\n    }\n    if (typeof type.nonModel === 'string') {\n      return [name, getDefaultSelectionSetForNonModelWithIR(modelIntrospection.nonModels[type.nonModel], modelIntrospection)];\n    }\n    return undefined;\n  }).filter(pair => pair !== undefined);\n  const ownerFields = resolveOwnerFields(modelDefinition).map(field => [field, FIELD_IR]);\n  return Object.fromEntries(mappedFields.concat(ownerFields));\n};\nfunction defaultSelectionSetForModel(modelDefinition) {\n  // fields that are explicitly part of the graphql schema; not\n  // inferred from owner auth rules.\n  const {\n    fields\n  } = modelDefinition;\n  const explicitFields = Object.values(fields)\n  // Default selection set omits model fields\n  .map(_ref5 => {\n    let {\n      type,\n      name\n    } = _ref5;\n    if (typeof type === 'string') return name;\n    if (typeof type === 'object') {\n      if (typeof (type === null || type === void 0 ? void 0 : type.enum) === 'string') {\n        return name;\n      } else if (typeof (type === null || type === void 0 ? void 0 : type.nonModel) === 'string') {\n        return \"\".concat(name, \".\").concat(SELECTION_SET_WILDCARD);\n      }\n    }\n    return undefined;\n  }).filter(Boolean);\n  // fields used for owner auth rules that may or may not also\n  // be explicit on the model.\n  const ownerFields = resolveOwnerFields(modelDefinition);\n  return Array.from(new Set(explicitFields.concat(ownerFields)));\n}\nconst FIELD_IR = '';\n/**\n * Generates nested Custom Selection Set IR from path\n *\n * @param modelDefinitions\n * @param modelName\n * @param selectionSet - array of object paths\n * @example\n * ### Given\n * `selectionSet = ['id', 'comments.post.id']`\n * ### Returns\n * ```ts\n * {\n *   id: '',\n *   comments: {\n *     items: { post: { id: '' } }\n *   }\n * }\n * ```\n */\nfunction customSelectionSetToIR(modelIntrospection, modelName, selectionSet) {\n  const dotNotationToObject = (path, modelOrNonModelName) => {\n    var _modelIntrospection$m2, _modelOrNonModelField, _modelOrNonModelField2;\n    const [fieldName, ...rest] = path.split('.');\n    const nested = rest[0];\n    const modelOrNonModelDefinition = (_modelIntrospection$m2 = modelIntrospection.models[modelOrNonModelName]) !== null && _modelIntrospection$m2 !== void 0 ? _modelIntrospection$m2 : modelIntrospection.nonModels[modelOrNonModelName];\n    const modelOrNonModelFields = modelOrNonModelDefinition === null || modelOrNonModelDefinition === void 0 ? void 0 : modelOrNonModelDefinition.fields;\n    const relatedModel = modelOrNonModelFields === null || modelOrNonModelFields === void 0 || (_modelOrNonModelField = modelOrNonModelFields[fieldName]) === null || _modelOrNonModelField === void 0 || (_modelOrNonModelField = _modelOrNonModelField.type) === null || _modelOrNonModelField === void 0 ? void 0 : _modelOrNonModelField.model;\n    const relatedModelDefinition = modelIntrospection.models[relatedModel];\n    const relatedNonModel = modelOrNonModelFields === null || modelOrNonModelFields === void 0 || (_modelOrNonModelField2 = modelOrNonModelFields[fieldName]) === null || _modelOrNonModelField2 === void 0 || (_modelOrNonModelField2 = _modelOrNonModelField2.type) === null || _modelOrNonModelField2 === void 0 ? void 0 : _modelOrNonModelField2.nonModel;\n    const relatedNonModelDefinition = modelIntrospection.nonModels[relatedNonModel];\n    const isModelOrNonModelOrFieldType = relatedModelDefinition ? 'model' : relatedNonModelDefinition ? 'nonModel' : 'field';\n    if (isModelOrNonModelOrFieldType === 'nonModel') {\n      let result = {};\n      if (!nested) {\n        throw Error(\"\".concat(fieldName, \" must declare a wildcard (*) or a field of custom type \").concat(relatedNonModel));\n      }\n      if (nested === SELECTION_SET_WILDCARD) {\n        result = {\n          [fieldName]: getDefaultSelectionSetForNonModelWithIR(relatedNonModelDefinition, modelIntrospection)\n        };\n      } else {\n        result = {\n          [fieldName]: dotNotationToObject(rest.join('.'), relatedNonModel)\n        };\n      }\n      return result;\n    } else if (isModelOrNonModelOrFieldType === 'model') {\n      var _modelOrNonModelField3;\n      let result = {};\n      if (!nested) {\n        throw Error(\"\".concat(fieldName, \" must declare a wildcard (*) or a field of model \").concat(relatedModel));\n      }\n      if (nested === SELECTION_SET_WILDCARD) {\n        const nestedRelatedModelDefinition = modelIntrospection.models[relatedModel];\n        result = {\n          [fieldName]: getDefaultSelectionSetForModelWithIR(nestedRelatedModelDefinition, modelIntrospection)\n        };\n      } else {\n        result = {\n          [fieldName]: dotNotationToObject(rest.join('.'), relatedModel)\n        };\n      }\n      if ((_modelOrNonModelField3 = modelOrNonModelFields[fieldName]) !== null && _modelOrNonModelField3 !== void 0 && _modelOrNonModelField3.isArray) {\n        result = {\n          [fieldName]: {\n            items: result[fieldName]\n          }\n        };\n      }\n      return result;\n    } else {\n      var _nonModelDefinition$f;\n      const modelField = modelOrNonModelFields === null || modelOrNonModelFields === void 0 ? void 0 : modelOrNonModelFields[fieldName];\n      const nonModelDefinition = modelIntrospection.nonModels[modelOrNonModelName];\n      const nonModelField = nonModelDefinition === null || nonModelDefinition === void 0 || (_nonModelDefinition$f = nonModelDefinition.fields) === null || _nonModelDefinition$f === void 0 ? void 0 : _nonModelDefinition$f[fieldName];\n      if (!nonModelDefinition) {\n        const isOwnerField = resolveOwnerFields(modelOrNonModelDefinition).includes(fieldName);\n        if (!modelField && !isOwnerField) {\n          throw Error(\"\".concat(fieldName, \" is not a field of model \").concat(modelOrNonModelName));\n        }\n      } else {\n        if (!nonModelField) {\n          throw Error(\"\".concat(fieldName, \" is not a field of custom type \").concat(modelOrNonModelName));\n        }\n      }\n      return {\n        [fieldName]: FIELD_IR\n      };\n    }\n  };\n  return selectionSet.reduce((resultObj, path) => deepMergeSelectionSetObjects(dotNotationToObject(path, modelName), resultObj), {});\n}\n/**\n * Stringifies selection set IR\n * * @example\n * ### Given\n * ```ts\n * {\n *   id: '',\n *   comments: {\n *     items: { post: { id: '' } }\n *   }\n * }\n * ```\n * ### Returns\n * `'id comments { items { post { id } } }'`\n */\nfunction selectionSetIRToString(obj) {\n  const res = [];\n  Object.entries(obj).forEach(_ref6 => {\n    let [fieldName, value] = _ref6;\n    if (value === FIELD_IR) {\n      res.push(fieldName);\n    } else if (typeof value === 'object' && value !== null) {\n      if (value !== null && value !== void 0 && value.items) {\n        res.push(fieldName, '{', 'items', '{', selectionSetIRToString(value.items), '}', '}');\n      } else {\n        res.push(fieldName, '{', selectionSetIRToString(value), '}');\n      }\n    }\n  });\n  return res.join(' ');\n}\n/**\n * Recursively merges selection set objects from `source` onto `target`.\n *\n * `target` will be updated. `source` will be left alone.\n *\n * @param source The object to merge into target.\n * @param target The object to be mutated.\n */\nfunction deepMergeSelectionSetObjects(source, target) {\n  const isObject = obj => obj && typeof obj === 'object';\n  for (const key in source) {\n    // This verification avoids 'Prototype Pollution' issue\n    if (!Object.prototype.hasOwnProperty.call(source, key)) continue;\n    if (Object.prototype.hasOwnProperty.call(target, key) && isObject(target[key])) {\n      deepMergeSelectionSetObjects(source[key], target[key]);\n    } else {\n      target[key] = source[key];\n    }\n  }\n  return target;\n}\nfunction generateSelectionSet(modelIntrospection, modelName, selectionSet) {\n  const modelDefinition = modelIntrospection.models[modelName];\n  const selSetIr = customSelectionSetToIR(modelIntrospection, modelName, selectionSet !== null && selectionSet !== void 0 ? selectionSet : defaultSelectionSetForModel(modelDefinition));\n  const selSetString = selectionSetIRToString(selSetIr);\n  return selSetString;\n}\nfunction generateGraphQLDocument(modelIntrospection, modelDefinition, modelOperation, listArgs, indexMeta) {\n  const {\n    name,\n    pluralName,\n    fields,\n    primaryKeyInfo: {\n      isCustomPrimaryKey,\n      primaryKeyFieldName,\n      sortKeyFieldNames\n    },\n    attributes\n  } = modelDefinition;\n  // Use pascal case of the model name to generate the operations and the arguments.\n  // This is required to be in sync with the resources generated by the GraphQL transformers.\n  const namePascalCase = name.charAt(0).toUpperCase() + name.slice(1);\n  const pluralNamePascalCase = pluralName.charAt(0).toUpperCase() + pluralName.slice(1);\n  const {\n    operationPrefix,\n    usePlural\n  } = graphQLOperationsInfo[modelOperation];\n  const {\n    selectionSet\n  } = listArgs || {};\n  let graphQLFieldName;\n  let indexQueryArgs;\n  if (operationPrefix) {\n    graphQLFieldName = \"\".concat(operationPrefix).concat(usePlural ? pluralNamePascalCase : namePascalCase);\n  } else if (indexMeta) {\n    const {\n      queryField,\n      pk,\n      sk = []\n    } = indexMeta;\n    graphQLFieldName = queryField;\n    /**\n     * **a. Single field SK** -> single arg where name is the field name and the type is `Model${gqlFieldType}KeyConditionInput` (nullable)\n     *  Note: string-like data types e.g.,  AWSDateTime, AWSEmail, AWSPhone, etc. should map to String. See `skGraphQlFieldTypeMap` above\n     * @example\n     * ```\n     * sk1: ModelStringKeyConditionInput\n     * ```\n     *\n     * **b. Composite SK** -> single arg where the name is camelCase concatenation of all the field names that comprise the SK\n     *  and the type is `Model${modelName}${keyAttributeName}CompositeKeyConditionInput` (nullable)\n     * @example\n     * ```\n     * sk1Sk2: ModelMyModelMyModelByPkAndSk1AndSk2CompositeKeyConditionInput\n     */\n    let skQueryArgs = {};\n    if (sk.length === 1) {\n      const [skField] = sk;\n      const type = typeof fields[skField].type === 'string' ? fields[skField].type : 'String';\n      const normalizedType = skGraphQlFieldTypeMap[type];\n      skQueryArgs = {\n        [skField]: \"Model\".concat(normalizedType, \"KeyConditionInput\")\n      };\n    } else if (sk.length > 1) {\n      var _attributes$find;\n      const compositeSkArgName = resolvedSkName(sk);\n      const keyName = attributes === null || attributes === void 0 || (_attributes$find = attributes.find(attr => {\n        var _attr$properties;\n        return (attr === null || attr === void 0 || (_attr$properties = attr.properties) === null || _attr$properties === void 0 ? void 0 : _attr$properties.queryField) === queryField;\n      })) === null || _attributes$find === void 0 || (_attributes$find = _attributes$find.properties) === null || _attributes$find === void 0 ? void 0 : _attributes$find.name;\n      skQueryArgs = {\n        [compositeSkArgName]: \"Model\".concat(capitalize(name)).concat(capitalize(keyName), \"CompositeKeyConditionInput\")\n      };\n    }\n    indexQueryArgs = _objectSpread({\n      [pk]: \"\".concat(Object.prototype.hasOwnProperty.call(fields[pk].type, 'enum') ? fields[pk].type.enum // AppSync schema sets enum type as the type of the enum fields that's used as PK\n      : fields[pk].type, \"!\")\n    }, skQueryArgs);\n  } else {\n    throw new Error('Error generating GraphQL Document - invalid operation name');\n  }\n  let graphQLOperationType;\n  let graphQLSelectionSet;\n  let graphQLArguments;\n  const selectionSetFields = generateSelectionSet(modelIntrospection, name, selectionSet);\n  // default PK args for get and list operations\n  // modified below for CPK\n  const getPkArgs = {\n    [primaryKeyFieldName]: \"\".concat(fields[primaryKeyFieldName].type, \"!\")\n  };\n  const listPkArgs = {};\n  /**\n   * Generate query field args for the SK if it's defined\n   *\n   * **1. Get queries** require each SK field to be present as a separate arg where the type is the field's GraphQL scalar type (non-nullable)\n   * @example\n   * ```\n   * sk1: String!, sk2: Int!\n   * ```\n   *\n   * **2. List queries**\n   *\n   * **a. Single field SK** -> single arg where name is the field name and the type is `Model${gqlFieldType}KeyConditionInput` (nullable)\n   *      Note: string-like data types e.g.,  AWSDateTime, AWSEmail, AWSPhone, etc. should map to String. See `skGraphQlFieldTypeMap` above\n   * @example\n   * ```\n   * sk1: ModelStringKeyConditionInput\n   * ```\n   *\n   * **b. Composite SK** -> single arg where the name is camelCase concatenation of all the field names that comprise the SK\n   *  and the type is `Model${modelName}PrimaryCompositeKeyConditionInput` (nullable)\n   * @example\n   * ```\n   * sk1Sk2: ModelMyModelPrimaryCompositeKeyConditionInput\n   * ```\n   */\n  const generateSkArgs = op => {\n    if (sortKeyFieldNames.length === 0) return {};\n    if (op === 'get') {\n      return sortKeyFieldNames.reduce((acc, fieldName) => {\n        const fieldType = fields[fieldName].type;\n        if (op === 'get') {\n          acc[fieldName] = \"\".concat(fieldType, \"!\"); // ! - SK args are non-nullable in Get queries\n        }\n        return acc;\n      }, {});\n    } else {\n      // list SK\n      if (sortKeyFieldNames.length === 1) {\n        // Single SK\n        const [sk] = sortKeyFieldNames;\n        const type = typeof fields[sk].type === 'string' ? fields[sk].type : 'String';\n        const normalizedType = skGraphQlFieldTypeMap[type];\n        return {\n          [sk]: \"Model\".concat(normalizedType, \"KeyConditionInput\")\n        };\n      } else {\n        // Composite SK\n        const compositeSkArgName = resolvedSkName(sortKeyFieldNames);\n        return {\n          [compositeSkArgName]: \"Model\".concat(capitalize(name), \"PrimaryCompositeKeyConditionInput\")\n        };\n      }\n    }\n  };\n  if (isCustomPrimaryKey) {\n    Object.assign(getPkArgs, generateSkArgs('get'));\n    Object.assign(listPkArgs, {\n      // PK is only included in list query field args in the generated GQL\n      // when explicitly specifying PK with .identifier(['fieldName']) or @primaryKey in the schema definition\n      [primaryKeyFieldName]: \"\".concat(fields[primaryKeyFieldName].type),\n      // PK is always a nullable arg for list (no `!` after the type)\n      sortDirection: 'ModelSortDirection'\n    }, generateSkArgs('list'));\n  }\n  switch (modelOperation) {\n    case 'CREATE':\n    case 'UPDATE':\n    case 'DELETE':\n      graphQLArguments !== null && graphQLArguments !== void 0 ? graphQLArguments : graphQLArguments = {\n        input: \"\".concat(operationPrefix.charAt(0).toLocaleUpperCase() + operationPrefix.slice(1)).concat(namePascalCase, \"Input!\")\n      };\n      graphQLOperationType !== null && graphQLOperationType !== void 0 ? graphQLOperationType : graphQLOperationType = 'mutation';\n    // TODO(Eslint): this this case clause correct without the break statement?\n    // eslint-disable-next-line no-fallthrough\n    case 'GET':\n      graphQLArguments !== null && graphQLArguments !== void 0 ? graphQLArguments : graphQLArguments = getPkArgs;\n      graphQLSelectionSet !== null && graphQLSelectionSet !== void 0 ? graphQLSelectionSet : graphQLSelectionSet = selectionSetFields;\n    // TODO(Eslint): this this case clause correct without the break statement?\n    // eslint-disable-next-line no-fallthrough\n    case 'LIST':\n      graphQLArguments !== null && graphQLArguments !== void 0 ? graphQLArguments : graphQLArguments = _objectSpread(_objectSpread({}, listPkArgs), {}, {\n        // eslint doesn't like the ts-ignore, because it thinks it's unnecessary.\n        // But TS doesn't like the `filter: ...` because it think it will always be\n        // overwritten. (it won't be.) so, we need to ignore the TS error and then\n        // ignore the eslint error on the ts-ignore.\n        // eslint-disable-next-line\n        // @ts-ignore\n        filter: \"Model\".concat(namePascalCase, \"FilterInput\"),\n        limit: 'Int',\n        nextToken: 'String'\n      });\n      graphQLOperationType !== null && graphQLOperationType !== void 0 ? graphQLOperationType : graphQLOperationType = 'query';\n      graphQLSelectionSet !== null && graphQLSelectionSet !== void 0 ? graphQLSelectionSet : graphQLSelectionSet = \"items { \".concat(selectionSetFields, \" } nextToken __typename\");\n    // TODO(Eslint): this this case clause correct without the break statement?\n    // eslint-disable-next-line no-fallthrough\n    case 'INDEX_QUERY':\n      graphQLArguments !== null && graphQLArguments !== void 0 ? graphQLArguments : graphQLArguments = _objectSpread(_objectSpread({}, indexQueryArgs), {}, {\n        filter: \"Model\".concat(namePascalCase, \"FilterInput\"),\n        sortDirection: 'ModelSortDirection',\n        limit: 'Int',\n        nextToken: 'String'\n      });\n      graphQLOperationType !== null && graphQLOperationType !== void 0 ? graphQLOperationType : graphQLOperationType = 'query';\n      graphQLSelectionSet !== null && graphQLSelectionSet !== void 0 ? graphQLSelectionSet : graphQLSelectionSet = \"items { \".concat(selectionSetFields, \" } nextToken __typename\");\n    // TODO(Eslint): this this case clause correct without the break statement?\n    // eslint-disable-next-line no-fallthrough\n    case 'ONCREATE':\n    case 'ONUPDATE':\n    case 'ONDELETE':\n      graphQLArguments !== null && graphQLArguments !== void 0 ? graphQLArguments : graphQLArguments = {\n        filter: \"ModelSubscription\".concat(namePascalCase, \"FilterInput\")\n      };\n      graphQLOperationType !== null && graphQLOperationType !== void 0 ? graphQLOperationType : graphQLOperationType = 'subscription';\n      graphQLSelectionSet !== null && graphQLSelectionSet !== void 0 ? graphQLSelectionSet : graphQLSelectionSet = selectionSetFields;\n      break;\n    case 'OBSERVEQUERY':\n    default:\n      throw new Error('Internal error: Attempted to generate graphql document for observeQuery. Please report this error.');\n  }\n  const graphQLDocument = \"\".concat(graphQLOperationType).concat(graphQLArguments ? \"(\".concat(Object.entries(graphQLArguments).map(_ref7 => {\n    let [fieldName, type] = _ref7;\n    return \"$\".concat(fieldName, \": \").concat(type);\n  }), \")\") : '', \" { \").concat(graphQLFieldName).concat(graphQLArguments ? \"(\".concat(Object.keys(graphQLArguments).map(fieldName => \"\".concat(fieldName, \": $\").concat(fieldName)), \")\") : '', \" { \").concat(graphQLSelectionSet, \" } }\");\n  return graphQLDocument;\n}\nfunction buildGraphQLVariables(modelDefinition, operation, arg, modelIntrospection, indexMeta) {\n  const {\n    fields,\n    primaryKeyInfo: {\n      isCustomPrimaryKey,\n      primaryKeyFieldName,\n      sortKeyFieldNames\n    }\n  } = modelDefinition;\n  const skName = (sortKeyFieldNames === null || sortKeyFieldNames === void 0 ? void 0 : sortKeyFieldNames.length) && resolvedSkName(sortKeyFieldNames);\n  let variables = {};\n  // TODO: process input\n  switch (operation) {\n    case 'CREATE':\n      variables = {\n        input: arg ? normalizeMutationInput(arg, modelDefinition, modelIntrospection) : {}\n      };\n      break;\n    case 'UPDATE':\n      // readonly fields are not  updated\n      variables = {\n        input: arg ? Object.fromEntries(Object.entries(normalizeMutationInput(arg, modelDefinition, modelIntrospection)).filter(_ref8 => {\n          let [fieldName] = _ref8;\n          // omit field from update input\n          // if exists in fields and marked read only\n          // if does not exist in fields but implicitly added to schema via ownership\n          return fields[fieldName] ? !fields[fieldName].isReadOnly : !resolveOwnerFields(modelDefinition).includes(fieldName);\n        })) : {}\n      };\n      break;\n    case 'GET':\n    case 'DELETE':\n      // only identifiers are sent\n      if (arg) {\n        variables = isCustomPrimaryKey ? [primaryKeyFieldName, ...sortKeyFieldNames].reduce((acc, fieldName) => {\n          acc[fieldName] = arg[fieldName];\n          return acc;\n        }, {}) : {\n          [primaryKeyFieldName]: arg[primaryKeyFieldName]\n        };\n      }\n      if (operation === 'DELETE') {\n        variables = {\n          input: variables\n        };\n      }\n      break;\n    case 'LIST':\n      if (arg !== null && arg !== void 0 && arg.filter) {\n        variables.filter = arg.filter;\n      }\n      if (arg !== null && arg !== void 0 && arg.sortDirection) {\n        variables.sortDirection = arg.sortDirection;\n      }\n      if (arg && arg[primaryKeyFieldName]) {\n        variables[primaryKeyFieldName] = arg[primaryKeyFieldName];\n      }\n      if (skName && arg && arg[skName]) {\n        variables[skName] = arg[skName];\n      }\n      if (arg !== null && arg !== void 0 && arg.nextToken) {\n        variables.nextToken = arg.nextToken;\n      }\n      if (arg !== null && arg !== void 0 && arg.limit) {\n        variables.limit = arg.limit;\n      }\n      break;\n    case 'INDEX_QUERY':\n      {\n        const {\n          pk,\n          sk = []\n        } = indexMeta;\n        const indexQuerySkName = (sk === null || sk === void 0 ? void 0 : sk.length) && resolvedSkName(sk);\n        variables[pk] = arg[pk];\n        if (indexQuerySkName && arg && arg[indexQuerySkName]) {\n          variables[indexQuerySkName] = arg[indexQuerySkName];\n        }\n        if (arg !== null && arg !== void 0 && arg.filter) {\n          variables.filter = arg.filter;\n        }\n        if (arg !== null && arg !== void 0 && arg.sortDirection) {\n          variables.sortDirection = arg.sortDirection;\n        }\n        if (arg !== null && arg !== void 0 && arg.nextToken) {\n          variables.nextToken = arg.nextToken;\n        }\n        if (arg !== null && arg !== void 0 && arg.limit) {\n          variables.limit = arg.limit;\n        }\n        break;\n      }\n    case 'ONCREATE':\n    case 'ONUPDATE':\n    case 'ONDELETE':\n      if (arg !== null && arg !== void 0 && arg.filter) {\n        variables = {\n          filter: arg.filter\n        };\n      }\n      break;\n    case 'OBSERVEQUERY':\n      throw new Error('Internal error: Attempted to build variables for observeQuery. Please report this error.');\n    default:\n      {\n        const exhaustiveCheck = operation;\n        throw new Error(\"Unhandled operation case: \".concat(exhaustiveCheck));\n      }\n  }\n  return variables;\n}\n/**\n * Iterates over mutation input values and resolves any model inputs to their corresponding join fields/values\n *\n * @example\n * ### Usage\n * ```ts\n * const result = normalizeMutationInput({ post: post }, model, modelDefinition);\n * ```\n * ### Result\n * ```ts\n * { postId: \"abc123\" }\n * ```\n *\n */\nfunction normalizeMutationInput(mutationInput, model, modelIntrospection) {\n  const {\n    fields\n  } = model;\n  const normalized = {};\n  Object.entries(mutationInput).forEach(_ref9 => {\n    var _fields$inputFieldNam;\n    let [inputFieldName, inputValue] = _ref9;\n    const fieldType = (_fields$inputFieldNam = fields[inputFieldName]) === null || _fields$inputFieldNam === void 0 ? void 0 : _fields$inputFieldNam.type;\n    const relatedModelName = fieldType === null || fieldType === void 0 ? void 0 : fieldType.model;\n    if (relatedModelName) {\n      var _fields$inputFieldNam2;\n      const association = (_fields$inputFieldNam2 = fields[inputFieldName]) === null || _fields$inputFieldNam2 === void 0 ? void 0 : _fields$inputFieldNam2.association;\n      const relatedModelDef = modelIntrospection.models[relatedModelName];\n      const relatedModelPkInfo = relatedModelDef.primaryKeyInfo;\n      if ((association === null || association === void 0 ? void 0 : association.connectionType) === connectionType.HAS_ONE) {\n        const associationHasOne = association;\n        associationHasOne.targetNames.forEach((targetName, idx) => {\n          const associatedFieldName = associationHasOne.associatedWith[idx];\n          normalized[targetName] = inputValue[associatedFieldName];\n        });\n      }\n      if ((association === null || association === void 0 ? void 0 : association.connectionType) === connectionType.BELONGS_TO) {\n        const associationBelongsTo = association;\n        associationBelongsTo.targetNames.forEach((targetName, idx) => {\n          if (idx === 0) {\n            const associatedFieldName = relatedModelPkInfo.primaryKeyFieldName;\n            normalized[targetName] = inputValue[associatedFieldName];\n          } else {\n            const associatedFieldName = relatedModelPkInfo.sortKeyFieldNames[idx - 1];\n            normalized[targetName] = inputValue[associatedFieldName];\n          }\n        });\n      }\n    } else {\n      normalized[inputFieldName] = inputValue;\n    }\n  });\n  return normalized;\n}\n/**\n * Produces a parameter object that can contains auth mode/token overrides\n * only if present in either `options` (first) or configured on the `client`\n * as a fallback.\n *\n * @param client Configured client from `generateClient`\n * @param options Args/Options object from call site.\n * @returns\n */\nfunction authModeParams(client, getInternals) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const internals = getInternals(client);\n  return {\n    authMode: options.authMode || internals.authMode,\n    authToken: options.authToken || internals.authToken\n  };\n}\n/**\n * Retrieves custom headers from either the client or request options.\n * @param client V6Client | V6ClientSSRRequest | V6ClientSSRCookies - for extracting client headers\n * @param requestHeaders {@link CustomHeaders} - request headers\n * @returns custom headers as {@link CustomHeaders}\n */\nfunction getCustomHeaders(client, getInternals, requestHeaders) {\n  let headers = getInternals(client).headers || {};\n  // Individual request headers will take precedence over client headers.\n  // We intentionally do *not* merge client and request headers.\n  if (requestHeaders) {\n    headers = requestHeaders;\n  }\n  return headers;\n}\nexport { authModeParams, buildGraphQLVariables, customSelectionSetToIR, flattenItems, generateGraphQLDocument, generateSelectionSet, getCustomHeaders, getDefaultSelectionSetForNonModelWithIR, graphQLOperationsInfo, initializeModel, normalizeMutationInput, selectionSetIRToString };","map":{"version":3,"names":["connectionType","HAS_ONE","HAS_MANY","BELONGS_TO","skGraphQlFieldTypeMap","ID","String","AWSDate","AWSTime","AWSDateTime","AWSTimestamp","AWSEmail","AWSPhone","AWSURL","AWSIPAddress","AWSJSON","Boolean","Int","Float","resolvedSkName","sk","length","reduce","acc","curr","idx","capitalize","flattenItems","modelIntrospection","modelName","modelRecord","mapped","fieldName","value","Object","entries","_modelIntrospection$m","fieldDef","models","fields","undefined","dvPair","isRelatedModelItemsArrayPair","items","map","itemValue","type","model","isRelatedModelProperty","dv","_dv$fieldDef","_dv$value","isArray","Array","initializeModel","client","result","authMode","authToken","context","arguments","introModel","introModelFields","modelFields","filter","_ref","_field$type","_","field","_ref2","record","initializedRelationshipFields","_modelField$associati","modelField","modelFieldType","relatedModelName","relatedModel","relatedModelPKFieldName","primaryKeyInfo","primaryKeyFieldName","relatedModelSKFieldNames","sortKeyFieldNames","relationType","association","connectionFields","associatedWith","targetNames","push","_client$models$relate","sortKeyValues","curVal","get","contextSpec","options","_objectSpread","data","_client$models$relate3","mapResult","shift","errors","extensions","parentPk","parentSK","relatedModelField","relatedModelFieldType","_client$models$relate2","relatedTargetNames","_relatedModelField$as","hasManyFilter","eq","list","selfAwareAsync","resultPromise","basePromise","and","limit","nextToken","extendedBase","extendCancellability","graphQLOperationsInfo","CREATE","operationPrefix","usePlural","GET","UPDATE","DELETE","LIST","INDEX_QUERY","ONCREATE","ONUPDATE","ONDELETE","OBSERVEQUERY","SELECTION_SET_WILDCARD","getDefaultSelectionSetForNonModelWithIR","nonModelDefinition","mappedFields","values","_ref3","name","enum","FIELD_IR","nonModel","nonModels","pair","fromEntries","getDefaultSelectionSetForModelWithIR","modelDefinition","_ref4","ownerFields","resolveOwnerFields","concat","defaultSelectionSetForModel","explicitFields","_ref5","from","Set","customSelectionSetToIR","selectionSet","dotNotationToObject","path","modelOrNonModelName","_modelIntrospection$m2","_modelOrNonModelField","_modelOrNonModelField2","rest","split","nested","modelOrNonModelDefinition","modelOrNonModelFields","relatedModelDefinition","relatedNonModel","relatedNonModelDefinition","isModelOrNonModelOrFieldType","Error","join","_modelOrNonModelField3","nestedRelatedModelDefinition","_nonModelDefinition$f","nonModelField","isOwnerField","includes","resultObj","deepMergeSelectionSetObjects","selectionSetIRToString","obj","res","forEach","_ref6","source","target","isObject","key","prototype","hasOwnProperty","call","generateSelectionSet","selSetIr","selSetString","generateGraphQLDocument","modelOperation","listArgs","indexMeta","pluralName","isCustomPrimaryKey","attributes","namePascalCase","charAt","toUpperCase","slice","pluralNamePascalCase","graphQLFieldName","indexQueryArgs","queryField","pk","skQueryArgs","skField","normalizedType","_attributes$find","compositeSkArgName","keyName","find","attr","_attr$properties","properties","graphQLOperationType","graphQLSelectionSet","graphQLArguments","selectionSetFields","getPkArgs","listPkArgs","generateSkArgs","op","fieldType","assign","sortDirection","input","toLocaleUpperCase","graphQLDocument","_ref7","keys","buildGraphQLVariables","operation","arg","skName","variables","normalizeMutationInput","_ref8","isReadOnly","indexQuerySkName","exhaustiveCheck","mutationInput","normalized","_ref9","_fields$inputFieldNam","inputFieldName","inputValue","_fields$inputFieldNam2","relatedModelDef","relatedModelPkInfo","associationHasOne","targetName","associatedFieldName","associationBelongsTo","authModeParams","getInternals","internals","getCustomHeaders","requestHeaders","headers"],"sources":["C:\\Users\\vinzl\\workspace\\machicoulis\\daily-image-collector\\node_modules\\@aws-amplify\\data-schema\\src\\runtime\\internals\\APIClient.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nimport { resolveOwnerFields, capitalize, selfAwareAsync } from '../utils';\nimport { extendCancellability } from './cancellation';\nconst connectionType = {\n    HAS_ONE: 'HAS_ONE',\n    HAS_MANY: 'HAS_MANY',\n    BELONGS_TO: 'BELONGS_TO',\n};\n// When generating an SK's KeyConditionInput name, string-like types map to String\nconst skGraphQlFieldTypeMap = {\n    ID: 'ID',\n    String: 'String',\n    AWSDate: 'String',\n    AWSTime: 'String',\n    AWSDateTime: 'String',\n    AWSTimestamp: 'Int',\n    AWSEmail: 'String',\n    AWSPhone: 'String',\n    AWSURL: 'String',\n    AWSIPAddress: 'String',\n    AWSJSON: 'String',\n    Boolean: 'Boolean',\n    Int: 'Int',\n    Float: 'Float',\n};\n// move to util\nconst resolvedSkName = (sk) => {\n    if (sk.length === 1) {\n        return sk[0];\n    }\n    else {\n        return sk.reduce((acc, curr, idx) => {\n            if (idx === 0) {\n                return curr;\n            }\n            else {\n                return acc + capitalize(curr);\n            }\n        }, '');\n    }\n};\n/**\n * Crawls a model tree, starting with a given **individual** model instance record, looking\n * for related hasMany children to extract from their `items` containers.\n *\n * E.g., if we have a record like this:\n *\n * ```js\n * {\n *   id: 'some-id',\n *   children: {\n *     items: [\n *       { name: 'a' }\n *       { name: 'b' }\n *       { name: 'c' }\n *     ]\n *   }\n * }\n * ```\n *\n * And if `children` refers to *an array of another model* (as opposed to a custom type),\n * the `items` will be extracted. We do this because `items` is just the mechanism for nesting\n * child records -- we don't want customers to have to dig the items out in application code.\n * Ultimately, we return this \"flattened\" structure:\n *\n * ```js\n * {\n *   id: 'some-id',\n *   children: [\n *     { name: 'a' }\n *     { name: 'b' }\n *     { name: 'c' }\n *   ]\n * }\n * ```\n *\n * Notably, an identical record could be the result of a nested custom type that contains an\n * `items` property. This will *not* be flattened, because in that case the `items` property is\n * actually part of the customer's schema. Similarly if a model contains an explicit `items` field.\n *\n * @param modelIntrospection Top-level model introspection schema.\n * @param modelName The name of the model. Can be `undefined`. E.g., for customOperation return types.\n * @param modelRecord The individual \"model instance record\" to normalize.\n */\nexport const flattenItems = (modelIntrospection, modelName, modelRecord) => {\n    if (!modelRecord)\n        return null;\n    const mapped = {};\n    for (const [fieldName, value] of Object.entries(modelRecord)) {\n        const fieldDef = modelName\n            ? modelIntrospection.models[modelName]?.fields[fieldName]\n            : undefined;\n        const dvPair = { fieldDef, value };\n        if (isRelatedModelItemsArrayPair(dvPair)) {\n            mapped[fieldName] = dvPair.value.items.map((itemValue) => flattenItems(modelIntrospection, dvPair.fieldDef.type.model, itemValue));\n        }\n        else if (isRelatedModelProperty(fieldDef)) {\n            mapped[fieldName] = flattenItems(modelIntrospection, fieldDef.type.model, value);\n        }\n        else {\n            mapped[fieldName] = value;\n        }\n    }\n    return mapped;\n};\n/**\n * Determines whether the given field definition and associated result value\n * represent a related model array from a HasMany-type relationship.\n *\n * @param dv Pair of field definition and associated result value\n * @returns\n */\nfunction isRelatedModelItemsArrayPair(dv) {\n    return (typeof dv.fieldDef?.type === 'object' &&\n        'model' in dv.fieldDef.type &&\n        typeof dv.fieldDef.type.model === 'string' &&\n        dv.fieldDef.isArray &&\n        Array.isArray(dv.value?.items));\n}\n/**\n * Determines whether the given field definition represents a relationship\n * to another model.\n *\n * @param fieldDef\n * @returns\n */\nfunction isRelatedModelProperty(fieldDef) {\n    return (typeof fieldDef?.type === 'object' &&\n        'model' in fieldDef.type &&\n        typeof fieldDef.type.model === 'string');\n}\n// TODO: this should accept single result to support CRUD methods; create helper for array/list\nexport function initializeModel(client, modelName, result, modelIntrospection, authMode, authToken, context = false) {\n    const introModel = modelIntrospection.models[modelName];\n    const introModelFields = introModel.fields;\n    const modelFields = Object.entries(introModelFields)\n        .filter(([_, field]) => field?.type?.model !== undefined)\n        .map(([fieldName]) => fieldName);\n    return result.map((record) => {\n        if (record === null || record === undefined) {\n            return record;\n        }\n        const initializedRelationshipFields = {};\n        for (const fieldName of modelFields) {\n            const modelField = introModelFields[fieldName];\n            const modelFieldType = modelField?.type;\n            const relatedModelName = modelFieldType.model;\n            const relatedModel = modelIntrospection.models[relatedModelName];\n            const relatedModelPKFieldName = relatedModel.primaryKeyInfo.primaryKeyFieldName;\n            const relatedModelSKFieldNames = relatedModel.primaryKeyInfo.sortKeyFieldNames;\n            const relationType = modelField.association?.connectionType;\n            let connectionFields = [];\n            if (modelField.association &&\n                'associatedWith' in modelField.association) {\n                connectionFields = modelField.association.associatedWith;\n            }\n            const targetNames = [];\n            if (modelField.association && 'targetNames' in modelField.association) {\n                targetNames.push(...modelField.association.targetNames);\n            }\n            switch (relationType) {\n                case connectionType.BELONGS_TO: {\n                    const sortKeyValues = relatedModelSKFieldNames.reduce(\n                    // TODO(Eslint): is this implementation correct?\n                    // eslint-disable-next-line array-callback-return\n                    (acc, curVal) => {\n                        if (record[curVal]) {\n                            acc[curVal] = record[curVal];\n                        }\n                        return acc;\n                    }, {});\n                    // if get is disabled on the related model\n                    if (client.models[relatedModelName]?.get === undefined) {\n                        break;\n                    }\n                    if (context) {\n                        initializedRelationshipFields[fieldName] = (contextSpec, options) => {\n                            if (record[targetNames[0]]) {\n                                return client.models[relatedModelName].get(contextSpec, {\n                                    [relatedModelPKFieldName]: record[targetNames[0]],\n                                    ...sortKeyValues,\n                                }, {\n                                    authMode: options?.authMode || authMode,\n                                    authToken: options?.authToken || authToken,\n                                });\n                            }\n                            return { data: null };\n                        };\n                    }\n                    else {\n                        initializedRelationshipFields[fieldName] = (options) => {\n                            if (record[targetNames[0]]) {\n                                return client.models[relatedModelName].get({\n                                    [relatedModelPKFieldName]: record[targetNames[0]],\n                                    ...sortKeyValues,\n                                }, {\n                                    authMode: options?.authMode || authMode,\n                                    authToken: options?.authToken || authToken,\n                                });\n                            }\n                            return { data: null };\n                        };\n                    }\n                    break;\n                }\n                case connectionType.HAS_ONE:\n                case connectionType.HAS_MANY: {\n                    /**\n                     * If the loader is a HAS_ONE, we just need to attempt to grab the first item\n                     * from the result.\n                     */\n                    const mapResult = relationType === connectionType.HAS_ONE\n                        ? (result) => {\n                            return {\n                                data: result?.data.shift() || null,\n                                errors: result.errors,\n                                extensions: result.extensions,\n                            };\n                        }\n                        : (result) => result;\n                    const parentPk = introModel.primaryKeyInfo.primaryKeyFieldName;\n                    const parentSK = introModel.primaryKeyInfo.sortKeyFieldNames;\n                    // M:N check - TODO: refactor\n                    const relatedModelField = relatedModel.fields[connectionFields[0]];\n                    const relatedModelFieldType = relatedModelField.type;\n                    if (relatedModelFieldType.model) {\n                        let relatedTargetNames = [];\n                        if (relatedModelField.association &&\n                            'targetNames' in relatedModelField.association) {\n                            relatedTargetNames = relatedModelField.association?.targetNames;\n                        }\n                        const hasManyFilter = relatedTargetNames.map((field, idx) => {\n                            if (idx === 0) {\n                                return { [field]: { eq: record[parentPk] } };\n                            }\n                            return { [field]: { eq: record[parentSK[idx - 1]] } };\n                        });\n                        // if list is disabled on the related model\n                        if (client.models[relatedModelName]?.list === undefined) {\n                            break;\n                        }\n                        if (context) {\n                            initializedRelationshipFields[fieldName] = (contextSpec, options) => {\n                                if (record[parentPk]) {\n                                    return selfAwareAsync(async (resultPromise) => {\n                                        const basePromise = client.models[relatedModelName].list(contextSpec, {\n                                            filter: { and: hasManyFilter },\n                                            limit: options?.limit,\n                                            nextToken: options?.nextToken,\n                                            authMode: options?.authMode || authMode,\n                                            authToken: options?.authToken || authToken,\n                                        });\n                                        const extendedBase = extendCancellability(basePromise, resultPromise);\n                                        return mapResult((await extendedBase));\n                                    });\n                                }\n                                return [];\n                            };\n                        }\n                        else {\n                            initializedRelationshipFields[fieldName] = (options) => {\n                                if (record[parentPk]) {\n                                    return selfAwareAsync(async (resultPromise) => {\n                                        const basePromise = client.models[relatedModelName].list({\n                                            filter: { and: hasManyFilter },\n                                            limit: options?.limit,\n                                            nextToken: options?.nextToken,\n                                            authMode: options?.authMode || authMode,\n                                            authToken: options?.authToken || authToken,\n                                        });\n                                        const extendedBase = extendCancellability(basePromise, resultPromise);\n                                        return mapResult((await extendedBase));\n                                    });\n                                }\n                                return [];\n                            };\n                        }\n                        break;\n                    }\n                    const hasManyFilter = connectionFields.map((field, idx) => {\n                        if (idx === 0) {\n                            return { [field]: { eq: record[parentPk] } };\n                        }\n                        return { [field]: { eq: record[parentSK[idx - 1]] } };\n                    });\n                    // if list is disabled on the related model\n                    if (client.models[relatedModelName]?.list === undefined) {\n                        break;\n                    }\n                    if (context) {\n                        initializedRelationshipFields[fieldName] = (contextSpec, options) => {\n                            if (record[parentPk]) {\n                                return selfAwareAsync(async (resultPromise) => {\n                                    const basePromise = client.models[relatedModelName].list(contextSpec, {\n                                        filter: { and: hasManyFilter },\n                                        limit: options?.limit,\n                                        nextToken: options?.nextToken,\n                                        authMode: options?.authMode || authMode,\n                                        authToken: options?.authToken || authToken,\n                                    });\n                                    const extendedBase = extendCancellability(basePromise, resultPromise);\n                                    return mapResult((await extendedBase));\n                                });\n                            }\n                            return [];\n                        };\n                    }\n                    else {\n                        initializedRelationshipFields[fieldName] = (options) => {\n                            if (record[parentPk]) {\n                                return selfAwareAsync(async (resultPromise) => {\n                                    const basePromise = client.models[relatedModelName].list({\n                                        filter: { and: hasManyFilter },\n                                        limit: options?.limit,\n                                        nextToken: options?.nextToken,\n                                        authMode: options?.authMode || authMode,\n                                        authToken: options?.authToken || authToken,\n                                    });\n                                    const extendedBase = extendCancellability(basePromise, resultPromise);\n                                    return mapResult((await extendedBase));\n                                });\n                            }\n                            return [];\n                        };\n                    }\n                    break;\n                }\n                default:\n                    break;\n            }\n        }\n        return { ...record, ...initializedRelationshipFields };\n    });\n}\nexport const graphQLOperationsInfo = {\n    CREATE: { operationPrefix: 'create', usePlural: false },\n    GET: { operationPrefix: 'get', usePlural: false },\n    UPDATE: { operationPrefix: 'update', usePlural: false },\n    DELETE: { operationPrefix: 'delete', usePlural: false },\n    LIST: { operationPrefix: 'list', usePlural: true },\n    INDEX_QUERY: { operationPrefix: '', usePlural: false },\n    ONCREATE: { operationPrefix: 'onCreate', usePlural: false },\n    ONUPDATE: { operationPrefix: 'onUpdate', usePlural: false },\n    ONDELETE: { operationPrefix: 'onDelete', usePlural: false },\n    OBSERVEQUERY: { operationPrefix: 'observeQuery', usePlural: false },\n};\nconst SELECTION_SET_WILDCARD = '*';\nexport const getDefaultSelectionSetForNonModelWithIR = (nonModelDefinition, modelIntrospection) => {\n    const { fields } = nonModelDefinition;\n    const mappedFields = Object.values(fields)\n        .map(({ type, name }) => {\n        if (typeof type.enum === 'string') {\n            return [name, FIELD_IR];\n        }\n        if (typeof type.nonModel === 'string') {\n            return [\n                name,\n                getDefaultSelectionSetForNonModelWithIR(modelIntrospection.nonModels[type.nonModel], modelIntrospection),\n            ];\n        }\n        if (typeof type === 'string') {\n            return [name, FIELD_IR];\n        }\n        return undefined;\n    })\n        .filter((pair) => pair !== undefined);\n    return Object.fromEntries(mappedFields);\n};\nconst getDefaultSelectionSetForModelWithIR = (modelDefinition, modelIntrospection) => {\n    const { fields } = modelDefinition;\n    const mappedFields = Object.values(fields)\n        .map(({ type, name }) => {\n        if (typeof type.enum === 'string' ||\n            typeof type === 'string') {\n            return [name, FIELD_IR];\n        }\n        if (typeof type.nonModel === 'string') {\n            return [\n                name,\n                getDefaultSelectionSetForNonModelWithIR(modelIntrospection.nonModels[type.nonModel], modelIntrospection),\n            ];\n        }\n        return undefined;\n    })\n        .filter((pair) => pair !== undefined);\n    const ownerFields = resolveOwnerFields(modelDefinition).map((field) => [\n        field,\n        FIELD_IR,\n    ]);\n    return Object.fromEntries(mappedFields.concat(ownerFields));\n};\nfunction defaultSelectionSetForModel(modelDefinition) {\n    // fields that are explicitly part of the graphql schema; not\n    // inferred from owner auth rules.\n    const { fields } = modelDefinition;\n    const explicitFields = Object.values(fields)\n        // Default selection set omits model fields\n        .map(({ type, name }) => {\n        if (typeof type === 'string')\n            return name;\n        if (typeof type === 'object') {\n            if (typeof type?.enum === 'string') {\n                return name;\n            }\n            else if (typeof type?.nonModel === 'string') {\n                return `${name}.${SELECTION_SET_WILDCARD}`;\n            }\n        }\n        return undefined;\n    })\n        .filter(Boolean);\n    // fields used for owner auth rules that may or may not also\n    // be explicit on the model.\n    const ownerFields = resolveOwnerFields(modelDefinition);\n    return Array.from(new Set(explicitFields.concat(ownerFields)));\n}\nconst FIELD_IR = '';\n/**\n * Generates nested Custom Selection Set IR from path\n *\n * @param modelDefinitions\n * @param modelName\n * @param selectionSet - array of object paths\n * @example\n * ### Given\n * `selectionSet = ['id', 'comments.post.id']`\n * ### Returns\n * ```ts\n * {\n *   id: '',\n *   comments: {\n *     items: { post: { id: '' } }\n *   }\n * }\n * ```\n */\nexport function customSelectionSetToIR(modelIntrospection, modelName, selectionSet) {\n    const dotNotationToObject = (path, modelOrNonModelName) => {\n        const [fieldName, ...rest] = path.split('.');\n        const nested = rest[0];\n        const modelOrNonModelDefinition = modelIntrospection.models[modelOrNonModelName] ??\n            modelIntrospection.nonModels[modelOrNonModelName];\n        const modelOrNonModelFields = modelOrNonModelDefinition?.fields;\n        const relatedModel = modelOrNonModelFields?.[fieldName]?.type?.model;\n        const relatedModelDefinition = modelIntrospection.models[relatedModel];\n        const relatedNonModel = modelOrNonModelFields?.[fieldName]?.type?.nonModel;\n        const relatedNonModelDefinition = modelIntrospection.nonModels[relatedNonModel];\n        const isModelOrNonModelOrFieldType = relatedModelDefinition\n            ? 'model'\n            : relatedNonModelDefinition\n                ? 'nonModel'\n                : 'field';\n        if (isModelOrNonModelOrFieldType === 'nonModel') {\n            let result = {};\n            if (!nested) {\n                throw Error(`${fieldName} must declare a wildcard (*) or a field of custom type ${relatedNonModel}`);\n            }\n            if (nested === SELECTION_SET_WILDCARD) {\n                result = {\n                    [fieldName]: getDefaultSelectionSetForNonModelWithIR(relatedNonModelDefinition, modelIntrospection),\n                };\n            }\n            else {\n                result = {\n                    [fieldName]: dotNotationToObject(rest.join('.'), relatedNonModel),\n                };\n            }\n            return result;\n        }\n        else if (isModelOrNonModelOrFieldType === 'model') {\n            let result = {};\n            if (!nested) {\n                throw Error(`${fieldName} must declare a wildcard (*) or a field of model ${relatedModel}`);\n            }\n            if (nested === SELECTION_SET_WILDCARD) {\n                const nestedRelatedModelDefinition = modelIntrospection.models[relatedModel];\n                result = {\n                    [fieldName]: getDefaultSelectionSetForModelWithIR(nestedRelatedModelDefinition, modelIntrospection),\n                };\n            }\n            else {\n                result = {\n                    [fieldName]: dotNotationToObject(rest.join('.'), relatedModel),\n                };\n            }\n            if (modelOrNonModelFields[fieldName]?.isArray) {\n                result = {\n                    [fieldName]: {\n                        items: result[fieldName],\n                    },\n                };\n            }\n            return result;\n        }\n        else {\n            const modelField = modelOrNonModelFields?.[fieldName];\n            const nonModelDefinition = modelIntrospection.nonModels[modelOrNonModelName];\n            const nonModelField = nonModelDefinition?.fields?.[fieldName];\n            if (!nonModelDefinition) {\n                const isOwnerField = resolveOwnerFields(modelOrNonModelDefinition).includes(fieldName);\n                if (!modelField && !isOwnerField) {\n                    throw Error(`${fieldName} is not a field of model ${modelOrNonModelName}`);\n                }\n            }\n            else {\n                if (!nonModelField) {\n                    throw Error(`${fieldName} is not a field of custom type ${modelOrNonModelName}`);\n                }\n            }\n            return { [fieldName]: FIELD_IR };\n        }\n    };\n    return selectionSet.reduce((resultObj, path) => deepMergeSelectionSetObjects(dotNotationToObject(path, modelName), resultObj), {});\n}\n/**\n * Stringifies selection set IR\n * * @example\n * ### Given\n * ```ts\n * {\n *   id: '',\n *   comments: {\n *     items: { post: { id: '' } }\n *   }\n * }\n * ```\n * ### Returns\n * `'id comments { items { post { id } } }'`\n */\nexport function selectionSetIRToString(obj) {\n    const res = [];\n    Object.entries(obj).forEach(([fieldName, value]) => {\n        if (value === FIELD_IR) {\n            res.push(fieldName);\n        }\n        else if (typeof value === 'object' && value !== null) {\n            if (value?.items) {\n                res.push(fieldName, '{', 'items', '{', selectionSetIRToString(value.items), '}', '}');\n            }\n            else {\n                res.push(fieldName, '{', selectionSetIRToString(value), '}');\n            }\n        }\n    });\n    return res.join(' ');\n}\n/**\n * Recursively merges selection set objects from `source` onto `target`.\n *\n * `target` will be updated. `source` will be left alone.\n *\n * @param source The object to merge into target.\n * @param target The object to be mutated.\n */\nfunction deepMergeSelectionSetObjects(source, target) {\n    const isObject = (obj) => obj && typeof obj === 'object';\n    for (const key in source) {\n        // This verification avoids 'Prototype Pollution' issue\n        if (!Object.prototype.hasOwnProperty.call(source, key))\n            continue;\n        if (Object.prototype.hasOwnProperty.call(target, key) &&\n            isObject(target[key])) {\n            deepMergeSelectionSetObjects(source[key], target[key]);\n        }\n        else {\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nexport function generateSelectionSet(modelIntrospection, modelName, selectionSet) {\n    const modelDefinition = modelIntrospection.models[modelName];\n    const selSetIr = customSelectionSetToIR(modelIntrospection, modelName, selectionSet ?? defaultSelectionSetForModel(modelDefinition));\n    const selSetString = selectionSetIRToString(selSetIr);\n    return selSetString;\n}\nexport function generateGraphQLDocument(modelIntrospection, modelDefinition, modelOperation, listArgs, indexMeta) {\n    const { name, pluralName, fields, primaryKeyInfo: { isCustomPrimaryKey, primaryKeyFieldName, sortKeyFieldNames, }, attributes, } = modelDefinition;\n    // Use pascal case of the model name to generate the operations and the arguments.\n    // This is required to be in sync with the resources generated by the GraphQL transformers.\n    const namePascalCase = name.charAt(0).toUpperCase() + name.slice(1);\n    const pluralNamePascalCase = pluralName.charAt(0).toUpperCase() + pluralName.slice(1);\n    const { operationPrefix, usePlural } = graphQLOperationsInfo[modelOperation];\n    const { selectionSet } = listArgs || {};\n    let graphQLFieldName;\n    let indexQueryArgs;\n    if (operationPrefix) {\n        graphQLFieldName = `${operationPrefix}${usePlural ? pluralNamePascalCase : namePascalCase}`;\n    }\n    else if (indexMeta) {\n        const { queryField, pk, sk = [] } = indexMeta;\n        graphQLFieldName = queryField;\n        /**\n         * **a. Single field SK** -> single arg where name is the field name and the type is `Model${gqlFieldType}KeyConditionInput` (nullable)\n         *  Note: string-like data types e.g.,  AWSDateTime, AWSEmail, AWSPhone, etc. should map to String. See `skGraphQlFieldTypeMap` above\n         * @example\n         * ```\n         * sk1: ModelStringKeyConditionInput\n         * ```\n         *\n         * **b. Composite SK** -> single arg where the name is camelCase concatenation of all the field names that comprise the SK\n         *  and the type is `Model${modelName}${keyAttributeName}CompositeKeyConditionInput` (nullable)\n         * @example\n         * ```\n         * sk1Sk2: ModelMyModelMyModelByPkAndSk1AndSk2CompositeKeyConditionInput\n         */\n        let skQueryArgs = {};\n        if (sk.length === 1) {\n            const [skField] = sk;\n            const type = (typeof fields[skField].type === 'string'\n                ? fields[skField].type\n                : 'String');\n            const normalizedType = skGraphQlFieldTypeMap[type];\n            skQueryArgs = {\n                [skField]: `Model${normalizedType}KeyConditionInput`,\n            };\n        }\n        else if (sk.length > 1) {\n            const compositeSkArgName = resolvedSkName(sk);\n            const keyName = attributes?.find((attr) => attr?.properties?.queryField === queryField)?.properties?.name;\n            skQueryArgs = {\n                [compositeSkArgName]: `Model${capitalize(name)}${capitalize(keyName)}CompositeKeyConditionInput`,\n            };\n        }\n        indexQueryArgs = {\n            [pk]: `${Object.prototype.hasOwnProperty.call(fields[pk].type, 'enum')\n                ? fields[pk].type.enum // AppSync schema sets enum type as the type of the enum fields that's used as PK\n                : fields[pk].type}!`,\n            ...skQueryArgs,\n        };\n    }\n    else {\n        throw new Error('Error generating GraphQL Document - invalid operation name');\n    }\n    let graphQLOperationType;\n    let graphQLSelectionSet;\n    let graphQLArguments;\n    const selectionSetFields = generateSelectionSet(modelIntrospection, name, selectionSet);\n    // default PK args for get and list operations\n    // modified below for CPK\n    const getPkArgs = {\n        [primaryKeyFieldName]: `${fields[primaryKeyFieldName].type}!`,\n    };\n    const listPkArgs = {};\n    /**\n     * Generate query field args for the SK if it's defined\n     *\n     * **1. Get queries** require each SK field to be present as a separate arg where the type is the field's GraphQL scalar type (non-nullable)\n     * @example\n     * ```\n     * sk1: String!, sk2: Int!\n     * ```\n     *\n     * **2. List queries**\n     *\n     * **a. Single field SK** -> single arg where name is the field name and the type is `Model${gqlFieldType}KeyConditionInput` (nullable)\n     *      Note: string-like data types e.g.,  AWSDateTime, AWSEmail, AWSPhone, etc. should map to String. See `skGraphQlFieldTypeMap` above\n     * @example\n     * ```\n     * sk1: ModelStringKeyConditionInput\n     * ```\n     *\n     * **b. Composite SK** -> single arg where the name is camelCase concatenation of all the field names that comprise the SK\n     *  and the type is `Model${modelName}PrimaryCompositeKeyConditionInput` (nullable)\n     * @example\n     * ```\n     * sk1Sk2: ModelMyModelPrimaryCompositeKeyConditionInput\n     * ```\n     */\n    const generateSkArgs = (op) => {\n        if (sortKeyFieldNames.length === 0)\n            return {};\n        if (op === 'get') {\n            return sortKeyFieldNames.reduce((acc, fieldName) => {\n                const fieldType = fields[fieldName].type;\n                if (op === 'get') {\n                    acc[fieldName] = `${fieldType}!`; // ! - SK args are non-nullable in Get queries\n                }\n                return acc;\n            }, {});\n        }\n        else {\n            // list SK\n            if (sortKeyFieldNames.length === 1) {\n                // Single SK\n                const [sk] = sortKeyFieldNames;\n                const type = (typeof fields[sk].type === 'string' ? fields[sk].type : 'String');\n                const normalizedType = skGraphQlFieldTypeMap[type];\n                return {\n                    [sk]: `Model${normalizedType}KeyConditionInput`,\n                };\n            }\n            else {\n                // Composite SK\n                const compositeSkArgName = resolvedSkName(sortKeyFieldNames);\n                return {\n                    [compositeSkArgName]: `Model${capitalize(name)}PrimaryCompositeKeyConditionInput`,\n                };\n            }\n        }\n    };\n    if (isCustomPrimaryKey) {\n        Object.assign(getPkArgs, generateSkArgs('get'));\n        Object.assign(listPkArgs, {\n            // PK is only included in list query field args in the generated GQL\n            // when explicitly specifying PK with .identifier(['fieldName']) or @primaryKey in the schema definition\n            [primaryKeyFieldName]: `${fields[primaryKeyFieldName].type}`, // PK is always a nullable arg for list (no `!` after the type)\n            sortDirection: 'ModelSortDirection',\n        }, generateSkArgs('list'));\n    }\n    switch (modelOperation) {\n        case 'CREATE':\n        case 'UPDATE':\n        case 'DELETE':\n            graphQLArguments ??\n                (graphQLArguments = {\n                    input: `${operationPrefix.charAt(0).toLocaleUpperCase() +\n                        operationPrefix.slice(1)}${namePascalCase}Input!`,\n                });\n            graphQLOperationType ?? (graphQLOperationType = 'mutation');\n        // TODO(Eslint): this this case clause correct without the break statement?\n        // eslint-disable-next-line no-fallthrough\n        case 'GET':\n            graphQLArguments ?? (graphQLArguments = getPkArgs);\n            graphQLSelectionSet ?? (graphQLSelectionSet = selectionSetFields);\n        // TODO(Eslint): this this case clause correct without the break statement?\n        // eslint-disable-next-line no-fallthrough\n        case 'LIST':\n            graphQLArguments ??\n                (graphQLArguments = {\n                    ...listPkArgs,\n                    // eslint doesn't like the ts-ignore, because it thinks it's unnecessary.\n                    // But TS doesn't like the `filter: ...` because it think it will always be\n                    // overwritten. (it won't be.) so, we need to ignore the TS error and then\n                    // ignore the eslint error on the ts-ignore.\n                    // eslint-disable-next-line\n                    // @ts-ignore\n                    filter: `Model${namePascalCase}FilterInput`,\n                    limit: 'Int',\n                    nextToken: 'String',\n                });\n            graphQLOperationType ?? (graphQLOperationType = 'query');\n            graphQLSelectionSet ??\n                (graphQLSelectionSet = `items { ${selectionSetFields} } nextToken __typename`);\n        // TODO(Eslint): this this case clause correct without the break statement?\n        // eslint-disable-next-line no-fallthrough\n        case 'INDEX_QUERY':\n            graphQLArguments ??\n                (graphQLArguments = {\n                    ...indexQueryArgs,\n                    filter: `Model${namePascalCase}FilterInput`,\n                    sortDirection: 'ModelSortDirection',\n                    limit: 'Int',\n                    nextToken: 'String',\n                });\n            graphQLOperationType ?? (graphQLOperationType = 'query');\n            graphQLSelectionSet ??\n                (graphQLSelectionSet = `items { ${selectionSetFields} } nextToken __typename`);\n        // TODO(Eslint): this this case clause correct without the break statement?\n        // eslint-disable-next-line no-fallthrough\n        case 'ONCREATE':\n        case 'ONUPDATE':\n        case 'ONDELETE':\n            graphQLArguments ??\n                (graphQLArguments = {\n                    filter: `ModelSubscription${namePascalCase}FilterInput`,\n                });\n            graphQLOperationType ?? (graphQLOperationType = 'subscription');\n            graphQLSelectionSet ?? (graphQLSelectionSet = selectionSetFields);\n            break;\n        case 'OBSERVEQUERY':\n        default:\n            throw new Error('Internal error: Attempted to generate graphql document for observeQuery. Please report this error.');\n    }\n    const graphQLDocument = `${graphQLOperationType}${graphQLArguments\n        ? `(${Object.entries(graphQLArguments).map(([fieldName, type]) => `$${fieldName}: ${type}`)})`\n        : ''} { ${graphQLFieldName}${graphQLArguments\n        ? `(${Object.keys(graphQLArguments).map((fieldName) => `${fieldName}: $${fieldName}`)})`\n        : ''} { ${graphQLSelectionSet} } }`;\n    return graphQLDocument;\n}\nexport function buildGraphQLVariables(modelDefinition, operation, arg, modelIntrospection, indexMeta) {\n    const { fields, primaryKeyInfo: { isCustomPrimaryKey, primaryKeyFieldName, sortKeyFieldNames, }, } = modelDefinition;\n    const skName = sortKeyFieldNames?.length && resolvedSkName(sortKeyFieldNames);\n    let variables = {};\n    // TODO: process input\n    switch (operation) {\n        case 'CREATE':\n            variables = {\n                input: arg\n                    ? normalizeMutationInput(arg, modelDefinition, modelIntrospection)\n                    : {},\n            };\n            break;\n        case 'UPDATE':\n            // readonly fields are not  updated\n            variables = {\n                input: arg\n                    ? Object.fromEntries(Object.entries(normalizeMutationInput(arg, modelDefinition, modelIntrospection)).filter(([fieldName]) => {\n                        // omit field from update input\n                        // if exists in fields and marked read only\n                        // if does not exist in fields but implicitly added to schema via ownership\n                        return fields[fieldName]\n                            ? !fields[fieldName].isReadOnly\n                            : !resolveOwnerFields(modelDefinition).includes(fieldName);\n                    }))\n                    : {},\n            };\n            break;\n        case 'GET':\n        case 'DELETE':\n            // only identifiers are sent\n            if (arg) {\n                variables = isCustomPrimaryKey\n                    ? [primaryKeyFieldName, ...sortKeyFieldNames].reduce((acc, fieldName) => {\n                        acc[fieldName] = arg[fieldName];\n                        return acc;\n                    }, {})\n                    : { [primaryKeyFieldName]: arg[primaryKeyFieldName] };\n            }\n            if (operation === 'DELETE') {\n                variables = { input: variables };\n            }\n            break;\n        case 'LIST':\n            if (arg?.filter) {\n                variables.filter = arg.filter;\n            }\n            if (arg?.sortDirection) {\n                variables.sortDirection = arg.sortDirection;\n            }\n            if (arg && arg[primaryKeyFieldName]) {\n                variables[primaryKeyFieldName] = arg[primaryKeyFieldName];\n            }\n            if (skName && arg && arg[skName]) {\n                variables[skName] = arg[skName];\n            }\n            if (arg?.nextToken) {\n                variables.nextToken = arg.nextToken;\n            }\n            if (arg?.limit) {\n                variables.limit = arg.limit;\n            }\n            break;\n        case 'INDEX_QUERY': {\n            const { pk, sk = [] } = indexMeta;\n            const indexQuerySkName = sk?.length && resolvedSkName(sk);\n            variables[pk] = arg[pk];\n            if (indexQuerySkName && arg && arg[indexQuerySkName]) {\n                variables[indexQuerySkName] = arg[indexQuerySkName];\n            }\n            if (arg?.filter) {\n                variables.filter = arg.filter;\n            }\n            if (arg?.sortDirection) {\n                variables.sortDirection = arg.sortDirection;\n            }\n            if (arg?.nextToken) {\n                variables.nextToken = arg.nextToken;\n            }\n            if (arg?.limit) {\n                variables.limit = arg.limit;\n            }\n            break;\n        }\n        case 'ONCREATE':\n        case 'ONUPDATE':\n        case 'ONDELETE':\n            if (arg?.filter) {\n                variables = { filter: arg.filter };\n            }\n            break;\n        case 'OBSERVEQUERY':\n            throw new Error('Internal error: Attempted to build variables for observeQuery. Please report this error.');\n        default: {\n            const exhaustiveCheck = operation;\n            throw new Error(`Unhandled operation case: ${exhaustiveCheck}`);\n        }\n    }\n    return variables;\n}\n/**\n * Iterates over mutation input values and resolves any model inputs to their corresponding join fields/values\n *\n * @example\n * ### Usage\n * ```ts\n * const result = normalizeMutationInput({ post: post }, model, modelDefinition);\n * ```\n * ### Result\n * ```ts\n * { postId: \"abc123\" }\n * ```\n *\n */\nexport function normalizeMutationInput(mutationInput, model, modelIntrospection) {\n    const { fields } = model;\n    const normalized = {};\n    Object.entries(mutationInput).forEach(([inputFieldName, inputValue]) => {\n        const fieldType = fields[inputFieldName]?.type;\n        const relatedModelName = fieldType?.model;\n        if (relatedModelName) {\n            const association = fields[inputFieldName]?.association;\n            const relatedModelDef = modelIntrospection.models[relatedModelName];\n            const relatedModelPkInfo = relatedModelDef.primaryKeyInfo;\n            if (association?.connectionType === connectionType.HAS_ONE) {\n                const associationHasOne = association;\n                associationHasOne.targetNames.forEach((targetName, idx) => {\n                    const associatedFieldName = associationHasOne.associatedWith[idx];\n                    normalized[targetName] = inputValue[associatedFieldName];\n                });\n            }\n            if (association?.connectionType === connectionType.BELONGS_TO) {\n                const associationBelongsTo = association;\n                associationBelongsTo.targetNames.forEach((targetName, idx) => {\n                    if (idx === 0) {\n                        const associatedFieldName = relatedModelPkInfo.primaryKeyFieldName;\n                        normalized[targetName] = inputValue[associatedFieldName];\n                    }\n                    else {\n                        const associatedFieldName = relatedModelPkInfo.sortKeyFieldNames[idx - 1];\n                        normalized[targetName] = inputValue[associatedFieldName];\n                    }\n                });\n            }\n        }\n        else {\n            normalized[inputFieldName] = inputValue;\n        }\n    });\n    return normalized;\n}\n/**\n * Produces a parameter object that can contains auth mode/token overrides\n * only if present in either `options` (first) or configured on the `client`\n * as a fallback.\n *\n * @param client Configured client from `generateClient`\n * @param options Args/Options object from call site.\n * @returns\n */\nexport function authModeParams(client, getInternals, options = {}) {\n    const internals = getInternals(client);\n    return {\n        authMode: options.authMode || internals.authMode,\n        authToken: options.authToken || internals.authToken,\n    };\n}\n/**\n * Retrieves custom headers from either the client or request options.\n * @param client V6Client | V6ClientSSRRequest | V6ClientSSRCookies - for extracting client headers\n * @param requestHeaders {@link CustomHeaders} - request headers\n * @returns custom headers as {@link CustomHeaders}\n */\nexport function getCustomHeaders(client, getInternals, requestHeaders) {\n    let headers = getInternals(client).headers || {};\n    // Individual request headers will take precedence over client headers.\n    // We intentionally do *not* merge client and request headers.\n    if (requestHeaders) {\n        headers = requestHeaders;\n    }\n    return headers;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}