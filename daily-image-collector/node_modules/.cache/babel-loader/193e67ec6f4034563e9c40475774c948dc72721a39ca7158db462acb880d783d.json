{"ast":null,"code":"'use strict';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.observeFrameworkChanges = exports.detectFramework = exports.frameworkChangeObservers = void 0;\nexports.clearCache = clearCache;\nconst types_1 = require(\"./types\");\nconst detection_1 = require(\"./detection\");\n// We want to cache detection since the framework won't change\nlet frameworkCache;\nexports.frameworkChangeObservers = [];\n// Setup the detection reset tracking / timeout delays\nlet resetTriggered = false;\nconst SSR_RESET_TIMEOUT = 10; // ms\nconst WEB_RESET_TIMEOUT = 10; // ms\nconst PRIME_FRAMEWORK_DELAY = 1000; // ms\nconst detectFramework = () => {\n  if (!frameworkCache) {\n    frameworkCache = (0, detection_1.detect)();\n    if (resetTriggered) {\n      // The final run of detectFramework:\n      // Starting from this point, the `frameworkCache` becomes \"final\".\n      // So we don't need to notify the observers again so the observer\n      // can be removed after the final notice.\n      while (exports.frameworkChangeObservers.length) {\n        exports.frameworkChangeObservers.pop()?.();\n      }\n    } else {\n      // The first run of detectFramework:\n      // Every time we update the cache, call each observer function\n      exports.frameworkChangeObservers.forEach(fcn => {\n        fcn();\n      });\n    }\n    // Retry once for either Unknown type after a delay (explained below)\n    resetTimeout(types_1.Framework.ServerSideUnknown, SSR_RESET_TIMEOUT);\n    resetTimeout(types_1.Framework.WebUnknown, WEB_RESET_TIMEOUT);\n  }\n  return frameworkCache;\n};\nexports.detectFramework = detectFramework;\n/**\n * @internal Setup observer callback that will be called everytime the framework changes\n */\nconst observeFrameworkChanges = fcn => {\n  // When the `frameworkCache` won't be updated again, we ignore all incoming\n  // observers.\n  if (resetTriggered) {\n    return;\n  }\n  exports.frameworkChangeObservers.push(fcn);\n};\nexports.observeFrameworkChanges = observeFrameworkChanges;\nfunction clearCache() {\n  frameworkCache = undefined;\n}\n// For a framework type and a delay amount, setup the event to re-detect\n//   During the runtime boot, it is possible that framework detection will\n//   be triggered before the framework has made modifications to the\n//   global/window/etc needed for detection. When no framework is detected\n//   we will reset and try again to ensure we don't use a cached\n//   non-framework detection result for all requests.\nfunction resetTimeout(framework, delay) {\n  if (frameworkCache === framework && !resetTriggered) {\n    setTimeout(() => {\n      clearCache();\n      resetTriggered = true;\n      setTimeout(exports.detectFramework, PRIME_FRAMEWORK_DELAY);\n    }, delay);\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","observeFrameworkChanges","detectFramework","frameworkChangeObservers","clearCache","types_1","require","detection_1","frameworkCache","resetTriggered","SSR_RESET_TIMEOUT","WEB_RESET_TIMEOUT","PRIME_FRAMEWORK_DELAY","detect","length","pop","forEach","fcn","resetTimeout","Framework","ServerSideUnknown","WebUnknown","push","undefined","framework","delay","setTimeout"],"sources":["C:\\Users\\vinzl\\workspace\\machicoulis\\daily-image-collector\\node_modules\\@aws-amplify\\core\\src\\Platform\\detectFramework.ts"],"sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.observeFrameworkChanges = exports.detectFramework = exports.frameworkChangeObservers = void 0;\nexports.clearCache = clearCache;\nconst types_1 = require(\"./types\");\nconst detection_1 = require(\"./detection\");\n// We want to cache detection since the framework won't change\nlet frameworkCache;\nexports.frameworkChangeObservers = [];\n// Setup the detection reset tracking / timeout delays\nlet resetTriggered = false;\nconst SSR_RESET_TIMEOUT = 10; // ms\nconst WEB_RESET_TIMEOUT = 10; // ms\nconst PRIME_FRAMEWORK_DELAY = 1000; // ms\nconst detectFramework = () => {\n    if (!frameworkCache) {\n        frameworkCache = (0, detection_1.detect)();\n        if (resetTriggered) {\n            // The final run of detectFramework:\n            // Starting from this point, the `frameworkCache` becomes \"final\".\n            // So we don't need to notify the observers again so the observer\n            // can be removed after the final notice.\n            while (exports.frameworkChangeObservers.length) {\n                exports.frameworkChangeObservers.pop()?.();\n            }\n        }\n        else {\n            // The first run of detectFramework:\n            // Every time we update the cache, call each observer function\n            exports.frameworkChangeObservers.forEach(fcn => {\n                fcn();\n            });\n        }\n        // Retry once for either Unknown type after a delay (explained below)\n        resetTimeout(types_1.Framework.ServerSideUnknown, SSR_RESET_TIMEOUT);\n        resetTimeout(types_1.Framework.WebUnknown, WEB_RESET_TIMEOUT);\n    }\n    return frameworkCache;\n};\nexports.detectFramework = detectFramework;\n/**\n * @internal Setup observer callback that will be called everytime the framework changes\n */\nconst observeFrameworkChanges = (fcn) => {\n    // When the `frameworkCache` won't be updated again, we ignore all incoming\n    // observers.\n    if (resetTriggered) {\n        return;\n    }\n    exports.frameworkChangeObservers.push(fcn);\n};\nexports.observeFrameworkChanges = observeFrameworkChanges;\nfunction clearCache() {\n    frameworkCache = undefined;\n}\n// For a framework type and a delay amount, setup the event to re-detect\n//   During the runtime boot, it is possible that framework detection will\n//   be triggered before the framework has made modifications to the\n//   global/window/etc needed for detection. When no framework is detected\n//   we will reset and try again to ensure we don't use a cached\n//   non-framework detection result for all requests.\nfunction resetTimeout(framework, delay) {\n    if (frameworkCache === framework && !resetTriggered) {\n        setTimeout(() => {\n            clearCache();\n            resetTriggered = true;\n            setTimeout(exports.detectFramework, PRIME_FRAMEWORK_DELAY);\n        }, delay);\n    }\n}\n"],"mappings":";;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAI,CAAE,CAAC;AAC7DD,OAAO,CAACE,uBAAuB,GAAGF,OAAO,CAACG,eAAe,GAAGH,OAAO,CAACI,wBAAwB,GAAG,MAAM;AACrGJ,OAAO,CAACK,UAAU,GAAGA,UAAU;AAC/B,MAAMC,OAAO,GAAGC,OAAO,CAAC,SAAS,CAAC;AAClC,MAAMC,WAAW,GAAGD,OAAO,CAAC,aAAa,CAAC;AAC1C;AACA,IAAIE,cAAc;AAClBT,OAAO,CAACI,wBAAwB,GAAG,EAAE;AACrC;AACA,IAAIM,cAAc,GAAG,KAAK;AAC1B,MAAMC,iBAAiB,GAAG,EAAE,CAAC;AAC7B,MAAMC,iBAAiB,GAAG,EAAE,CAAC;AAC7B,MAAMC,qBAAqB,GAAG,IAAI,CAAC;AACnC,MAAMV,eAAe,GAAGA,CAAA,KAAM;EAC1B,IAAI,CAACM,cAAc,EAAE;IACjBA,cAAc,GAAG,IAAID,WAAW,CAACM,MAAM,GAAG;IAC1C,IAAIJ,cAAc,EAAE;MAC5B;MACA;MACA;MACA;MACY,OAAOV,OAAO,CAACI,wBAAwB,CAACW,MAAM,EAAE;QAC5Cf,OAAO,CAACI,wBAAwB,CAACY,GAAG,EAAE,IAAI;MAC1D;IACA,OACa;MACb;MACA;MACYhB,OAAO,CAACI,wBAAwB,CAACa,OAAO,CAACC,GAAG,IAAI;QAC5CA,GAAG,EAAE;MACrB,CAAa,CAAC;IACd;IACA;IACQC,YAAY,CAACb,OAAO,CAACc,SAAS,CAACC,iBAAiB,EAAEV,iBAAiB,CAAC;IACpEQ,YAAY,CAACb,OAAO,CAACc,SAAS,CAACE,UAAU,EAAEV,iBAAiB,CAAC;EACrE;EACI,OAAOH,cAAc;AACzB,CAAC;AACDT,OAAO,CAACG,eAAe,GAAGA,eAAe;AACzC;AACA;AACA;AACA,MAAMD,uBAAuB,GAAIgB,GAAG,IAAK;EACzC;EACA;EACI,IAAIR,cAAc,EAAE;IAChB;EACR;EACIV,OAAO,CAACI,wBAAwB,CAACmB,IAAI,CAACL,GAAG,CAAC;AAC9C,CAAC;AACDlB,OAAO,CAACE,uBAAuB,GAAGA,uBAAuB;AACzD,SAASG,UAAUA,CAAA,EAAG;EAClBI,cAAc,GAAGe,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASL,YAAYA,CAACM,SAAS,EAAEC,KAAK,EAAE;EACpC,IAAIjB,cAAc,KAAKgB,SAAS,IAAI,CAACf,cAAc,EAAE;IACjDiB,UAAU,CAAC,MAAM;MACbtB,UAAU,EAAE;MACZK,cAAc,GAAG,IAAI;MACrBiB,UAAU,CAAC3B,OAAO,CAACG,eAAe,EAAEU,qBAAqB,CAAC;IACtE,CAAS,EAAEa,KAAK,CAAC;EACjB;AACA","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}