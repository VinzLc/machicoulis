{"ast":null,"code":"'use strict';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.removeCachedUpload = exports.cacheMultipartUpload = exports.getUploadsCacheKey = exports.serializeUploadOptions = exports.findCachedUploadPartsAndEvictExpired = void 0;\nconst constants_1 = require(\"../../../../utils/constants\");\nconst s3data_1 = require(\"../../../../utils/client/s3data\");\nconst utils_1 = require(\"../../../../../../utils\");\nconst ONE_HOUR = 1000 * 60 * 60;\n/**\n * Find the cached multipart upload id and get the parts that have been uploaded\n * with ListParts API. If the cached upload is expired(1 hour), return null.\n */\nconst findCachedUploadPartsAndEvictExpired = async ({\n  resumableUploadsCache,\n  cacheKey,\n  s3Config,\n  bucket,\n  finalKey\n}) => {\n  const allCachedUploads = await listCachedUploadTasks(resumableUploadsCache);\n  // Evict all outdated uploads.\n  const validCachedUploads = Object.fromEntries(Object.entries(allCachedUploads).filter(([_, cacheValue]) => cacheValue.lastTouched >= Date.now() - ONE_HOUR));\n  if (Object.keys(validCachedUploads).length !== Object.keys(allCachedUploads).length) {\n    await resumableUploadsCache.setItem(constants_1.UPLOADS_STORAGE_KEY, JSON.stringify(validCachedUploads));\n  }\n  if (!validCachedUploads[cacheKey]) {\n    return null;\n  }\n  const cachedUpload = validCachedUploads[cacheKey];\n  cachedUpload.lastTouched = Date.now();\n  await resumableUploadsCache.setItem(constants_1.UPLOADS_STORAGE_KEY, JSON.stringify(validCachedUploads));\n  try {\n    const {\n      Parts = []\n    } = await (0, s3data_1.listParts)(s3Config, {\n      Bucket: bucket,\n      Key: finalKey,\n      UploadId: cachedUpload.uploadId\n    });\n    return {\n      parts: Parts,\n      uploadId: cachedUpload.uploadId,\n      finalCrc32: cachedUpload.finalCrc32\n    };\n  } catch (e) {\n    utils_1.logger.debug('failed to list cached parts, removing cached upload.');\n    await (0, exports.removeCachedUpload)(resumableUploadsCache, cacheKey);\n    return null;\n  }\n};\nexports.findCachedUploadPartsAndEvictExpired = findCachedUploadPartsAndEvictExpired;\nconst listCachedUploadTasks = async resumableUploadsCache => {\n  try {\n    return JSON.parse((await resumableUploadsCache.getItem(constants_1.UPLOADS_STORAGE_KEY)) ?? '{}');\n  } catch (e) {\n    utils_1.logger.debug('failed to parse cached uploads record.');\n    return {};\n  }\n};\n/**\n * Serialize the uploadData API options to string so it can be hashed.\n */\nconst serializeUploadOptions = (options = {}) => {\n  const unserializableOptionProperties = ['onProgress', 'resumableUploadsCache',\n  // Internally injected implementation not set by customers\n  'locationCredentialsProvider' // Internally injected implementation not set by customers\n  ];\n  const serializableOptionEntries = Object.entries(options).filter(([key]) => !unserializableOptionProperties.includes(key));\n  if (options.checksumAlgorithm === 'crc-32') {\n    // Additional options to differentiate the upload cache created before introducing the full-object checksum and\n    // after. If full-object checksum is enabled, the previous upload caches that created with composite checksum should\n    // be ignored.\n    serializableOptionEntries.push(['checksumType', 'FULL_OBJECT']);\n  }\n  const serializableOptions = Object.fromEntries(serializableOptionEntries);\n  return JSON.stringify(serializableOptions);\n};\nexports.serializeUploadOptions = serializeUploadOptions;\n/**\n * Get the cache key of a multipart upload. Data source cached by different: size, content type, bucket, access level,\n * key. If the data source is a File instance, the upload is additionally indexed by file name and last modified time.\n * So the library always created a new multipart upload if the file is modified.\n */\nconst getUploadsCacheKey = ({\n  file,\n  size,\n  contentType,\n  bucket,\n  accessLevel,\n  key,\n  optionsHash\n}) => {\n  let levelStr;\n  const resolvedContentType = contentType ?? file?.type ?? 'application/octet-stream';\n  // If no access level is defined, we're using custom gen2 access rules\n  if (accessLevel === undefined) {\n    levelStr = 'custom';\n  } else {\n    levelStr = accessLevel === 'guest' ? 'public' : accessLevel;\n  }\n  const baseId = `${optionsHash}_${size}_${resolvedContentType}_${bucket}_${levelStr}_${key}`;\n  if (file) {\n    return `${file.name}_${file.lastModified}_${baseId}`;\n  } else {\n    return baseId;\n  }\n};\nexports.getUploadsCacheKey = getUploadsCacheKey;\nconst cacheMultipartUpload = async (resumableUploadsCache, cacheKey, fileMetadata) => {\n  const cachedUploads = await listCachedUploadTasks(resumableUploadsCache);\n  cachedUploads[cacheKey] = {\n    ...fileMetadata,\n    lastTouched: Date.now()\n  };\n  await resumableUploadsCache.setItem(constants_1.UPLOADS_STORAGE_KEY, JSON.stringify(cachedUploads));\n};\nexports.cacheMultipartUpload = cacheMultipartUpload;\nconst removeCachedUpload = async (resumableUploadsCache, cacheKey) => {\n  const cachedUploads = await listCachedUploadTasks(resumableUploadsCache);\n  delete cachedUploads[cacheKey];\n  await resumableUploadsCache.setItem(constants_1.UPLOADS_STORAGE_KEY, JSON.stringify(cachedUploads));\n};\nexports.removeCachedUpload = removeCachedUpload;","map":{"version":3,"names":["Object","defineProperty","exports","value","removeCachedUpload","cacheMultipartUpload","getUploadsCacheKey","serializeUploadOptions","findCachedUploadPartsAndEvictExpired","constants_1","require","s3data_1","utils_1","ONE_HOUR","resumableUploadsCache","cacheKey","s3Config","bucket","finalKey","allCachedUploads","listCachedUploadTasks","validCachedUploads","fromEntries","entries","filter","_","cacheValue","lastTouched","Date","now","keys","length","setItem","UPLOADS_STORAGE_KEY","JSON","stringify","cachedUpload","Parts","listParts","Bucket","Key","UploadId","uploadId","parts","finalCrc32","e","logger","debug","parse","getItem","options","unserializableOptionProperties","serializableOptionEntries","key","includes","checksumAlgorithm","push","serializableOptions","file","size","contentType","accessLevel","optionsHash","levelStr","resolvedContentType","type","undefined","baseId","name","lastModified","fileMetadata","cachedUploads"],"sources":["C:\\Users\\vinzl\\workspace\\machicoulis\\daily-image-collector\\node_modules\\@aws-amplify\\storage\\src\\providers\\s3\\apis\\internal\\uploadData\\multipart\\uploadCache.ts"],"sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.removeCachedUpload = exports.cacheMultipartUpload = exports.getUploadsCacheKey = exports.serializeUploadOptions = exports.findCachedUploadPartsAndEvictExpired = void 0;\nconst constants_1 = require(\"../../../../utils/constants\");\nconst s3data_1 = require(\"../../../../utils/client/s3data\");\nconst utils_1 = require(\"../../../../../../utils\");\nconst ONE_HOUR = 1000 * 60 * 60;\n/**\n * Find the cached multipart upload id and get the parts that have been uploaded\n * with ListParts API. If the cached upload is expired(1 hour), return null.\n */\nconst findCachedUploadPartsAndEvictExpired = async ({ resumableUploadsCache, cacheKey, s3Config, bucket, finalKey, }) => {\n    const allCachedUploads = await listCachedUploadTasks(resumableUploadsCache);\n    // Evict all outdated uploads.\n    const validCachedUploads = Object.fromEntries(Object.entries(allCachedUploads).filter(([_, cacheValue]) => cacheValue.lastTouched >= Date.now() - ONE_HOUR));\n    if (Object.keys(validCachedUploads).length !==\n        Object.keys(allCachedUploads).length) {\n        await resumableUploadsCache.setItem(constants_1.UPLOADS_STORAGE_KEY, JSON.stringify(validCachedUploads));\n    }\n    if (!validCachedUploads[cacheKey]) {\n        return null;\n    }\n    const cachedUpload = validCachedUploads[cacheKey];\n    cachedUpload.lastTouched = Date.now();\n    await resumableUploadsCache.setItem(constants_1.UPLOADS_STORAGE_KEY, JSON.stringify(validCachedUploads));\n    try {\n        const { Parts = [] } = await (0, s3data_1.listParts)(s3Config, {\n            Bucket: bucket,\n            Key: finalKey,\n            UploadId: cachedUpload.uploadId,\n        });\n        return {\n            parts: Parts,\n            uploadId: cachedUpload.uploadId,\n            finalCrc32: cachedUpload.finalCrc32,\n        };\n    }\n    catch (e) {\n        utils_1.logger.debug('failed to list cached parts, removing cached upload.');\n        await (0, exports.removeCachedUpload)(resumableUploadsCache, cacheKey);\n        return null;\n    }\n};\nexports.findCachedUploadPartsAndEvictExpired = findCachedUploadPartsAndEvictExpired;\nconst listCachedUploadTasks = async (resumableUploadsCache) => {\n    try {\n        return JSON.parse((await resumableUploadsCache.getItem(constants_1.UPLOADS_STORAGE_KEY)) ?? '{}');\n    }\n    catch (e) {\n        utils_1.logger.debug('failed to parse cached uploads record.');\n        return {};\n    }\n};\n/**\n * Serialize the uploadData API options to string so it can be hashed.\n */\nconst serializeUploadOptions = (options = {}) => {\n    const unserializableOptionProperties = [\n        'onProgress',\n        'resumableUploadsCache', // Internally injected implementation not set by customers\n        'locationCredentialsProvider', // Internally injected implementation not set by customers\n    ];\n    const serializableOptionEntries = Object.entries(options).filter(([key]) => !unserializableOptionProperties.includes(key));\n    if (options.checksumAlgorithm === 'crc-32') {\n        // Additional options to differentiate the upload cache created before introducing the full-object checksum and\n        // after. If full-object checksum is enabled, the previous upload caches that created with composite checksum should\n        // be ignored.\n        serializableOptionEntries.push(['checksumType', 'FULL_OBJECT']);\n    }\n    const serializableOptions = Object.fromEntries(serializableOptionEntries);\n    return JSON.stringify(serializableOptions);\n};\nexports.serializeUploadOptions = serializeUploadOptions;\n/**\n * Get the cache key of a multipart upload. Data source cached by different: size, content type, bucket, access level,\n * key. If the data source is a File instance, the upload is additionally indexed by file name and last modified time.\n * So the library always created a new multipart upload if the file is modified.\n */\nconst getUploadsCacheKey = ({ file, size, contentType, bucket, accessLevel, key, optionsHash, }) => {\n    let levelStr;\n    const resolvedContentType = contentType ?? file?.type ?? 'application/octet-stream';\n    // If no access level is defined, we're using custom gen2 access rules\n    if (accessLevel === undefined) {\n        levelStr = 'custom';\n    }\n    else {\n        levelStr = accessLevel === 'guest' ? 'public' : accessLevel;\n    }\n    const baseId = `${optionsHash}_${size}_${resolvedContentType}_${bucket}_${levelStr}_${key}`;\n    if (file) {\n        return `${file.name}_${file.lastModified}_${baseId}`;\n    }\n    else {\n        return baseId;\n    }\n};\nexports.getUploadsCacheKey = getUploadsCacheKey;\nconst cacheMultipartUpload = async (resumableUploadsCache, cacheKey, fileMetadata) => {\n    const cachedUploads = await listCachedUploadTasks(resumableUploadsCache);\n    cachedUploads[cacheKey] = {\n        ...fileMetadata,\n        lastTouched: Date.now(),\n    };\n    await resumableUploadsCache.setItem(constants_1.UPLOADS_STORAGE_KEY, JSON.stringify(cachedUploads));\n};\nexports.cacheMultipartUpload = cacheMultipartUpload;\nconst removeCachedUpload = async (resumableUploadsCache, cacheKey) => {\n    const cachedUploads = await listCachedUploadTasks(resumableUploadsCache);\n    delete cachedUploads[cacheKey];\n    await resumableUploadsCache.setItem(constants_1.UPLOADS_STORAGE_KEY, JSON.stringify(cachedUploads));\n};\nexports.removeCachedUpload = removeCachedUpload;\n"],"mappings":";;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAI,CAAE,CAAC;AAC7DD,OAAO,CAACE,kBAAkB,GAAGF,OAAO,CAACG,oBAAoB,GAAGH,OAAO,CAACI,kBAAkB,GAAGJ,OAAO,CAACK,sBAAsB,GAAGL,OAAO,CAACM,oCAAoC,GAAG,MAAM;AAC/K,MAAMC,WAAW,GAAGC,OAAO,CAAC,6BAA6B,CAAC;AAC1D,MAAMC,QAAQ,GAAGD,OAAO,CAAC,iCAAiC,CAAC;AAC3D,MAAME,OAAO,GAAGF,OAAO,CAAC,yBAAyB,CAAC;AAClD,MAAMG,QAAQ,GAAG,IAAI,GAAG,EAAE,GAAG,EAAE;AAC/B;AACA;AACA;AACA;AACA,MAAML,oCAAoC,GAAG,MAAAA,CAAO;EAAEM,qBAAqB;EAAEC,QAAQ;EAAEC,QAAQ;EAAEC,MAAM;EAAEC;AAAQ,CAAG,KAAK;EACrH,MAAMC,gBAAgB,GAAG,MAAMC,qBAAqB,CAACN,qBAAqB,CAAC;EAC/E;EACI,MAAMO,kBAAkB,GAAGrB,MAAM,CAACsB,WAAW,CAACtB,MAAM,CAACuB,OAAO,CAACJ,gBAAgB,CAAC,CAACK,MAAM,CAAC,CAAC,CAACC,CAAC,EAAEC,UAAU,CAAC,KAAKA,UAAU,CAACC,WAAW,IAAIC,IAAI,CAACC,GAAG,EAAE,GAAGhB,QAAQ,CAAC,CAAC;EAC5J,IAAIb,MAAM,CAAC8B,IAAI,CAACT,kBAAkB,CAAC,CAACU,MAAM,KACtC/B,MAAM,CAAC8B,IAAI,CAACX,gBAAgB,CAAC,CAACY,MAAM,EAAE;IACtC,MAAMjB,qBAAqB,CAACkB,OAAO,CAACvB,WAAW,CAACwB,mBAAmB,EAAEC,IAAI,CAACC,SAAS,CAACd,kBAAkB,CAAC,CAAC;EAChH;EACI,IAAI,CAACA,kBAAkB,CAACN,QAAQ,CAAC,EAAE;IAC/B,OAAO,IAAI;EACnB;EACI,MAAMqB,YAAY,GAAGf,kBAAkB,CAACN,QAAQ,CAAC;EACjDqB,YAAY,CAACT,WAAW,GAAGC,IAAI,CAACC,GAAG,EAAE;EACrC,MAAMf,qBAAqB,CAACkB,OAAO,CAACvB,WAAW,CAACwB,mBAAmB,EAAEC,IAAI,CAACC,SAAS,CAACd,kBAAkB,CAAC,CAAC;EACxG,IAAI;IACA,MAAM;MAAEgB,KAAK,GAAG;IAAE,CAAE,GAAG,MAAM,CAAC,CAAC,EAAE1B,QAAQ,CAAC2B,SAAS,EAAEtB,QAAQ,EAAE;MAC3DuB,MAAM,EAAEtB,MAAM;MACduB,GAAG,EAAEtB,QAAQ;MACbuB,QAAQ,EAAEL,YAAY,CAACM;IACnC,CAAS,CAAC;IACF,OAAO;MACHC,KAAK,EAAEN,KAAK;MACZK,QAAQ,EAAEN,YAAY,CAACM,QAAQ;MAC/BE,UAAU,EAAER,YAAY,CAACQ;IACrC,CAAS;EACT,EACI,OAAOC,CAAC,EAAE;IACNjC,OAAO,CAACkC,MAAM,CAACC,KAAK,CAAC,sDAAsD,CAAC;IAC5E,MAAM,IAAI7C,OAAO,CAACE,kBAAkB,EAAEU,qBAAqB,EAAEC,QAAQ,CAAC;IACtE,OAAO,IAAI;EACnB;AACA,CAAC;AACDb,OAAO,CAACM,oCAAoC,GAAGA,oCAAoC;AACnF,MAAMY,qBAAqB,GAAG,MAAON,qBAAqB,IAAK;EAC3D,IAAI;IACA,OAAOoB,IAAI,CAACc,KAAK,CAAC,CAAC,MAAMlC,qBAAqB,CAACmC,OAAO,CAACxC,WAAW,CAACwB,mBAAmB,CAAC,KAAK,IAAI,CAAC;EACzG,EACI,OAAOY,CAAC,EAAE;IACNjC,OAAO,CAACkC,MAAM,CAACC,KAAK,CAAC,wCAAwC,CAAC;IAC9D,OAAO,EAAE;EACjB;AACA,CAAC;AACD;AACA;AACA;AACA,MAAMxC,sBAAsB,GAAGA,CAAC2C,OAAO,GAAG,EAAE,KAAK;EAC7C,MAAMC,8BAA8B,GAAG,CACnC,YAAY,EACZ,uBAAuB;EAAA;EACvB,6BAA6B;EAAA,CAChC;EACD,MAAMC,yBAAyB,GAAGpD,MAAM,CAACuB,OAAO,CAAC2B,OAAO,CAAC,CAAC1B,MAAM,CAAC,CAAC,CAAC6B,GAAG,CAAC,KAAK,CAACF,8BAA8B,CAACG,QAAQ,CAACD,GAAG,CAAC,CAAC;EAC1H,IAAIH,OAAO,CAACK,iBAAiB,KAAK,QAAQ,EAAE;IAChD;IACA;IACA;IACQH,yBAAyB,CAACI,IAAI,CAAC,CAAC,cAAc,EAAE,aAAa,CAAC,CAAC;EACvE;EACI,MAAMC,mBAAmB,GAAGzD,MAAM,CAACsB,WAAW,CAAC8B,yBAAyB,CAAC;EACzE,OAAOlB,IAAI,CAACC,SAAS,CAACsB,mBAAmB,CAAC;AAC9C,CAAC;AACDvD,OAAO,CAACK,sBAAsB,GAAGA,sBAAsB;AACvD;AACA;AACA;AACA;AACA;AACA,MAAMD,kBAAkB,GAAGA,CAAC;EAAEoD,IAAI;EAAEC,IAAI;EAAEC,WAAW;EAAE3C,MAAM;EAAE4C,WAAW;EAAER,GAAG;EAAES;AAAW,CAAG,KAAK;EAChG,IAAIC,QAAQ;EACZ,MAAMC,mBAAmB,GAAGJ,WAAW,IAAIF,IAAI,EAAEO,IAAI,IAAI,0BAA0B;EACvF;EACI,IAAIJ,WAAW,KAAKK,SAAS,EAAE;IAC3BH,QAAQ,GAAG,QAAQ;EAC3B,OACS;IACDA,QAAQ,GAAGF,WAAW,KAAK,OAAO,GAAG,QAAQ,GAAGA,WAAW;EACnE;EACI,MAAMM,MAAM,GAAG,GAAGL,WAAW,IAAIH,IAAI,IAAIK,mBAAmB,IAAI/C,MAAM,IAAI8C,QAAQ,IAAIV,GAAG,EAAE;EAC3F,IAAIK,IAAI,EAAE;IACN,OAAO,GAAGA,IAAI,CAACU,IAAI,IAAIV,IAAI,CAACW,YAAY,IAAIF,MAAM,EAAE;EAC5D,OACS;IACD,OAAOA,MAAM;EACrB;AACA,CAAC;AACDjE,OAAO,CAACI,kBAAkB,GAAGA,kBAAkB;AAC/C,MAAMD,oBAAoB,GAAG,MAAAA,CAAOS,qBAAqB,EAAEC,QAAQ,EAAEuD,YAAY,KAAK;EAClF,MAAMC,aAAa,GAAG,MAAMnD,qBAAqB,CAACN,qBAAqB,CAAC;EACxEyD,aAAa,CAACxD,QAAQ,CAAC,GAAG;IACtB,GAAGuD,YAAY;IACf3C,WAAW,EAAEC,IAAI,CAACC,GAAG;EAC7B,CAAK;EACD,MAAMf,qBAAqB,CAACkB,OAAO,CAACvB,WAAW,CAACwB,mBAAmB,EAAEC,IAAI,CAACC,SAAS,CAACoC,aAAa,CAAC,CAAC;AACvG,CAAC;AACDrE,OAAO,CAACG,oBAAoB,GAAGA,oBAAoB;AACnD,MAAMD,kBAAkB,GAAG,MAAAA,CAAOU,qBAAqB,EAAEC,QAAQ,KAAK;EAClE,MAAMwD,aAAa,GAAG,MAAMnD,qBAAqB,CAACN,qBAAqB,CAAC;EACxE,OAAOyD,aAAa,CAACxD,QAAQ,CAAC;EAC9B,MAAMD,qBAAqB,CAACkB,OAAO,CAACvB,WAAW,CAACwB,mBAAmB,EAAEC,IAAI,CAACC,SAAS,CAACoC,aAAa,CAAC,CAAC;AACvG,CAAC;AACDrE,OAAO,CAACE,kBAAkB,GAAGA,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}