{"ast":null,"code":"import _objectSpread from \"C:/Users/vinzl/workspace/machicoulis/daily-image-collector/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { Observable } from 'rxjs';\nimport { GraphQLError } from 'graphql';\nimport { ConsoleLogger, Hub } from '@aws-amplify/core';\nimport { NonRetryableError, amplifyUuid, isNonRetryableError, base64Encoder, jitteredExponentialRetry, AMPLIFY_SYMBOL } from '@aws-amplify/core/internals/utils';\nimport { ConnectionState, CONTROL_MSG } from '../../types/PubSub.mjs';\nimport { SOCKET_STATUS, NON_RETRYABLE_CODES, NON_RETRYABLE_ERROR_TYPES, SUBSCRIPTION_STATUS, START_ACK_TIMEOUT, DEFAULT_KEEP_ALIVE_ALERT_TIMEOUT, MESSAGE_TYPES, MAX_DELAY_MS, CONNECTION_INIT_TIMEOUT, DEFAULT_KEEP_ALIVE_HEARTBEAT_TIMEOUT, CONNECTION_STATE_CHANGE } from '../constants.mjs';\nimport { ConnectionStateMonitor, CONNECTION_CHANGE } from '../../utils/ConnectionStateMonitor.mjs';\nimport { ReconnectionMonitor, ReconnectEvent } from '../../utils/ReconnectionMonitor.mjs';\nimport { additionalHeadersFromOptions, queryParamsFromCustomHeaders, realtimeUrlWithQueryString } from './appsyncUrl.mjs';\nimport { awsRealTimeHeaderBasedAuth } from './authHeaders.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst dispatchApiEvent = payload => {\n  Hub.dispatch('api', payload, 'PubSub', AMPLIFY_SYMBOL);\n};\nclass AWSWebSocketProvider {\n  constructor(args) {\n    this.subscriptionObserverMap = new Map();\n    this.allowNoSubscriptions = false;\n    this.socketStatus = SOCKET_STATUS.CLOSED;\n    this.keepAliveTimestamp = Date.now();\n    this.promiseArray = [];\n    this.connectionStateMonitor = new ConnectionStateMonitor();\n    this.reconnectionMonitor = new ReconnectionMonitor();\n    /**\n     * Open WebSocket connection & perform handshake\n     * Ref: https://docs.aws.amazon.com/appsync/latest/devguide/real-time-websocket-client.html#appsynclong-real-time-websocket-client-implementation-guide-for-graphql-subscriptions\n     *\n     * @param subprotocol -\n     */\n    this._establishConnection = async (awsRealTimeUrl, subprotocol) => {\n      this.logger.debug(\"Establishing WebSocket connection to \".concat(awsRealTimeUrl));\n      try {\n        await this._openConnection(awsRealTimeUrl, subprotocol);\n        await this._initiateHandshake();\n      } catch (err) {\n        const {\n          errorType,\n          errorCode\n        } = err;\n        if (NON_RETRYABLE_CODES.includes(errorCode) ||\n        // Event API does not currently return `errorCode`. This may change in the future.\n        // For now fall back to also checking known non-retryable error types\n        NON_RETRYABLE_ERROR_TYPES.includes(errorType)) {\n          throw new NonRetryableError(errorType);\n        } else if (errorType) {\n          throw new Error(errorType);\n        } else {\n          throw err;\n        }\n      }\n    };\n    this.logger = new ConsoleLogger(args.providerName);\n    this.wsProtocolName = args.wsProtocolName;\n    this.wsConnectUri = args.connectUri;\n    this.connectionStateMonitorSubscription = this._startConnectionStateMonitoring();\n  }\n  /**\n   * Mark the socket closed and release all active listeners\n   */\n  close() {\n    // Mark the socket closed both in status and the connection monitor\n    this.socketStatus = SOCKET_STATUS.CLOSED;\n    this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_FAILED);\n    // Turn off the subscription monitor Hub publishing\n    this.connectionStateMonitorSubscription.unsubscribe();\n    // Complete all reconnect observers\n    this.reconnectionMonitor.close();\n    return new Promise((resolve, reject) => {\n      if (this.awsRealTimeSocket) {\n        this.awsRealTimeSocket.onclose = _ => {\n          this._closeSocket();\n          this.subscriptionObserverMap = new Map();\n          this.awsRealTimeSocket = undefined;\n          resolve();\n        };\n        this.awsRealTimeSocket.onerror = err => {\n          reject(err);\n        };\n        this.awsRealTimeSocket.close();\n      } else {\n        resolve();\n      }\n    });\n  }\n  subscribe(options, customUserAgentDetails) {\n    return new Observable(observer => {\n      if (!(options !== null && options !== void 0 && options.appSyncGraphqlEndpoint)) {\n        observer.error({\n          errors: [_objectSpread({}, new GraphQLError(\"Subscribe only available for AWS AppSync endpoint\"))]\n        });\n        observer.complete();\n        return;\n      }\n      let subscriptionStartInProgress = false;\n      const subscriptionId = amplifyUuid();\n      const startSubscription = () => {\n        if (!subscriptionStartInProgress) {\n          subscriptionStartInProgress = true;\n          this._startSubscriptionWithAWSAppSyncRealTime({\n            options,\n            observer,\n            subscriptionId,\n            customUserAgentDetails\n          }).catch(err => {\n            this.logger.debug(\"\".concat(CONTROL_MSG.REALTIME_SUBSCRIPTION_INIT_ERROR, \": \").concat(err));\n            this._closeSocket();\n          }).finally(() => {\n            subscriptionStartInProgress = false;\n          });\n        }\n      };\n      // Add an observable to the reconnection list to manage reconnection for this subscription\n      const reconnectSubscription = new Observable(reconnectSubscriptionObserver => {\n        this.reconnectionMonitor.addObserver(reconnectSubscriptionObserver);\n      }).subscribe(() => {\n        startSubscription();\n      });\n      startSubscription();\n      return async () => {\n        await this._cleanupSubscription(subscriptionId, reconnectSubscription);\n      };\n    });\n  }\n  async connect(options) {\n    if (this.socketStatus === SOCKET_STATUS.READY) {\n      return;\n    }\n    await this._connectWebSocket(options);\n  }\n  async publish(options, customUserAgentDetails) {\n    if (this.socketStatus !== SOCKET_STATUS.READY) {\n      throw new Error('Subscription has not been initialized');\n    }\n    return this._publishMessage(options, customUserAgentDetails);\n  }\n  async _connectWebSocket(options) {\n    const {\n      apiKey,\n      appSyncGraphqlEndpoint,\n      authenticationType,\n      region\n    } = options;\n    const {\n      additionalCustomHeaders\n    } = await additionalHeadersFromOptions(options);\n    this.connectionStateMonitor.record(CONNECTION_CHANGE.OPENING_CONNECTION);\n    await this._initializeWebSocketConnection({\n      apiKey,\n      appSyncGraphqlEndpoint,\n      authenticationType,\n      region,\n      additionalCustomHeaders\n    });\n  }\n  async _publishMessage(options, customUserAgentDetails) {\n    const subscriptionId = amplifyUuid();\n    const {\n      additionalCustomHeaders,\n      libraryConfigHeaders\n    } = await additionalHeadersFromOptions(options);\n    const serializedSubscriptionMessage = await this._prepareSubscriptionPayload({\n      options,\n      subscriptionId,\n      customUserAgentDetails,\n      additionalCustomHeaders,\n      libraryConfigHeaders,\n      publish: true\n    });\n    return new Promise((resolve, reject) => {\n      if (this.awsRealTimeSocket) {\n        const publishListener = event => {\n          const data = JSON.parse(event.data);\n          if (data.id === subscriptionId && data.type === 'publish_success') {\n            this.awsRealTimeSocket && this.awsRealTimeSocket.removeEventListener('message', publishListener);\n            cleanup();\n            resolve();\n          }\n          if (data.errors && data.errors.length > 0) {\n            const errorTypes = data.errors.map(error => error.errorType);\n            cleanup();\n            reject(new Error(\"Publish errors: \".concat(errorTypes.join(', '))));\n          }\n        };\n        const errorListener = error => {\n          cleanup();\n          reject(new Error(\"WebSocket error: \".concat(error)));\n        };\n        const closeListener = () => {\n          cleanup();\n          reject(new Error('WebSocket is closed'));\n        };\n        const cleanup = () => {\n          var _this$awsRealTimeSock, _this$awsRealTimeSock2, _this$awsRealTimeSock3;\n          (_this$awsRealTimeSock = this.awsRealTimeSocket) === null || _this$awsRealTimeSock === void 0 || _this$awsRealTimeSock.removeEventListener('message', publishListener);\n          (_this$awsRealTimeSock2 = this.awsRealTimeSocket) === null || _this$awsRealTimeSock2 === void 0 || _this$awsRealTimeSock2.removeEventListener('error', errorListener);\n          (_this$awsRealTimeSock3 = this.awsRealTimeSocket) === null || _this$awsRealTimeSock3 === void 0 || _this$awsRealTimeSock3.removeEventListener('close', closeListener);\n        };\n        this.awsRealTimeSocket.addEventListener('message', publishListener);\n        this.awsRealTimeSocket.addEventListener('error', errorListener);\n        this.awsRealTimeSocket.addEventListener('close', closeListener);\n        this.awsRealTimeSocket.send(serializedSubscriptionMessage);\n      } else {\n        reject(new Error('WebSocket is not connected'));\n      }\n    });\n  }\n  async _cleanupSubscription(subscriptionId, reconnectSubscription) {\n    // Cleanup reconnection subscription\n    reconnectSubscription === null || reconnectSubscription === void 0 || reconnectSubscription.unsubscribe();\n    // Cleanup after unsubscribing or observer.complete was called after _startSubscriptionWithAWSAppSyncRealTime\n    try {\n      // Waiting that subscription has been connected before trying to unsubscribe\n      await this._waitForSubscriptionToBeConnected(subscriptionId);\n      const {\n        subscriptionState\n      } = this.subscriptionObserverMap.get(subscriptionId) || {};\n      if (!subscriptionState) {\n        // subscription already unsubscribed\n        return;\n      }\n      if (subscriptionState === SUBSCRIPTION_STATUS.CONNECTED) {\n        this._sendUnsubscriptionMessage(subscriptionId);\n      } else {\n        throw new Error('Subscription never connected');\n      }\n    } catch (err) {\n      this.logger.debug(\"Error while unsubscribing \".concat(err));\n    } finally {\n      this._removeSubscriptionObserver(subscriptionId);\n    }\n  }\n  // Monitor the connection state and pass changes along to Hub\n  _startConnectionStateMonitoring() {\n    return this.connectionStateMonitor.connectionStateObservable.subscribe(connectionState => {\n      dispatchApiEvent({\n        event: CONNECTION_STATE_CHANGE,\n        data: {\n          provider: this,\n          connectionState\n        },\n        message: \"Connection state is \".concat(connectionState)\n      });\n      this.connectionState = connectionState;\n      // Trigger START_RECONNECT when the connection is disrupted\n      if (connectionState === ConnectionState.ConnectionDisrupted) {\n        this.reconnectionMonitor.record(ReconnectEvent.START_RECONNECT);\n      }\n      // Trigger HALT_RECONNECT to halt reconnection attempts when the state is anything other than\n      // ConnectionDisrupted or Connecting\n      if ([ConnectionState.Connected, ConnectionState.ConnectedPendingDisconnect, ConnectionState.ConnectedPendingKeepAlive, ConnectionState.ConnectedPendingNetwork, ConnectionState.ConnectionDisruptedPendingNetwork, ConnectionState.Disconnected].includes(connectionState)) {\n        this.reconnectionMonitor.record(ReconnectEvent.HALT_RECONNECT);\n      }\n    });\n  }\n  async _startSubscriptionWithAWSAppSyncRealTime(_ref) {\n    var _this$subscriptionObs;\n    let {\n      options,\n      observer,\n      subscriptionId,\n      customUserAgentDetails\n    } = _ref;\n    const {\n      query,\n      variables\n    } = options;\n    this.subscriptionObserverMap.set(subscriptionId, {\n      observer,\n      query: query !== null && query !== void 0 ? query : '',\n      variables: variables !== null && variables !== void 0 ? variables : {},\n      subscriptionState: SUBSCRIPTION_STATUS.PENDING,\n      startAckTimeoutId: undefined\n    });\n    const {\n      additionalCustomHeaders,\n      libraryConfigHeaders\n    } = await additionalHeadersFromOptions(options);\n    const serializedSubscriptionMessage = await this._prepareSubscriptionPayload({\n      options,\n      subscriptionId,\n      customUserAgentDetails,\n      additionalCustomHeaders,\n      libraryConfigHeaders\n    });\n    try {\n      await this._connectWebSocket(options);\n    } catch (err) {\n      this._logStartSubscriptionError(subscriptionId, observer, err);\n      return;\n    }\n    // Potential race condition can occur when unsubscribe is called during _initializeWebSocketConnection.\n    // E.g.unsubscribe gets invoked prior to finishing WebSocket handshake or START_ACK.\n    // Both subscriptionFailedCallback and subscriptionReadyCallback are used to synchronized this.\n    const {\n      subscriptionFailedCallback,\n      subscriptionReadyCallback\n    } = (_this$subscriptionObs = this.subscriptionObserverMap.get(subscriptionId)) !== null && _this$subscriptionObs !== void 0 ? _this$subscriptionObs : {};\n    // This must be done before sending the message in order to be listening immediately\n    this.subscriptionObserverMap.set(subscriptionId, {\n      observer,\n      subscriptionState: SUBSCRIPTION_STATUS.PENDING,\n      query: query !== null && query !== void 0 ? query : '',\n      variables: variables !== null && variables !== void 0 ? variables : {},\n      subscriptionReadyCallback,\n      subscriptionFailedCallback,\n      startAckTimeoutId: setTimeout(() => {\n        this._timeoutStartSubscriptionAck(subscriptionId);\n      }, START_ACK_TIMEOUT)\n    });\n    if (this.awsRealTimeSocket) {\n      this.awsRealTimeSocket.send(serializedSubscriptionMessage);\n    }\n  }\n  // Log logic for start subscription failures\n  _logStartSubscriptionError(subscriptionId, observer, err) {\n    var _err$message;\n    this.logger.debug({\n      err\n    });\n    const message = String((_err$message = err.message) !== null && _err$message !== void 0 ? _err$message : '');\n    // Resolving to give the state observer time to propogate the update\n    this._closeSocket();\n    // Capture the error only when the network didn't cause disruption\n    if (this.connectionState !== ConnectionState.ConnectionDisruptedPendingNetwork) {\n      // When the error is non-retriable, error out the observable\n      if (isNonRetryableError(err)) {\n        observer.error({\n          errors: [_objectSpread({}, new GraphQLError(\"\".concat(CONTROL_MSG.CONNECTION_FAILED, \": \").concat(message)))]\n        });\n      } else {\n        this.logger.debug(\"\".concat(CONTROL_MSG.CONNECTION_FAILED, \": \").concat(message));\n      }\n      const {\n        subscriptionFailedCallback\n      } = this.subscriptionObserverMap.get(subscriptionId) || {};\n      // Notify concurrent unsubscription\n      if (typeof subscriptionFailedCallback === 'function') {\n        subscriptionFailedCallback();\n      }\n    }\n  }\n  // Waiting that subscription has been connected before trying to unsubscribe\n  async _waitForSubscriptionToBeConnected(subscriptionId) {\n    const subscriptionObserver = this.subscriptionObserverMap.get(subscriptionId);\n    if (subscriptionObserver) {\n      const {\n        subscriptionState\n      } = subscriptionObserver;\n      // This in case unsubscribe is invoked before sending start subscription message\n      if (subscriptionState === SUBSCRIPTION_STATUS.PENDING) {\n        return new Promise((resolve, reject) => {\n          const {\n            observer,\n            subscriptionState: observedSubscriptionState,\n            variables,\n            query\n          } = subscriptionObserver;\n          this.subscriptionObserverMap.set(subscriptionId, {\n            observer,\n            subscriptionState: observedSubscriptionState,\n            variables,\n            query,\n            subscriptionReadyCallback: resolve,\n            subscriptionFailedCallback: reject\n          });\n        });\n      }\n    }\n  }\n  _sendUnsubscriptionMessage(subscriptionId) {\n    try {\n      if (this.awsRealTimeSocket && this.awsRealTimeSocket.readyState === WebSocket.OPEN && this.socketStatus === SOCKET_STATUS.READY) {\n        // Preparing unsubscribe message to stop receiving messages for that subscription\n        const unsubscribeMessage = this._unsubscribeMessage(subscriptionId);\n        const stringToAWSRealTime = JSON.stringify(unsubscribeMessage);\n        this.awsRealTimeSocket.send(stringToAWSRealTime);\n      }\n    } catch (err) {\n      // If GQL_STOP is not sent because of disconnection issue, then there is nothing the client can do\n      this.logger.debug({\n        err\n      });\n    }\n  }\n  _removeSubscriptionObserver(subscriptionId) {\n    this.subscriptionObserverMap.delete(subscriptionId);\n    // Verifying 1000ms after removing subscription in case there are new subscription unmount/mount\n    if (!this.allowNoSubscriptions) {\n      setTimeout(this._closeSocketIfRequired.bind(this), 1000);\n    }\n  }\n  _closeSocketIfRequired() {\n    if (this.subscriptionObserverMap.size > 0) {\n      // Active subscriptions on the WebSocket\n      return;\n    }\n    if (!this.awsRealTimeSocket) {\n      this.socketStatus = SOCKET_STATUS.CLOSED;\n      return;\n    }\n    this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSING_CONNECTION);\n    if (this.awsRealTimeSocket.bufferedAmount > 0) {\n      // Still data on the WebSocket\n      setTimeout(this._closeSocketIfRequired.bind(this), 1000);\n    } else {\n      this.logger.debug('closing WebSocket...');\n      const tempSocket = this.awsRealTimeSocket;\n      // Cleaning callbacks to avoid race condition, socket still exists\n      tempSocket.onclose = null;\n      tempSocket.onerror = null;\n      tempSocket.close(1000);\n      this.awsRealTimeSocket = undefined;\n      this.socketStatus = SOCKET_STATUS.CLOSED;\n      this._closeSocket();\n    }\n  }\n  maintainKeepAlive() {\n    this.keepAliveTimestamp = Date.now();\n  }\n  keepAliveHeartbeat(connectionTimeoutMs) {\n    const currentTime = Date.now();\n    // Check for missed KA message\n    if (currentTime - this.keepAliveTimestamp > DEFAULT_KEEP_ALIVE_ALERT_TIMEOUT) {\n      this.connectionStateMonitor.record(CONNECTION_CHANGE.KEEP_ALIVE_MISSED);\n    } else {\n      this.connectionStateMonitor.record(CONNECTION_CHANGE.KEEP_ALIVE);\n    }\n    // Recognize we are disconnected if we haven't seen messages in the keep alive timeout period\n    if (currentTime - this.keepAliveTimestamp > connectionTimeoutMs) {\n      this._errorDisconnect(CONTROL_MSG.TIMEOUT_DISCONNECT);\n    }\n  }\n  _handleIncomingSubscriptionMessage(message) {\n    if (typeof message.data !== 'string') {\n      return;\n    }\n    const [isData, data] = this._handleSubscriptionData(message);\n    if (isData) {\n      this.maintainKeepAlive();\n      return;\n    }\n    const {\n      type,\n      id,\n      payload\n    } = data;\n    const {\n      observer = null,\n      query = '',\n      variables = {},\n      startAckTimeoutId,\n      subscriptionReadyCallback,\n      subscriptionFailedCallback\n    } = this.subscriptionObserverMap.get(id) || {};\n    if (type === MESSAGE_TYPES.GQL_START_ACK || type === MESSAGE_TYPES.EVENT_SUBSCRIBE_ACK) {\n      this.logger.debug(\"subscription ready for \".concat(JSON.stringify({\n        query,\n        variables\n      })));\n      if (typeof subscriptionReadyCallback === 'function') {\n        subscriptionReadyCallback();\n      }\n      if (startAckTimeoutId) clearTimeout(startAckTimeoutId);\n      dispatchApiEvent({\n        event: CONTROL_MSG.SUBSCRIPTION_ACK,\n        data: {\n          query,\n          variables\n        },\n        message: 'Connection established for subscription'\n      });\n      const subscriptionState = SUBSCRIPTION_STATUS.CONNECTED;\n      if (observer) {\n        this.subscriptionObserverMap.set(id, {\n          observer,\n          query,\n          variables,\n          startAckTimeoutId: undefined,\n          subscriptionState,\n          subscriptionReadyCallback,\n          subscriptionFailedCallback\n        });\n      }\n      this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_ESTABLISHED);\n      return;\n    }\n    if (type === MESSAGE_TYPES.GQL_CONNECTION_KEEP_ALIVE) {\n      this.maintainKeepAlive();\n      return;\n    }\n    if (type === MESSAGE_TYPES.GQL_ERROR) {\n      const subscriptionState = SUBSCRIPTION_STATUS.FAILED;\n      if (observer) {\n        this.subscriptionObserverMap.set(id, {\n          observer,\n          query,\n          variables,\n          startAckTimeoutId,\n          subscriptionReadyCallback,\n          subscriptionFailedCallback,\n          subscriptionState\n        });\n        this.logger.debug(\"\".concat(CONTROL_MSG.CONNECTION_FAILED, \": \").concat(JSON.stringify(payload !== null && payload !== void 0 ? payload : data)));\n        observer.error({\n          errors: [_objectSpread({}, new GraphQLError(\"\".concat(CONTROL_MSG.CONNECTION_FAILED, \": \").concat(JSON.stringify(payload !== null && payload !== void 0 ? payload : data))))]\n        });\n        if (startAckTimeoutId) clearTimeout(startAckTimeoutId);\n        if (typeof subscriptionFailedCallback === 'function') {\n          subscriptionFailedCallback();\n        }\n      }\n    }\n  }\n  _errorDisconnect(msg) {\n    this.logger.debug(\"Disconnect error: \".concat(msg));\n    if (this.awsRealTimeSocket) {\n      this._closeSocket();\n      this.awsRealTimeSocket.close();\n    }\n    this.socketStatus = SOCKET_STATUS.CLOSED;\n  }\n  _closeSocket() {\n    if (this.keepAliveHeartbeatIntervalId) {\n      clearInterval(this.keepAliveHeartbeatIntervalId);\n      this.keepAliveHeartbeatIntervalId = undefined;\n    }\n    this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n  }\n  _timeoutStartSubscriptionAck(subscriptionId) {\n    const subscriptionObserver = this.subscriptionObserverMap.get(subscriptionId);\n    if (subscriptionObserver) {\n      const {\n        observer,\n        query,\n        variables\n      } = subscriptionObserver;\n      if (!observer) {\n        return;\n      }\n      this.subscriptionObserverMap.set(subscriptionId, {\n        observer,\n        query,\n        variables,\n        subscriptionState: SUBSCRIPTION_STATUS.FAILED\n      });\n      this._closeSocket();\n      this.logger.debug('timeoutStartSubscription', JSON.stringify({\n        query,\n        variables\n      }));\n    }\n  }\n  _initializeWebSocketConnection(_ref2) {\n    let {\n      appSyncGraphqlEndpoint,\n      authenticationType,\n      apiKey,\n      region,\n      additionalCustomHeaders\n    } = _ref2;\n    if (this.socketStatus === SOCKET_STATUS.READY) {\n      return;\n    }\n    // TODO(Eslint): refactor to now use async function as the promise executor\n    // eslint-disable-next-line no-async-promise-executor\n    return new Promise(async (resolve, reject) => {\n      this.promiseArray.push({\n        res: resolve,\n        rej: reject\n      });\n      if (this.socketStatus === SOCKET_STATUS.CLOSED) {\n        try {\n          this.socketStatus = SOCKET_STATUS.CONNECTING;\n          // Empty payload on connect\n          const payloadString = '{}';\n          const authHeader = await awsRealTimeHeaderBasedAuth({\n            authenticationType,\n            payload: payloadString,\n            canonicalUri: this.wsConnectUri,\n            apiKey,\n            appSyncGraphqlEndpoint,\n            region,\n            additionalCustomHeaders\n          });\n          const headerString = authHeader ? JSON.stringify(authHeader) : '';\n          // base64url-encoded string\n          const encodedHeader = base64Encoder.convert(headerString, {\n            urlSafe: true,\n            skipPadding: true\n          });\n          const authTokenSubprotocol = \"header-\".concat(encodedHeader);\n          const queryParams = queryParamsFromCustomHeaders(additionalCustomHeaders);\n          const awsRealTimeUrl = realtimeUrlWithQueryString(appSyncGraphqlEndpoint, queryParams);\n          await this._establishRetryableConnection(awsRealTimeUrl, authTokenSubprotocol);\n          this.promiseArray.forEach(_ref3 => {\n            let {\n              res\n            } = _ref3;\n            this.logger.debug('Notifying connection successful');\n            res();\n          });\n          this.socketStatus = SOCKET_STATUS.READY;\n          this.promiseArray = [];\n        } catch (err) {\n          this.logger.debug('Connection exited with', err);\n          this.promiseArray.forEach(_ref4 => {\n            let {\n              rej\n            } = _ref4;\n            rej(err);\n          });\n          this.promiseArray = [];\n          if (this.awsRealTimeSocket && this.awsRealTimeSocket.readyState === WebSocket.OPEN) {\n            this.awsRealTimeSocket.close(3001);\n          }\n          this.awsRealTimeSocket = undefined;\n          this.socketStatus = SOCKET_STATUS.CLOSED;\n        }\n      }\n    });\n  }\n  async _establishRetryableConnection(awsRealTimeUrl, subprotocol) {\n    this.logger.debug(\"Establishing retryable connection\");\n    await jitteredExponentialRetry(this._establishConnection.bind(this), [awsRealTimeUrl, subprotocol], MAX_DELAY_MS);\n  }\n  async _openConnection(awsRealTimeUrl, subprotocol) {\n    return new Promise((resolve, reject) => {\n      const newSocket = this._getNewWebSocket(awsRealTimeUrl, [this.wsProtocolName, subprotocol]);\n      newSocket.onerror = () => {\n        this.logger.debug(\"WebSocket connection error\");\n      };\n      newSocket.onclose = () => {\n        this._closeSocket();\n        reject(new Error('Connection handshake error'));\n      };\n      newSocket.onopen = () => {\n        this.awsRealTimeSocket = newSocket;\n        resolve();\n      };\n    });\n  }\n  _getNewWebSocket(url, protocol) {\n    return new WebSocket(url, protocol);\n  }\n  async _initiateHandshake() {\n    return new Promise((resolve, reject) => {\n      if (!this.awsRealTimeSocket) {\n        reject(new Error('awsRealTimeSocket undefined'));\n        return;\n      }\n      let ackOk = false;\n      this.awsRealTimeSocket.onerror = error => {\n        this.logger.debug(\"WebSocket error \".concat(JSON.stringify(error)));\n      };\n      this.awsRealTimeSocket.onclose = event => {\n        this.logger.debug(\"WebSocket closed \".concat(event.reason));\n        this._closeSocket();\n        reject(new Error(JSON.stringify(event)));\n      };\n      this.awsRealTimeSocket.onmessage = message => {\n        if (typeof message.data !== 'string') {\n          return;\n        }\n        this.logger.debug(\"subscription message from AWS AppSyncRealTime: \".concat(message.data, \" \"));\n        const data = JSON.parse(message.data);\n        const {\n          type\n        } = data;\n        const connectionTimeoutMs = this._extractConnectionTimeout(data);\n        if (type === MESSAGE_TYPES.GQL_CONNECTION_ACK) {\n          ackOk = true;\n          this._registerWebsocketHandlers(connectionTimeoutMs);\n          resolve('Connected to AWS AppSyncRealTime');\n          return;\n        }\n        if (type === MESSAGE_TYPES.GQL_CONNECTION_ERROR) {\n          const {\n            errorType,\n            errorCode\n          } = this._extractErrorCodeAndType(data);\n          // TODO(Eslint): refactor to reject an Error object instead of a plain object\n          // eslint-disable-next-line prefer-promise-reject-errors\n          reject({\n            errorType,\n            errorCode\n          });\n        }\n      };\n      const gqlInit = {\n        type: MESSAGE_TYPES.GQL_CONNECTION_INIT\n      };\n      this.awsRealTimeSocket.send(JSON.stringify(gqlInit));\n      const checkAckOk = targetAckOk => {\n        if (!targetAckOk) {\n          this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_FAILED);\n          reject(new Error(\"Connection timeout: ack from AWSAppSyncRealTime was not received after \".concat(CONNECTION_INIT_TIMEOUT, \" ms\")));\n        }\n      };\n      setTimeout(() => {\n        checkAckOk(ackOk);\n      }, CONNECTION_INIT_TIMEOUT);\n    });\n  }\n  _registerWebsocketHandlers(connectionTimeoutMs) {\n    if (!this.awsRealTimeSocket) {\n      return;\n    }\n    // Set up a keep alive heartbeat for this connection\n    this.keepAliveHeartbeatIntervalId = setInterval(() => {\n      this.keepAliveHeartbeat(connectionTimeoutMs);\n    }, DEFAULT_KEEP_ALIVE_HEARTBEAT_TIMEOUT);\n    this.awsRealTimeSocket.onmessage = this._handleIncomingSubscriptionMessage.bind(this);\n    this.awsRealTimeSocket.onerror = err => {\n      this.logger.debug(err);\n      this._errorDisconnect(CONTROL_MSG.CONNECTION_CLOSED);\n    };\n    this.awsRealTimeSocket.onclose = event => {\n      this.logger.debug(\"WebSocket closed \".concat(event.reason));\n      this._closeSocket();\n      this._errorDisconnect(CONTROL_MSG.CONNECTION_CLOSED);\n    };\n  }\n}\nexport { AWSWebSocketProvider };","map":{"version":3,"names":["dispatchApiEvent","payload","Hub","dispatch","AMPLIFY_SYMBOL","AWSWebSocketProvider","constructor","args","subscriptionObserverMap","Map","allowNoSubscriptions","socketStatus","SOCKET_STATUS","CLOSED","keepAliveTimestamp","Date","now","promiseArray","connectionStateMonitor","ConnectionStateMonitor","reconnectionMonitor","ReconnectionMonitor","_establishConnection","awsRealTimeUrl","subprotocol","logger","debug","concat","_openConnection","_initiateHandshake","err","errorType","errorCode","NON_RETRYABLE_CODES","includes","NON_RETRYABLE_ERROR_TYPES","NonRetryableError","Error","ConsoleLogger","providerName","wsProtocolName","wsConnectUri","connectUri","connectionStateMonitorSubscription","_startConnectionStateMonitoring","close","record","CONNECTION_CHANGE","CONNECTION_FAILED","unsubscribe","Promise","resolve","reject","awsRealTimeSocket","onclose","_","_closeSocket","undefined","onerror","subscribe","options","customUserAgentDetails","Observable","observer","appSyncGraphqlEndpoint","error","errors","_objectSpread","GraphQLError","complete","subscriptionStartInProgress","subscriptionId","amplifyUuid","startSubscription","_startSubscriptionWithAWSAppSyncRealTime","catch","CONTROL_MSG","REALTIME_SUBSCRIPTION_INIT_ERROR","finally","reconnectSubscription","reconnectSubscriptionObserver","addObserver","_cleanupSubscription","connect","READY","_connectWebSocket","publish","_publishMessage","apiKey","authenticationType","region","additionalCustomHeaders","additionalHeadersFromOptions","OPENING_CONNECTION","_initializeWebSocketConnection","libraryConfigHeaders","serializedSubscriptionMessage","_prepareSubscriptionPayload","publishListener","event","data","JSON","parse","id","type","removeEventListener","cleanup","length","errorTypes","map","join","errorListener","closeListener","_this$awsRealTimeSock","_this$awsRealTimeSock2","_this$awsRealTimeSock3","addEventListener","send","_waitForSubscriptionToBeConnected","subscriptionState","get","SUBSCRIPTION_STATUS","CONNECTED","_sendUnsubscriptionMessage","_removeSubscriptionObserver","connectionStateObservable","connectionState","CONNECTION_STATE_CHANGE","provider","message","ConnectionState","ConnectionDisrupted","ReconnectEvent","START_RECONNECT","Connected","ConnectedPendingDisconnect","ConnectedPendingKeepAlive","ConnectedPendingNetwork","ConnectionDisruptedPendingNetwork","Disconnected","HALT_RECONNECT","_ref","_this$subscriptionObs","query","variables","set","PENDING","startAckTimeoutId","_logStartSubscriptionError","subscriptionFailedCallback","subscriptionReadyCallback","setTimeout","_timeoutStartSubscriptionAck","START_ACK_TIMEOUT","_err$message","String","isNonRetryableError","subscriptionObserver","observedSubscriptionState","readyState","WebSocket","OPEN","unsubscribeMessage","_unsubscribeMessage","stringToAWSRealTime","stringify","delete","_closeSocketIfRequired","bind","size","CLOSING_CONNECTION","bufferedAmount","tempSocket","maintainKeepAlive","keepAliveHeartbeat","connectionTimeoutMs","currentTime","DEFAULT_KEEP_ALIVE_ALERT_TIMEOUT","KEEP_ALIVE_MISSED","KEEP_ALIVE","_errorDisconnect","TIMEOUT_DISCONNECT","_handleIncomingSubscriptionMessage","isData","_handleSubscriptionData","MESSAGE_TYPES","GQL_START_ACK","EVENT_SUBSCRIBE_ACK","clearTimeout","SUBSCRIPTION_ACK","CONNECTION_ESTABLISHED","GQL_CONNECTION_KEEP_ALIVE","GQL_ERROR","FAILED","msg","keepAliveHeartbeatIntervalId","clearInterval","_ref2","push","res","rej","CONNECTING","payloadString","authHeader","awsRealTimeHeaderBasedAuth","canonicalUri","headerString","encodedHeader","base64Encoder","convert","urlSafe","skipPadding","authTokenSubprotocol","queryParams","queryParamsFromCustomHeaders","realtimeUrlWithQueryString","_establishRetryableConnection","forEach","_ref3","_ref4","jitteredExponentialRetry","MAX_DELAY_MS","newSocket","_getNewWebSocket","onopen","url","protocol","ackOk","reason","onmessage","_extractConnectionTimeout","GQL_CONNECTION_ACK","_registerWebsocketHandlers","GQL_CONNECTION_ERROR","_extractErrorCodeAndType","gqlInit","GQL_CONNECTION_INIT","checkAckOk","targetAckOk","CONNECTION_INIT_TIMEOUT","setInterval","DEFAULT_KEEP_ALIVE_HEARTBEAT_TIMEOUT","CONNECTION_CLOSED"],"sources":["C:\\Users\\vinzl\\workspace\\machicoulis\\daily-image-collector\\node_modules\\@aws-amplify\\api-graphql\\src\\Providers\\AWSWebSocketProvider\\index.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Observable } from 'rxjs';\nimport { GraphQLError } from 'graphql';\nimport { ConsoleLogger, Hub } from '@aws-amplify/core';\nimport { NonRetryableError, amplifyUuid, base64Encoder, isNonRetryableError, jitteredExponentialRetry, } from '@aws-amplify/core/internals/utils';\nimport { CONTROL_MSG, ConnectionState, } from '../../types/PubSub';\nimport { AMPLIFY_SYMBOL, CONNECTION_INIT_TIMEOUT, CONNECTION_STATE_CHANGE, DEFAULT_KEEP_ALIVE_ALERT_TIMEOUT, DEFAULT_KEEP_ALIVE_HEARTBEAT_TIMEOUT, MAX_DELAY_MS, MESSAGE_TYPES, NON_RETRYABLE_CODES, NON_RETRYABLE_ERROR_TYPES, SOCKET_STATUS, START_ACK_TIMEOUT, SUBSCRIPTION_STATUS, } from '../constants';\nimport { CONNECTION_CHANGE, ConnectionStateMonitor, } from '../../utils/ConnectionStateMonitor';\nimport { ReconnectEvent, ReconnectionMonitor, } from '../../utils/ReconnectionMonitor';\nimport { additionalHeadersFromOptions, queryParamsFromCustomHeaders, realtimeUrlWithQueryString, } from './appsyncUrl';\nimport { awsRealTimeHeaderBasedAuth } from './authHeaders';\nconst dispatchApiEvent = (payload) => {\n    Hub.dispatch('api', payload, 'PubSub', AMPLIFY_SYMBOL);\n};\nexport class AWSWebSocketProvider {\n    constructor(args) {\n        this.subscriptionObserverMap = new Map();\n        this.allowNoSubscriptions = false;\n        this.socketStatus = SOCKET_STATUS.CLOSED;\n        this.keepAliveTimestamp = Date.now();\n        this.promiseArray = [];\n        this.connectionStateMonitor = new ConnectionStateMonitor();\n        this.reconnectionMonitor = new ReconnectionMonitor();\n        /**\n         * Open WebSocket connection & perform handshake\n         * Ref: https://docs.aws.amazon.com/appsync/latest/devguide/real-time-websocket-client.html#appsynclong-real-time-websocket-client-implementation-guide-for-graphql-subscriptions\n         *\n         * @param subprotocol -\n         */\n        this._establishConnection = async (awsRealTimeUrl, subprotocol) => {\n            this.logger.debug(`Establishing WebSocket connection to ${awsRealTimeUrl}`);\n            try {\n                await this._openConnection(awsRealTimeUrl, subprotocol);\n                await this._initiateHandshake();\n            }\n            catch (err) {\n                const { errorType, errorCode } = err;\n                if (NON_RETRYABLE_CODES.includes(errorCode) ||\n                    // Event API does not currently return `errorCode`. This may change in the future.\n                    // For now fall back to also checking known non-retryable error types\n                    NON_RETRYABLE_ERROR_TYPES.includes(errorType)) {\n                    throw new NonRetryableError(errorType);\n                }\n                else if (errorType) {\n                    throw new Error(errorType);\n                }\n                else {\n                    throw err;\n                }\n            }\n        };\n        this.logger = new ConsoleLogger(args.providerName);\n        this.wsProtocolName = args.wsProtocolName;\n        this.wsConnectUri = args.connectUri;\n        this.connectionStateMonitorSubscription =\n            this._startConnectionStateMonitoring();\n    }\n    /**\n     * Mark the socket closed and release all active listeners\n     */\n    close() {\n        // Mark the socket closed both in status and the connection monitor\n        this.socketStatus = SOCKET_STATUS.CLOSED;\n        this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_FAILED);\n        // Turn off the subscription monitor Hub publishing\n        this.connectionStateMonitorSubscription.unsubscribe();\n        // Complete all reconnect observers\n        this.reconnectionMonitor.close();\n        return new Promise((resolve, reject) => {\n            if (this.awsRealTimeSocket) {\n                this.awsRealTimeSocket.onclose = (_) => {\n                    this._closeSocket();\n                    this.subscriptionObserverMap = new Map();\n                    this.awsRealTimeSocket = undefined;\n                    resolve();\n                };\n                this.awsRealTimeSocket.onerror = (err) => {\n                    reject(err);\n                };\n                this.awsRealTimeSocket.close();\n            }\n            else {\n                resolve();\n            }\n        });\n    }\n    subscribe(options, customUserAgentDetails) {\n        return new Observable(observer => {\n            if (!options?.appSyncGraphqlEndpoint) {\n                observer.error({\n                    errors: [\n                        {\n                            ...new GraphQLError(`Subscribe only available for AWS AppSync endpoint`),\n                        },\n                    ],\n                });\n                observer.complete();\n                return;\n            }\n            let subscriptionStartInProgress = false;\n            const subscriptionId = amplifyUuid();\n            const startSubscription = () => {\n                if (!subscriptionStartInProgress) {\n                    subscriptionStartInProgress = true;\n                    this._startSubscriptionWithAWSAppSyncRealTime({\n                        options,\n                        observer,\n                        subscriptionId,\n                        customUserAgentDetails,\n                    })\n                        .catch(err => {\n                        this.logger.debug(`${CONTROL_MSG.REALTIME_SUBSCRIPTION_INIT_ERROR}: ${err}`);\n                        this._closeSocket();\n                    })\n                        .finally(() => {\n                        subscriptionStartInProgress = false;\n                    });\n                }\n            };\n            // Add an observable to the reconnection list to manage reconnection for this subscription\n            const reconnectSubscription = new Observable(reconnectSubscriptionObserver => {\n                this.reconnectionMonitor.addObserver(reconnectSubscriptionObserver);\n            }).subscribe(() => {\n                startSubscription();\n            });\n            startSubscription();\n            return async () => {\n                await this._cleanupSubscription(subscriptionId, reconnectSubscription);\n            };\n        });\n    }\n    async connect(options) {\n        if (this.socketStatus === SOCKET_STATUS.READY) {\n            return;\n        }\n        await this._connectWebSocket(options);\n    }\n    async publish(options, customUserAgentDetails) {\n        if (this.socketStatus !== SOCKET_STATUS.READY) {\n            throw new Error('Subscription has not been initialized');\n        }\n        return this._publishMessage(options, customUserAgentDetails);\n    }\n    async _connectWebSocket(options) {\n        const { apiKey, appSyncGraphqlEndpoint, authenticationType, region } = options;\n        const { additionalCustomHeaders } = await additionalHeadersFromOptions(options);\n        this.connectionStateMonitor.record(CONNECTION_CHANGE.OPENING_CONNECTION);\n        await this._initializeWebSocketConnection({\n            apiKey,\n            appSyncGraphqlEndpoint,\n            authenticationType,\n            region,\n            additionalCustomHeaders,\n        });\n    }\n    async _publishMessage(options, customUserAgentDetails) {\n        const subscriptionId = amplifyUuid();\n        const { additionalCustomHeaders, libraryConfigHeaders } = await additionalHeadersFromOptions(options);\n        const serializedSubscriptionMessage = await this._prepareSubscriptionPayload({\n            options,\n            subscriptionId,\n            customUserAgentDetails,\n            additionalCustomHeaders,\n            libraryConfigHeaders,\n            publish: true,\n        });\n        return new Promise((resolve, reject) => {\n            if (this.awsRealTimeSocket) {\n                const publishListener = (event) => {\n                    const data = JSON.parse(event.data);\n                    if (data.id === subscriptionId && data.type === 'publish_success') {\n                        this.awsRealTimeSocket &&\n                            this.awsRealTimeSocket.removeEventListener('message', publishListener);\n                        cleanup();\n                        resolve();\n                    }\n                    if (data.errors && data.errors.length > 0) {\n                        const errorTypes = data.errors.map((error) => error.errorType);\n                        cleanup();\n                        reject(new Error(`Publish errors: ${errorTypes.join(', ')}`));\n                    }\n                };\n                const errorListener = (error) => {\n                    cleanup();\n                    reject(new Error(`WebSocket error: ${error}`));\n                };\n                const closeListener = () => {\n                    cleanup();\n                    reject(new Error('WebSocket is closed'));\n                };\n                const cleanup = () => {\n                    this.awsRealTimeSocket?.removeEventListener('message', publishListener);\n                    this.awsRealTimeSocket?.removeEventListener('error', errorListener);\n                    this.awsRealTimeSocket?.removeEventListener('close', closeListener);\n                };\n                this.awsRealTimeSocket.addEventListener('message', publishListener);\n                this.awsRealTimeSocket.addEventListener('error', errorListener);\n                this.awsRealTimeSocket.addEventListener('close', closeListener);\n                this.awsRealTimeSocket.send(serializedSubscriptionMessage);\n            }\n            else {\n                reject(new Error('WebSocket is not connected'));\n            }\n        });\n    }\n    async _cleanupSubscription(subscriptionId, reconnectSubscription) {\n        // Cleanup reconnection subscription\n        reconnectSubscription?.unsubscribe();\n        // Cleanup after unsubscribing or observer.complete was called after _startSubscriptionWithAWSAppSyncRealTime\n        try {\n            // Waiting that subscription has been connected before trying to unsubscribe\n            await this._waitForSubscriptionToBeConnected(subscriptionId);\n            const { subscriptionState } = this.subscriptionObserverMap.get(subscriptionId) || {};\n            if (!subscriptionState) {\n                // subscription already unsubscribed\n                return;\n            }\n            if (subscriptionState === SUBSCRIPTION_STATUS.CONNECTED) {\n                this._sendUnsubscriptionMessage(subscriptionId);\n            }\n            else {\n                throw new Error('Subscription never connected');\n            }\n        }\n        catch (err) {\n            this.logger.debug(`Error while unsubscribing ${err}`);\n        }\n        finally {\n            this._removeSubscriptionObserver(subscriptionId);\n        }\n    }\n    // Monitor the connection state and pass changes along to Hub\n    _startConnectionStateMonitoring() {\n        return this.connectionStateMonitor.connectionStateObservable.subscribe(connectionState => {\n            dispatchApiEvent({\n                event: CONNECTION_STATE_CHANGE,\n                data: {\n                    provider: this,\n                    connectionState,\n                },\n                message: `Connection state is ${connectionState}`,\n            });\n            this.connectionState = connectionState;\n            // Trigger START_RECONNECT when the connection is disrupted\n            if (connectionState === ConnectionState.ConnectionDisrupted) {\n                this.reconnectionMonitor.record(ReconnectEvent.START_RECONNECT);\n            }\n            // Trigger HALT_RECONNECT to halt reconnection attempts when the state is anything other than\n            // ConnectionDisrupted or Connecting\n            if ([\n                ConnectionState.Connected,\n                ConnectionState.ConnectedPendingDisconnect,\n                ConnectionState.ConnectedPendingKeepAlive,\n                ConnectionState.ConnectedPendingNetwork,\n                ConnectionState.ConnectionDisruptedPendingNetwork,\n                ConnectionState.Disconnected,\n            ].includes(connectionState)) {\n                this.reconnectionMonitor.record(ReconnectEvent.HALT_RECONNECT);\n            }\n        });\n    }\n    async _startSubscriptionWithAWSAppSyncRealTime({ options, observer, subscriptionId, customUserAgentDetails, }) {\n        const { query, variables } = options;\n        this.subscriptionObserverMap.set(subscriptionId, {\n            observer,\n            query: query ?? '',\n            variables: variables ?? {},\n            subscriptionState: SUBSCRIPTION_STATUS.PENDING,\n            startAckTimeoutId: undefined,\n        });\n        const { additionalCustomHeaders, libraryConfigHeaders } = await additionalHeadersFromOptions(options);\n        const serializedSubscriptionMessage = await this._prepareSubscriptionPayload({\n            options,\n            subscriptionId,\n            customUserAgentDetails,\n            additionalCustomHeaders,\n            libraryConfigHeaders,\n        });\n        try {\n            await this._connectWebSocket(options);\n        }\n        catch (err) {\n            this._logStartSubscriptionError(subscriptionId, observer, err);\n            return;\n        }\n        // Potential race condition can occur when unsubscribe is called during _initializeWebSocketConnection.\n        // E.g.unsubscribe gets invoked prior to finishing WebSocket handshake or START_ACK.\n        // Both subscriptionFailedCallback and subscriptionReadyCallback are used to synchronized this.\n        const { subscriptionFailedCallback, subscriptionReadyCallback } = this.subscriptionObserverMap.get(subscriptionId) ?? {};\n        // This must be done before sending the message in order to be listening immediately\n        this.subscriptionObserverMap.set(subscriptionId, {\n            observer,\n            subscriptionState: SUBSCRIPTION_STATUS.PENDING,\n            query: query ?? '',\n            variables: variables ?? {},\n            subscriptionReadyCallback,\n            subscriptionFailedCallback,\n            startAckTimeoutId: setTimeout(() => {\n                this._timeoutStartSubscriptionAck(subscriptionId);\n            }, START_ACK_TIMEOUT),\n        });\n        if (this.awsRealTimeSocket) {\n            this.awsRealTimeSocket.send(serializedSubscriptionMessage);\n        }\n    }\n    // Log logic for start subscription failures\n    _logStartSubscriptionError(subscriptionId, observer, err) {\n        this.logger.debug({ err });\n        const message = String(err.message ?? '');\n        // Resolving to give the state observer time to propogate the update\n        this._closeSocket();\n        // Capture the error only when the network didn't cause disruption\n        if (this.connectionState !== ConnectionState.ConnectionDisruptedPendingNetwork) {\n            // When the error is non-retriable, error out the observable\n            if (isNonRetryableError(err)) {\n                observer.error({\n                    errors: [\n                        {\n                            ...new GraphQLError(`${CONTROL_MSG.CONNECTION_FAILED}: ${message}`),\n                        },\n                    ],\n                });\n            }\n            else {\n                this.logger.debug(`${CONTROL_MSG.CONNECTION_FAILED}: ${message}`);\n            }\n            const { subscriptionFailedCallback } = this.subscriptionObserverMap.get(subscriptionId) || {};\n            // Notify concurrent unsubscription\n            if (typeof subscriptionFailedCallback === 'function') {\n                subscriptionFailedCallback();\n            }\n        }\n    }\n    // Waiting that subscription has been connected before trying to unsubscribe\n    async _waitForSubscriptionToBeConnected(subscriptionId) {\n        const subscriptionObserver = this.subscriptionObserverMap.get(subscriptionId);\n        if (subscriptionObserver) {\n            const { subscriptionState } = subscriptionObserver;\n            // This in case unsubscribe is invoked before sending start subscription message\n            if (subscriptionState === SUBSCRIPTION_STATUS.PENDING) {\n                return new Promise((resolve, reject) => {\n                    const { observer, subscriptionState: observedSubscriptionState, variables, query, } = subscriptionObserver;\n                    this.subscriptionObserverMap.set(subscriptionId, {\n                        observer,\n                        subscriptionState: observedSubscriptionState,\n                        variables,\n                        query,\n                        subscriptionReadyCallback: resolve,\n                        subscriptionFailedCallback: reject,\n                    });\n                });\n            }\n        }\n    }\n    _sendUnsubscriptionMessage(subscriptionId) {\n        try {\n            if (this.awsRealTimeSocket &&\n                this.awsRealTimeSocket.readyState === WebSocket.OPEN &&\n                this.socketStatus === SOCKET_STATUS.READY) {\n                // Preparing unsubscribe message to stop receiving messages for that subscription\n                const unsubscribeMessage = this._unsubscribeMessage(subscriptionId);\n                const stringToAWSRealTime = JSON.stringify(unsubscribeMessage);\n                this.awsRealTimeSocket.send(stringToAWSRealTime);\n            }\n        }\n        catch (err) {\n            // If GQL_STOP is not sent because of disconnection issue, then there is nothing the client can do\n            this.logger.debug({ err });\n        }\n    }\n    _removeSubscriptionObserver(subscriptionId) {\n        this.subscriptionObserverMap.delete(subscriptionId);\n        // Verifying 1000ms after removing subscription in case there are new subscription unmount/mount\n        if (!this.allowNoSubscriptions) {\n            setTimeout(this._closeSocketIfRequired.bind(this), 1000);\n        }\n    }\n    _closeSocketIfRequired() {\n        if (this.subscriptionObserverMap.size > 0) {\n            // Active subscriptions on the WebSocket\n            return;\n        }\n        if (!this.awsRealTimeSocket) {\n            this.socketStatus = SOCKET_STATUS.CLOSED;\n            return;\n        }\n        this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSING_CONNECTION);\n        if (this.awsRealTimeSocket.bufferedAmount > 0) {\n            // Still data on the WebSocket\n            setTimeout(this._closeSocketIfRequired.bind(this), 1000);\n        }\n        else {\n            this.logger.debug('closing WebSocket...');\n            const tempSocket = this.awsRealTimeSocket;\n            // Cleaning callbacks to avoid race condition, socket still exists\n            tempSocket.onclose = null;\n            tempSocket.onerror = null;\n            tempSocket.close(1000);\n            this.awsRealTimeSocket = undefined;\n            this.socketStatus = SOCKET_STATUS.CLOSED;\n            this._closeSocket();\n        }\n    }\n    maintainKeepAlive() {\n        this.keepAliveTimestamp = Date.now();\n    }\n    keepAliveHeartbeat(connectionTimeoutMs) {\n        const currentTime = Date.now();\n        // Check for missed KA message\n        if (currentTime - this.keepAliveTimestamp >\n            DEFAULT_KEEP_ALIVE_ALERT_TIMEOUT) {\n            this.connectionStateMonitor.record(CONNECTION_CHANGE.KEEP_ALIVE_MISSED);\n        }\n        else {\n            this.connectionStateMonitor.record(CONNECTION_CHANGE.KEEP_ALIVE);\n        }\n        // Recognize we are disconnected if we haven't seen messages in the keep alive timeout period\n        if (currentTime - this.keepAliveTimestamp > connectionTimeoutMs) {\n            this._errorDisconnect(CONTROL_MSG.TIMEOUT_DISCONNECT);\n        }\n    }\n    _handleIncomingSubscriptionMessage(message) {\n        if (typeof message.data !== 'string') {\n            return;\n        }\n        const [isData, data] = this._handleSubscriptionData(message);\n        if (isData) {\n            this.maintainKeepAlive();\n            return;\n        }\n        const { type, id, payload } = data;\n        const { observer = null, query = '', variables = {}, startAckTimeoutId, subscriptionReadyCallback, subscriptionFailedCallback, } = this.subscriptionObserverMap.get(id) || {};\n        if (type === MESSAGE_TYPES.GQL_START_ACK ||\n            type === MESSAGE_TYPES.EVENT_SUBSCRIBE_ACK) {\n            this.logger.debug(`subscription ready for ${JSON.stringify({ query, variables })}`);\n            if (typeof subscriptionReadyCallback === 'function') {\n                subscriptionReadyCallback();\n            }\n            if (startAckTimeoutId)\n                clearTimeout(startAckTimeoutId);\n            dispatchApiEvent({\n                event: CONTROL_MSG.SUBSCRIPTION_ACK,\n                data: { query, variables },\n                message: 'Connection established for subscription',\n            });\n            const subscriptionState = SUBSCRIPTION_STATUS.CONNECTED;\n            if (observer) {\n                this.subscriptionObserverMap.set(id, {\n                    observer,\n                    query,\n                    variables,\n                    startAckTimeoutId: undefined,\n                    subscriptionState,\n                    subscriptionReadyCallback,\n                    subscriptionFailedCallback,\n                });\n            }\n            this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_ESTABLISHED);\n            return;\n        }\n        if (type === MESSAGE_TYPES.GQL_CONNECTION_KEEP_ALIVE) {\n            this.maintainKeepAlive();\n            return;\n        }\n        if (type === MESSAGE_TYPES.GQL_ERROR) {\n            const subscriptionState = SUBSCRIPTION_STATUS.FAILED;\n            if (observer) {\n                this.subscriptionObserverMap.set(id, {\n                    observer,\n                    query,\n                    variables,\n                    startAckTimeoutId,\n                    subscriptionReadyCallback,\n                    subscriptionFailedCallback,\n                    subscriptionState,\n                });\n                this.logger.debug(`${CONTROL_MSG.CONNECTION_FAILED}: ${JSON.stringify(payload ?? data)}`);\n                observer.error({\n                    errors: [\n                        {\n                            ...new GraphQLError(`${CONTROL_MSG.CONNECTION_FAILED}: ${JSON.stringify(payload ?? data)}`),\n                        },\n                    ],\n                });\n                if (startAckTimeoutId)\n                    clearTimeout(startAckTimeoutId);\n                if (typeof subscriptionFailedCallback === 'function') {\n                    subscriptionFailedCallback();\n                }\n            }\n        }\n    }\n    _errorDisconnect(msg) {\n        this.logger.debug(`Disconnect error: ${msg}`);\n        if (this.awsRealTimeSocket) {\n            this._closeSocket();\n            this.awsRealTimeSocket.close();\n        }\n        this.socketStatus = SOCKET_STATUS.CLOSED;\n    }\n    _closeSocket() {\n        if (this.keepAliveHeartbeatIntervalId) {\n            clearInterval(this.keepAliveHeartbeatIntervalId);\n            this.keepAliveHeartbeatIntervalId = undefined;\n        }\n        this.connectionStateMonitor.record(CONNECTION_CHANGE.CLOSED);\n    }\n    _timeoutStartSubscriptionAck(subscriptionId) {\n        const subscriptionObserver = this.subscriptionObserverMap.get(subscriptionId);\n        if (subscriptionObserver) {\n            const { observer, query, variables } = subscriptionObserver;\n            if (!observer) {\n                return;\n            }\n            this.subscriptionObserverMap.set(subscriptionId, {\n                observer,\n                query,\n                variables,\n                subscriptionState: SUBSCRIPTION_STATUS.FAILED,\n            });\n            this._closeSocket();\n            this.logger.debug('timeoutStartSubscription', JSON.stringify({ query, variables }));\n        }\n    }\n    _initializeWebSocketConnection({ appSyncGraphqlEndpoint, authenticationType, apiKey, region, additionalCustomHeaders, }) {\n        if (this.socketStatus === SOCKET_STATUS.READY) {\n            return;\n        }\n        // TODO(Eslint): refactor to now use async function as the promise executor\n        // eslint-disable-next-line no-async-promise-executor\n        return new Promise(async (resolve, reject) => {\n            this.promiseArray.push({ res: resolve, rej: reject });\n            if (this.socketStatus === SOCKET_STATUS.CLOSED) {\n                try {\n                    this.socketStatus = SOCKET_STATUS.CONNECTING;\n                    // Empty payload on connect\n                    const payloadString = '{}';\n                    const authHeader = await awsRealTimeHeaderBasedAuth({\n                        authenticationType,\n                        payload: payloadString,\n                        canonicalUri: this.wsConnectUri,\n                        apiKey,\n                        appSyncGraphqlEndpoint,\n                        region,\n                        additionalCustomHeaders,\n                    });\n                    const headerString = authHeader ? JSON.stringify(authHeader) : '';\n                    // base64url-encoded string\n                    const encodedHeader = base64Encoder.convert(headerString, {\n                        urlSafe: true,\n                        skipPadding: true,\n                    });\n                    const authTokenSubprotocol = `header-${encodedHeader}`;\n                    const queryParams = queryParamsFromCustomHeaders(additionalCustomHeaders);\n                    const awsRealTimeUrl = realtimeUrlWithQueryString(appSyncGraphqlEndpoint, queryParams);\n                    await this._establishRetryableConnection(awsRealTimeUrl, authTokenSubprotocol);\n                    this.promiseArray.forEach(({ res }) => {\n                        this.logger.debug('Notifying connection successful');\n                        res();\n                    });\n                    this.socketStatus = SOCKET_STATUS.READY;\n                    this.promiseArray = [];\n                }\n                catch (err) {\n                    this.logger.debug('Connection exited with', err);\n                    this.promiseArray.forEach(({ rej }) => {\n                        rej(err);\n                    });\n                    this.promiseArray = [];\n                    if (this.awsRealTimeSocket &&\n                        this.awsRealTimeSocket.readyState === WebSocket.OPEN) {\n                        this.awsRealTimeSocket.close(3001);\n                    }\n                    this.awsRealTimeSocket = undefined;\n                    this.socketStatus = SOCKET_STATUS.CLOSED;\n                }\n            }\n        });\n    }\n    async _establishRetryableConnection(awsRealTimeUrl, subprotocol) {\n        this.logger.debug(`Establishing retryable connection`);\n        await jitteredExponentialRetry(this._establishConnection.bind(this), [awsRealTimeUrl, subprotocol], MAX_DELAY_MS);\n    }\n    async _openConnection(awsRealTimeUrl, subprotocol) {\n        return new Promise((resolve, reject) => {\n            const newSocket = this._getNewWebSocket(awsRealTimeUrl, [\n                this.wsProtocolName,\n                subprotocol,\n            ]);\n            newSocket.onerror = () => {\n                this.logger.debug(`WebSocket connection error`);\n            };\n            newSocket.onclose = () => {\n                this._closeSocket();\n                reject(new Error('Connection handshake error'));\n            };\n            newSocket.onopen = () => {\n                this.awsRealTimeSocket = newSocket;\n                resolve();\n            };\n        });\n    }\n    _getNewWebSocket(url, protocol) {\n        return new WebSocket(url, protocol);\n    }\n    async _initiateHandshake() {\n        return new Promise((resolve, reject) => {\n            if (!this.awsRealTimeSocket) {\n                reject(new Error('awsRealTimeSocket undefined'));\n                return;\n            }\n            let ackOk = false;\n            this.awsRealTimeSocket.onerror = error => {\n                this.logger.debug(`WebSocket error ${JSON.stringify(error)}`);\n            };\n            this.awsRealTimeSocket.onclose = event => {\n                this.logger.debug(`WebSocket closed ${event.reason}`);\n                this._closeSocket();\n                reject(new Error(JSON.stringify(event)));\n            };\n            this.awsRealTimeSocket.onmessage = (message) => {\n                if (typeof message.data !== 'string') {\n                    return;\n                }\n                this.logger.debug(`subscription message from AWS AppSyncRealTime: ${message.data} `);\n                const data = JSON.parse(message.data);\n                const { type } = data;\n                const connectionTimeoutMs = this._extractConnectionTimeout(data);\n                if (type === MESSAGE_TYPES.GQL_CONNECTION_ACK) {\n                    ackOk = true;\n                    this._registerWebsocketHandlers(connectionTimeoutMs);\n                    resolve('Connected to AWS AppSyncRealTime');\n                    return;\n                }\n                if (type === MESSAGE_TYPES.GQL_CONNECTION_ERROR) {\n                    const { errorType, errorCode } = this._extractErrorCodeAndType(data);\n                    // TODO(Eslint): refactor to reject an Error object instead of a plain object\n                    // eslint-disable-next-line prefer-promise-reject-errors\n                    reject({ errorType, errorCode });\n                }\n            };\n            const gqlInit = {\n                type: MESSAGE_TYPES.GQL_CONNECTION_INIT,\n            };\n            this.awsRealTimeSocket.send(JSON.stringify(gqlInit));\n            const checkAckOk = (targetAckOk) => {\n                if (!targetAckOk) {\n                    this.connectionStateMonitor.record(CONNECTION_CHANGE.CONNECTION_FAILED);\n                    reject(new Error(`Connection timeout: ack from AWSAppSyncRealTime was not received after ${CONNECTION_INIT_TIMEOUT} ms`));\n                }\n            };\n            setTimeout(() => {\n                checkAckOk(ackOk);\n            }, CONNECTION_INIT_TIMEOUT);\n        });\n    }\n    _registerWebsocketHandlers(connectionTimeoutMs) {\n        if (!this.awsRealTimeSocket) {\n            return;\n        }\n        // Set up a keep alive heartbeat for this connection\n        this.keepAliveHeartbeatIntervalId = setInterval(() => {\n            this.keepAliveHeartbeat(connectionTimeoutMs);\n        }, DEFAULT_KEEP_ALIVE_HEARTBEAT_TIMEOUT);\n        this.awsRealTimeSocket.onmessage =\n            this._handleIncomingSubscriptionMessage.bind(this);\n        this.awsRealTimeSocket.onerror = err => {\n            this.logger.debug(err);\n            this._errorDisconnect(CONTROL_MSG.CONNECTION_CLOSED);\n        };\n        this.awsRealTimeSocket.onclose = event => {\n            this.logger.debug(`WebSocket closed ${event.reason}`);\n            this._closeSocket();\n            this._errorDisconnect(CONTROL_MSG.CONNECTION_CLOSED);\n        };\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}