{"ast":null,"code":"import _objectSpread from \"C:/Users/vinzl/workspace/machicoulis/daily-image-collector/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { map } from 'rxjs';\nimport { authModeParams, getCustomHeaders, initializeModel, selectionSetIRToString, getDefaultSelectionSetForNonModelWithIR, generateSelectionSet } from '../APIClient.mjs';\nimport { handleSingularGraphQlError } from './utils.mjs';\nimport { selfAwareAsync } from '../../utils/selfAwareAsync.mjs';\nimport { extendCancellability } from '../cancellation.mjs';\nimport { createUserAgentOverride } from '../ai/getCustomUserAgentDetails.mjs';\n\n/**\n * Type guard for checking whether a Custom Operation argument is a contextSpec object\n */\nconst argIsContextSpec = arg => {\n  var _arg$token;\n  return typeof (arg === null || arg === void 0 || (_arg$token = arg.token) === null || _arg$token === void 0 ? void 0 : _arg$token.value) === 'symbol';\n};\n/**\n * Builds an operation function, embedded with all client and context data, that\n * can be attached to a client as a custom query or mutation.\n *\n * If we have this source schema:\n *\n * ```typescript\n * a.schema({\n *   echo: a.query()\n *     .arguments({input: a.string().required()})\n *     .returns(a.string())\n * })\n * ```\n *\n * Our model intro schema will contain an entry like this:\n *\n * ```ts\n * {\n *   queries: {\n *     echo: {\n *       name: \"echo\",\n *       isArray: false,\n *       type: 'String',\n *       isRequired: false,\n *       arguments: {\n *         input: {\n *           name: 'input',\n *           isArray: false,\n *           type: String,\n *           isRequired: true\n *         }\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * The `echo` object is used to build the `echo' method that goes here:\n *\n * ```typescript\n * const client = generateClent()\n * const { data } = await client.queries.echo({input: 'a string'});\n * //                                    ^\n * //                                    |\n * //                                    +-- This one right here.\n * //\n * ```\n *\n *\n * @param client The client to run graphql queries through.\n * @param modelIntrospection The model introspection schema the op comes from.\n * @param operationType The broad category of graphql operation.\n * @param operation The operation definition from the introspection schema.\n * @param useContext Whether the function needs to accept an SSR context.\n * @returns The operation function to attach to query, mutations, etc.\n */\nfunction customOpFactory(client, modelIntrospection, operationType, operation, useContext, getInternals, customUserAgentDetails) {\n  // .arguments() are defined for the custom operation in the schema builder\n  // and are present in the model introspection schema\n  const argsDefined = operation.arguments !== undefined;\n  const op = function () {\n    var _ref;\n    // options is always the last argument\n    const options = (_ref = arguments.length - 1, _ref < 0 || arguments.length <= _ref ? undefined : arguments[_ref]);\n    let contextSpec;\n    let arg;\n    if (useContext) {\n      if (argIsContextSpec(arguments.length <= 0 ? undefined : arguments[0])) {\n        contextSpec = arguments.length <= 0 ? undefined : arguments[0];\n      } else {\n        throw new Error(\"Invalid first argument passed to \".concat(operation.name, \". Expected contextSpec\"));\n      }\n    }\n    if (argsDefined) {\n      if (useContext) {\n        arg = arguments.length <= 1 ? undefined : arguments[1];\n      } else {\n        arg = arguments.length <= 0 ? undefined : arguments[0];\n      }\n    }\n    if (operationType === 'subscription') {\n      return _opSubscription(\n      // subscriptions are only enabled on the clientside\n      client, modelIntrospection, operation, getInternals, arg, options, customUserAgentDetails);\n    }\n    return _op(client, modelIntrospection, operationType, operation, getInternals, arg, options, contextSpec, customUserAgentDetails);\n  };\n  return op;\n}\n/**\n * Runtime test and type guard to check whether `o[field]` is a `String`.\n *\n * ```typescript\n * if (hasStringField(o, 'prop')) {\n *   const s = o.prop;\n *   //    ^? const s: string\n * }\n * ```\n *\n * @param o Object to inspect\n * @param field Field to look for\n * @returns Boolean: `true` if the `o[field]` is a `string`\n */\nfunction hasStringField(o, field) {\n  return typeof o[field] === 'string';\n}\nfunction isEnumType(type) {\n  return type instanceof Object && 'enum' in type;\n}\nfunction isInputType(type) {\n  return type instanceof Object && 'input' in type;\n}\n/**\n * @param argDef A single argument definition from a custom operation\n * @returns A string naming the base type including the `!` if the arg is required.\n */\nfunction argumentBaseTypeString(_ref2) {\n  let {\n    type,\n    isRequired\n  } = _ref2;\n  const requiredFlag = isRequired ? '!' : '';\n  if (isEnumType(type)) {\n    return \"\".concat(type.enum).concat(requiredFlag);\n  }\n  if (isInputType(type)) {\n    return \"\".concat(type.input).concat(requiredFlag);\n  }\n  return \"\".concat(type).concat(requiredFlag);\n}\n/**\n * Generates \"outer\" arguments string for a custom operation. For example,\n * in this operation:\n *\n * ```graphql\n * query MyQuery(InputString: String!) {\n *   echoString(InputString: $InputString)\n * }\n * ```\n *\n * This function returns the top/outer level arguments as a string:\n *\n * ```json\n * \"InputString: String!\"\n * ```\n *\n * @param operation Operation object from model introspection schema.\n * @returns \"outer\" arguments string\n */\nfunction outerArguments(operation) {\n  if (operation.arguments === undefined) {\n    return '';\n  }\n  const args = Object.entries(operation.arguments).map(_ref3 => {\n    let [k, argument] = _ref3;\n    const baseType = argumentBaseTypeString(argument);\n    const finalType = argument.isArray ? \"[\".concat(baseType, \"]\").concat(argument.isArrayNullable ? '' : '!') : baseType;\n    return \"$\".concat(k, \": \").concat(finalType);\n  }).join(', ');\n  return args.length > 0 ? \"(\".concat(args, \")\") : '';\n}\n/**\n * Generates \"inner\" arguments string for a custom operation. For example,\n * in this operation:\n *\n * ```graphql\n * query MyQuery(InputString: String!) {\n *   echoString(InputString: $InputString)\n * }\n * ```\n *\n * This function returns the inner arguments as a string:\n *\n * ```json\n * \"InputString: $InputString\"\n * ```\n *\n * @param operation Operation object from model introspection schema.\n * @returns \"outer\" arguments string\n */\nfunction innerArguments(operation) {\n  if (operation.arguments === undefined) {\n    return '';\n  }\n  const args = Object.keys(operation.arguments).map(k => \"\".concat(k, \": $\").concat(k)).join(', ');\n  return args.length > 0 ? \"(\".concat(args, \")\") : '';\n}\n/**\n * Generates the selection set string for a custom operation. This is slightly\n * different than the selection set generation for models. If the custom op returns\n * a primitive or enum types, it doesn't require a selection set at all.\n *\n * E.g., the graphql might look like this:\n *\n * ```graphql\n * query MyQuery {\n *   echoString(inputString: \"whatever\")\n * }\n * #                                     ^\n * #                                     |\n * #                                     +-- no selection set\n * ```\n *\n * Non-primitive return type selection set generation will be similar to other\n * model operations.\n *\n * @param modelIntrospection The full code-generated introspection schema.\n * @param operation The operation object from the schema.\n * @returns The selection set as a string.\n */\nfunction operationSelectionSet(modelIntrospection, operation) {\n  if (hasStringField(operation, 'type') || hasStringField(operation.type, 'enum')) {\n    return '';\n  } else if (hasStringField(operation.type, 'nonModel')) {\n    const nonModel = modelIntrospection.nonModels[operation.type.nonModel];\n    return \"{\".concat(selectionSetIRToString(getDefaultSelectionSetForNonModelWithIR(nonModel, modelIntrospection)), \"}\");\n  } else if (hasStringField(operation.type, 'model')) {\n    return \"{\".concat(generateSelectionSet(modelIntrospection, operation.type.model), \"}\");\n  } else {\n    return '';\n  }\n}\n/**\n * Maps an arguments objec to graphql variables, removing superfluous args and\n * screaming loudly when required args are missing.\n *\n * @param operation The operation to construct graphql request variables for.\n * @param args The arguments to map variables from.\n * @returns The graphql variables object.\n */\nfunction operationVariables(operation) {\n  let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const variables = {};\n  if (operation.arguments === undefined) {\n    return variables;\n  }\n  for (const argDef of Object.values(operation.arguments)) {\n    if (typeof args[argDef.name] !== 'undefined') {\n      variables[argDef.name] = args[argDef.name];\n    } else if (argDef.isRequired) {\n      // At this point, the variable is both required and missing: We don't need\n      // to continue. The operation is expected to fail.\n      throw new Error(\"\".concat(operation.name, \" requires arguments '\").concat(argDef.name, \"'\"));\n    }\n  }\n  return variables;\n}\n/**\n * Executes an operation from the given model intro schema against a client, returning\n * a fully instantiated model when relevant.\n *\n * @param client The client to operate `graphql()` calls through.\n * @param modelIntrospection The model intro schema to construct requests from.\n * @param operationType The high level graphql operation type.\n * @param operation The specific operation name, args, return type details.\n * @param args The arguments to provide to the operation as variables.\n * @param options Request options like headers, etc.\n * @param context SSR context if relevant.\n * @returns Result from the graphql request, model-instantiated when relevant.\n */\nfunction _op(client, modelIntrospection, operationType, operation, getInternals, args, options, context, customUserAgentDetails) {\n  return selfAwareAsync(async resultPromise => {\n    const {\n      name: operationName\n    } = operation;\n    const auth = authModeParams(client, getInternals, options);\n    const headers = getCustomHeaders(client, getInternals, options === null || options === void 0 ? void 0 : options.headers);\n    const outerArgsString = outerArguments(operation);\n    const innerArgsString = innerArguments(operation);\n    const selectionSet = operationSelectionSet(modelIntrospection, operation);\n    const returnTypeModelName = hasStringField(operation.type, 'model') ? operation.type.model : undefined;\n    const query = \"\\n    \".concat(operationType.toLocaleLowerCase()).concat(outerArgsString, \" {\\n      \").concat(operationName).concat(innerArgsString, \" \").concat(selectionSet, \"\\n    }\\n  \");\n    const variables = operationVariables(operation, args);\n    const userAgentOverride = createUserAgentOverride(customUserAgentDetails);\n    try {\n      const basePromise = context ? client.graphql(context, _objectSpread(_objectSpread({}, auth), {}, {\n        query,\n        variables\n      }), headers) : client.graphql(_objectSpread(_objectSpread({}, auth), {}, {\n        query,\n        variables\n      }, userAgentOverride), headers);\n      const extendedPromise = extendCancellability(basePromise, resultPromise);\n      const {\n        data,\n        extensions\n      } = await extendedPromise;\n      // flatten response\n      if (data) {\n        const [key] = Object.keys(data);\n        const isArrayResult = Array.isArray(data[key]);\n        // TODO: when adding support for custom selection set, flattening will need\n        // to occur recursively. For now, it's expected that related models are not\n        // present in the result. Only FK's are present. Any related model properties\n        // should be replaced with lazy loaders under the current implementation.\n        const flattenedResult = isArrayResult ? data[key].filter(x => x) : data[key];\n        // TODO: custom selection set. current selection set is default selection set only\n        // custom selection set requires data-schema-type + runtime updates above.\n        const initialized = returnTypeModelName ? initializeModel(client, returnTypeModelName, isArrayResult ? flattenedResult : [flattenedResult], modelIntrospection, auth.authMode, auth.authToken, !!context) : flattenedResult;\n        return {\n          data: !isArrayResult && Array.isArray(initialized) ? initialized.shift() : initialized,\n          extensions\n        };\n      } else {\n        return {\n          data: null,\n          extensions\n        };\n      }\n    } catch (error) {\n      /**\n       * The `data` type returned by `error` here could be:\n       * 1) `null`\n       * 2) an empty object\n       * 3) \"populated\" but with a `null` value `{ getPost: null }`\n       * 4) an actual record `{ getPost: { id: '1', title: 'Hello, World!' } }`\n       */\n      const {\n        data,\n        errors\n      } = error;\n      /**\n       * `data` is not `null`, and is not an empty object:\n       */\n      if (data && Object.keys(data).length !== 0 && errors) {\n        const [key] = Object.keys(data);\n        const isArrayResult = Array.isArray(data[key]);\n        // TODO: when adding support for custom selection set, flattening will need\n        // to occur recursively. For now, it's expected that related models are not\n        // present in the result. Only FK's are present. Any related model properties\n        // should be replaced with lazy loaders under the current implementation.\n        const flattenedResult = isArrayResult ? data[key].filter(x => x) : data[key];\n        /**\n         * `flattenedResult` could be `null` here (e.g. `data: { getPost: null }`)\n         * if `flattenedResult`, result is an actual record:\n         */\n        if (flattenedResult) {\n          // TODO: custom selection set. current selection set is default selection set only\n          // custom selection set requires data-schema-type + runtime updates above.\n          const initialized = returnTypeModelName ? initializeModel(client, returnTypeModelName, isArrayResult ? flattenedResult : [flattenedResult], modelIntrospection, auth.authMode, auth.authToken, !!context) : flattenedResult;\n          return {\n            data: !isArrayResult && Array.isArray(initialized) ? initialized.shift() : initialized,\n            errors\n          };\n        } else {\n          // was `data: { getPost: null }`)\n          return handleSingularGraphQlError(error);\n        }\n      } else {\n        // `data` is `null`:\n        return handleSingularGraphQlError(error);\n      }\n    }\n  });\n}\n/**\n * Executes an operation from the given model intro schema against a client, returning\n * a fully instantiated model when relevant.\n *\n * @param client The client to operate `graphql()` calls through.\n * @param modelIntrospection The model intro schema to construct requests from.\n * @param operation The specific operation name, args, return type details.\n * @param args The arguments to provide to the operation as variables.\n * @param options Request options like headers, etc.\n * @returns Result from the graphql request, model-instantiated when relevant.\n */\nfunction _opSubscription(client, modelIntrospection, operation, getInternals, args, options, customUserAgentDetails) {\n  const operationType = 'subscription';\n  const {\n    name: operationName\n  } = operation;\n  const auth = authModeParams(client, getInternals, options);\n  const headers = getCustomHeaders(client, getInternals, options === null || options === void 0 ? void 0 : options.headers);\n  const outerArgsString = outerArguments(operation);\n  const innerArgsString = innerArguments(operation);\n  const selectionSet = operationSelectionSet(modelIntrospection, operation);\n  const returnTypeModelName = hasStringField(operation.type, 'model') ? operation.type.model : undefined;\n  const query = \"\\n    \".concat(operationType.toLocaleLowerCase()).concat(outerArgsString, \" {\\n      \").concat(operationName).concat(innerArgsString, \" \").concat(selectionSet, \"\\n    }\\n  \");\n  const variables = operationVariables(operation, args);\n  const userAgentOverride = createUserAgentOverride(customUserAgentDetails);\n  const observable = client.graphql(_objectSpread(_objectSpread({}, auth), {}, {\n    query,\n    variables\n  }, userAgentOverride), headers);\n  return observable.pipe(map(value => {\n    const [key] = Object.keys(value.data);\n    const data = value.data[key];\n    const [initialized] = returnTypeModelName ? initializeModel(client, returnTypeModelName, [data], modelIntrospection, auth.authMode, auth.authToken) : [data];\n    return initialized;\n  }));\n}\nexport { customOpFactory };","map":{"version":3,"names":["argIsContextSpec","arg","_arg$token","token","value","customOpFactory","client","modelIntrospection","operationType","operation","useContext","getInternals","customUserAgentDetails","argsDefined","arguments","undefined","op","_ref","options","length","contextSpec","Error","concat","name","_opSubscription","_op","hasStringField","o","field","isEnumType","type","Object","isInputType","argumentBaseTypeString","_ref2","isRequired","requiredFlag","enum","input","outerArguments","args","entries","map","_ref3","k","argument","baseType","finalType","isArray","isArrayNullable","join","innerArguments","keys","operationSelectionSet","nonModel","nonModels","selectionSetIRToString","getDefaultSelectionSetForNonModelWithIR","generateSelectionSet","model","operationVariables","variables","argDef","values","context","selfAwareAsync","resultPromise","operationName","auth","authModeParams","headers","getCustomHeaders","outerArgsString","innerArgsString","selectionSet","returnTypeModelName","query","toLocaleLowerCase","userAgentOverride","createUserAgentOverride","basePromise","graphql","_objectSpread","extendedPromise","extendCancellability","data","extensions","key","isArrayResult","Array","flattenedResult","filter","x","initialized","initializeModel","authMode","authToken","shift","error","errors","handleSingularGraphQlError","observable","pipe"],"sources":["C:\\Users\\vinzl\\workspace\\machicoulis\\daily-image-collector\\node_modules\\@aws-amplify\\data-schema\\src\\runtime\\internals\\operations\\custom.ts"],"sourcesContent":["import { map } from 'rxjs';\nimport { authModeParams, getDefaultSelectionSetForNonModelWithIR, generateSelectionSet, getCustomHeaders, initializeModel, selectionSetIRToString, } from '../APIClient';\nimport { handleSingularGraphQlError } from './utils';\nimport { selfAwareAsync } from '../../utils';\nimport { extendCancellability } from '../cancellation';\nimport { createUserAgentOverride } from '../ai/getCustomUserAgentDetails';\n/**\n * Type guard for checking whether a Custom Operation argument is a contextSpec object\n */\nconst argIsContextSpec = (arg) => {\n    return typeof arg?.token?.value === 'symbol';\n};\n/**\n * Builds an operation function, embedded with all client and context data, that\n * can be attached to a client as a custom query or mutation.\n *\n * If we have this source schema:\n *\n * ```typescript\n * a.schema({\n *   echo: a.query()\n *     .arguments({input: a.string().required()})\n *     .returns(a.string())\n * })\n * ```\n *\n * Our model intro schema will contain an entry like this:\n *\n * ```ts\n * {\n *   queries: {\n *     echo: {\n *       name: \"echo\",\n *       isArray: false,\n *       type: 'String',\n *       isRequired: false,\n *       arguments: {\n *         input: {\n *           name: 'input',\n *           isArray: false,\n *           type: String,\n *           isRequired: true\n *         }\n *       }\n *     }\n *   }\n * }\n * ```\n *\n * The `echo` object is used to build the `echo' method that goes here:\n *\n * ```typescript\n * const client = generateClent()\n * const { data } = await client.queries.echo({input: 'a string'});\n * //                                    ^\n * //                                    |\n * //                                    +-- This one right here.\n * //\n * ```\n *\n *\n * @param client The client to run graphql queries through.\n * @param modelIntrospection The model introspection schema the op comes from.\n * @param operationType The broad category of graphql operation.\n * @param operation The operation definition from the introspection schema.\n * @param useContext Whether the function needs to accept an SSR context.\n * @returns The operation function to attach to query, mutations, etc.\n */\nexport function customOpFactory(client, modelIntrospection, operationType, operation, useContext, getInternals, customUserAgentDetails) {\n    // .arguments() are defined for the custom operation in the schema builder\n    // and are present in the model introspection schema\n    const argsDefined = operation.arguments !== undefined;\n    const op = (...args) => {\n        // options is always the last argument\n        const options = args[args.length - 1];\n        let contextSpec;\n        let arg;\n        if (useContext) {\n            if (argIsContextSpec(args[0])) {\n                contextSpec = args[0];\n            }\n            else {\n                throw new Error(`Invalid first argument passed to ${operation.name}. Expected contextSpec`);\n            }\n        }\n        if (argsDefined) {\n            if (useContext) {\n                arg = args[1];\n            }\n            else {\n                arg = args[0];\n            }\n        }\n        if (operationType === 'subscription') {\n            return _opSubscription(\n            // subscriptions are only enabled on the clientside\n            client, modelIntrospection, operation, getInternals, arg, options, customUserAgentDetails);\n        }\n        return _op(client, modelIntrospection, operationType, operation, getInternals, arg, options, contextSpec, customUserAgentDetails);\n    };\n    return op;\n}\n/**\n * Runtime test and type guard to check whether `o[field]` is a `String`.\n *\n * ```typescript\n * if (hasStringField(o, 'prop')) {\n *   const s = o.prop;\n *   //    ^? const s: string\n * }\n * ```\n *\n * @param o Object to inspect\n * @param field Field to look for\n * @returns Boolean: `true` if the `o[field]` is a `string`\n */\nfunction hasStringField(o, field) {\n    return typeof o[field] === 'string';\n}\nfunction isEnumType(type) {\n    return type instanceof Object && 'enum' in type;\n}\nfunction isInputType(type) {\n    return type instanceof Object && 'input' in type;\n}\n/**\n * @param argDef A single argument definition from a custom operation\n * @returns A string naming the base type including the `!` if the arg is required.\n */\nfunction argumentBaseTypeString({ type, isRequired }) {\n    const requiredFlag = isRequired ? '!' : '';\n    if (isEnumType(type)) {\n        return `${type.enum}${requiredFlag}`;\n    }\n    if (isInputType(type)) {\n        return `${type.input}${requiredFlag}`;\n    }\n    return `${type}${requiredFlag}`;\n}\n/**\n * Generates \"outer\" arguments string for a custom operation. For example,\n * in this operation:\n *\n * ```graphql\n * query MyQuery(InputString: String!) {\n *   echoString(InputString: $InputString)\n * }\n * ```\n *\n * This function returns the top/outer level arguments as a string:\n *\n * ```json\n * \"InputString: String!\"\n * ```\n *\n * @param operation Operation object from model introspection schema.\n * @returns \"outer\" arguments string\n */\nfunction outerArguments(operation) {\n    if (operation.arguments === undefined) {\n        return '';\n    }\n    const args = Object.entries(operation.arguments)\n        .map(([k, argument]) => {\n        const baseType = argumentBaseTypeString(argument);\n        const finalType = argument.isArray\n            ? `[${baseType}]${argument.isArrayNullable ? '' : '!'}`\n            : baseType;\n        return `$${k}: ${finalType}`;\n    })\n        .join(', ');\n    return args.length > 0 ? `(${args})` : '';\n}\n/**\n * Generates \"inner\" arguments string for a custom operation. For example,\n * in this operation:\n *\n * ```graphql\n * query MyQuery(InputString: String!) {\n *   echoString(InputString: $InputString)\n * }\n * ```\n *\n * This function returns the inner arguments as a string:\n *\n * ```json\n * \"InputString: $InputString\"\n * ```\n *\n * @param operation Operation object from model introspection schema.\n * @returns \"outer\" arguments string\n */\nfunction innerArguments(operation) {\n    if (operation.arguments === undefined) {\n        return '';\n    }\n    const args = Object.keys(operation.arguments)\n        .map((k) => `${k}: $${k}`)\n        .join(', ');\n    return args.length > 0 ? `(${args})` : '';\n}\n/**\n * Generates the selection set string for a custom operation. This is slightly\n * different than the selection set generation for models. If the custom op returns\n * a primitive or enum types, it doesn't require a selection set at all.\n *\n * E.g., the graphql might look like this:\n *\n * ```graphql\n * query MyQuery {\n *   echoString(inputString: \"whatever\")\n * }\n * #                                     ^\n * #                                     |\n * #                                     +-- no selection set\n * ```\n *\n * Non-primitive return type selection set generation will be similar to other\n * model operations.\n *\n * @param modelIntrospection The full code-generated introspection schema.\n * @param operation The operation object from the schema.\n * @returns The selection set as a string.\n */\nfunction operationSelectionSet(modelIntrospection, operation) {\n    if (hasStringField(operation, 'type') ||\n        hasStringField(operation.type, 'enum')) {\n        return '';\n    }\n    else if (hasStringField(operation.type, 'nonModel')) {\n        const nonModel = modelIntrospection.nonModels[operation.type.nonModel];\n        return `{${selectionSetIRToString(getDefaultSelectionSetForNonModelWithIR(nonModel, modelIntrospection))}}`;\n    }\n    else if (hasStringField(operation.type, 'model')) {\n        return `{${generateSelectionSet(modelIntrospection, operation.type.model)}}`;\n    }\n    else {\n        return '';\n    }\n}\n/**\n * Maps an arguments objec to graphql variables, removing superfluous args and\n * screaming loudly when required args are missing.\n *\n * @param operation The operation to construct graphql request variables for.\n * @param args The arguments to map variables from.\n * @returns The graphql variables object.\n */\nfunction operationVariables(operation, args = {}) {\n    const variables = {};\n    if (operation.arguments === undefined) {\n        return variables;\n    }\n    for (const argDef of Object.values(operation.arguments)) {\n        if (typeof args[argDef.name] !== 'undefined') {\n            variables[argDef.name] = args[argDef.name];\n        }\n        else if (argDef.isRequired) {\n            // At this point, the variable is both required and missing: We don't need\n            // to continue. The operation is expected to fail.\n            throw new Error(`${operation.name} requires arguments '${argDef.name}'`);\n        }\n    }\n    return variables;\n}\n/**\n * Executes an operation from the given model intro schema against a client, returning\n * a fully instantiated model when relevant.\n *\n * @param client The client to operate `graphql()` calls through.\n * @param modelIntrospection The model intro schema to construct requests from.\n * @param operationType The high level graphql operation type.\n * @param operation The specific operation name, args, return type details.\n * @param args The arguments to provide to the operation as variables.\n * @param options Request options like headers, etc.\n * @param context SSR context if relevant.\n * @returns Result from the graphql request, model-instantiated when relevant.\n */\nfunction _op(client, modelIntrospection, operationType, operation, getInternals, args, options, context, customUserAgentDetails) {\n    return selfAwareAsync(async (resultPromise) => {\n        const { name: operationName } = operation;\n        const auth = authModeParams(client, getInternals, options);\n        const headers = getCustomHeaders(client, getInternals, options?.headers);\n        const outerArgsString = outerArguments(operation);\n        const innerArgsString = innerArguments(operation);\n        const selectionSet = operationSelectionSet(modelIntrospection, operation);\n        const returnTypeModelName = hasStringField(operation.type, 'model')\n            ? operation.type.model\n            : undefined;\n        const query = `\n    ${operationType.toLocaleLowerCase()}${outerArgsString} {\n      ${operationName}${innerArgsString} ${selectionSet}\n    }\n  `;\n        const variables = operationVariables(operation, args);\n        const userAgentOverride = createUserAgentOverride(customUserAgentDetails);\n        try {\n            const basePromise = context\n                ? client.graphql(context, {\n                    ...auth,\n                    query,\n                    variables,\n                }, headers)\n                : client.graphql({\n                    ...auth,\n                    query,\n                    variables,\n                    ...userAgentOverride,\n                }, headers);\n            const extendedPromise = extendCancellability(basePromise, resultPromise);\n            const { data, extensions } = await extendedPromise;\n            // flatten response\n            if (data) {\n                const [key] = Object.keys(data);\n                const isArrayResult = Array.isArray(data[key]);\n                // TODO: when adding support for custom selection set, flattening will need\n                // to occur recursively. For now, it's expected that related models are not\n                // present in the result. Only FK's are present. Any related model properties\n                // should be replaced with lazy loaders under the current implementation.\n                const flattenedResult = isArrayResult\n                    ? data[key].filter((x) => x)\n                    : data[key];\n                // TODO: custom selection set. current selection set is default selection set only\n                // custom selection set requires data-schema-type + runtime updates above.\n                const initialized = returnTypeModelName\n                    ? initializeModel(client, returnTypeModelName, isArrayResult ? flattenedResult : [flattenedResult], modelIntrospection, auth.authMode, auth.authToken, !!context)\n                    : flattenedResult;\n                return {\n                    data: !isArrayResult && Array.isArray(initialized)\n                        ? initialized.shift()\n                        : initialized,\n                    extensions,\n                };\n            }\n            else {\n                return { data: null, extensions };\n            }\n        }\n        catch (error) {\n            /**\n             * The `data` type returned by `error` here could be:\n             * 1) `null`\n             * 2) an empty object\n             * 3) \"populated\" but with a `null` value `{ getPost: null }`\n             * 4) an actual record `{ getPost: { id: '1', title: 'Hello, World!' } }`\n             */\n            const { data, errors } = error;\n            /**\n             * `data` is not `null`, and is not an empty object:\n             */\n            if (data && Object.keys(data).length !== 0 && errors) {\n                const [key] = Object.keys(data);\n                const isArrayResult = Array.isArray(data[key]);\n                // TODO: when adding support for custom selection set, flattening will need\n                // to occur recursively. For now, it's expected that related models are not\n                // present in the result. Only FK's are present. Any related model properties\n                // should be replaced with lazy loaders under the current implementation.\n                const flattenedResult = isArrayResult\n                    ? data[key].filter((x) => x)\n                    : data[key];\n                /**\n                 * `flattenedResult` could be `null` here (e.g. `data: { getPost: null }`)\n                 * if `flattenedResult`, result is an actual record:\n                 */\n                if (flattenedResult) {\n                    // TODO: custom selection set. current selection set is default selection set only\n                    // custom selection set requires data-schema-type + runtime updates above.\n                    const initialized = returnTypeModelName\n                        ? initializeModel(client, returnTypeModelName, isArrayResult ? flattenedResult : [flattenedResult], modelIntrospection, auth.authMode, auth.authToken, !!context)\n                        : flattenedResult;\n                    return {\n                        data: !isArrayResult && Array.isArray(initialized)\n                            ? initialized.shift()\n                            : initialized,\n                        errors,\n                    };\n                }\n                else {\n                    // was `data: { getPost: null }`)\n                    return handleSingularGraphQlError(error);\n                }\n            }\n            else {\n                // `data` is `null`:\n                return handleSingularGraphQlError(error);\n            }\n        }\n    });\n}\n/**\n * Executes an operation from the given model intro schema against a client, returning\n * a fully instantiated model when relevant.\n *\n * @param client The client to operate `graphql()` calls through.\n * @param modelIntrospection The model intro schema to construct requests from.\n * @param operation The specific operation name, args, return type details.\n * @param args The arguments to provide to the operation as variables.\n * @param options Request options like headers, etc.\n * @returns Result from the graphql request, model-instantiated when relevant.\n */\nfunction _opSubscription(client, modelIntrospection, operation, getInternals, args, options, customUserAgentDetails) {\n    const operationType = 'subscription';\n    const { name: operationName } = operation;\n    const auth = authModeParams(client, getInternals, options);\n    const headers = getCustomHeaders(client, getInternals, options?.headers);\n    const outerArgsString = outerArguments(operation);\n    const innerArgsString = innerArguments(operation);\n    const selectionSet = operationSelectionSet(modelIntrospection, operation);\n    const returnTypeModelName = hasStringField(operation.type, 'model')\n        ? operation.type.model\n        : undefined;\n    const query = `\n    ${operationType.toLocaleLowerCase()}${outerArgsString} {\n      ${operationName}${innerArgsString} ${selectionSet}\n    }\n  `;\n    const variables = operationVariables(operation, args);\n    const userAgentOverride = createUserAgentOverride(customUserAgentDetails);\n    const observable = client.graphql({\n        ...auth,\n        query,\n        variables,\n        ...userAgentOverride,\n    }, headers);\n    return observable.pipe(map((value) => {\n        const [key] = Object.keys(value.data);\n        const data = value.data[key];\n        const [initialized] = returnTypeModelName\n            ? initializeModel(client, returnTypeModelName, [data], modelIntrospection, auth.authMode, auth.authToken)\n            : [data];\n        return initialized;\n    }));\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}