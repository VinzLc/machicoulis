{"ast":null,"code":"import { assertValidationError } from '../../../errors/utils/assertValidationError.mjs';\nimport { StorageValidationErrorCode } from '../../../errors/types/validation.mjs';\nimport { resolvePrefix } from '../../../utils/resolvePrefix.mjs';\nimport { StorageError } from '../../../errors/StorageError.mjs';\nimport { INVALID_STORAGE_INPUT } from '../../../errors/constants.mjs';\nimport { DEFAULT_ACCESS_LEVEL, LOCAL_TESTING_S3_ENDPOINT } from './constants.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n/**\n * resolve the common input options for S3 API handlers from Amplify configuration and library options.\n *\n * @param {AmplifyClassV6} amplify The Amplify instance.\n * @param {S3ApiOptions} apiOptions The input options for S3 provider.\n * @returns {Promise<ResolvedS3ConfigAndInput>} The resolved common input options for S3 API handlers.\n * @throws A `StorageError` with `error.name` from `StorageValidationErrorCode` indicating invalid\n *   configurations or Amplify library options.\n *\n * @internal\n */\nconst resolveS3ConfigAndInput = async (amplify, apiInput) => {\n  const {\n    options: apiOptions\n  } = apiInput ?? {};\n  /**\n   * IdentityId is always cached in memory so we can safely make calls here. It\n   * should be stable even for unauthenticated users, regardless of credentials.\n   */\n  const {\n    identityId\n  } = await amplify.Auth.fetchAuthSession();\n  /**\n   * A credentials provider function instead of a static credentials object is\n   * used because the long-running tasks like multipart upload may span over the\n   * credentials expiry. Auth.fetchAuthSession() automatically refreshes the\n   * credentials if they are expired.\n   *\n   * The optional forceRefresh option is set when the S3 service returns expired\n   * tokens error in the previous API call attempt.\n   */\n  const credentialsProvider = async options => {\n    if (isLocationCredentialsProvider(apiOptions)) {\n      assertStorageInput(apiInput);\n    }\n    // TODO: forceRefresh option of fetchAuthSession would refresh both tokens and\n    // AWS credentials. So we do not support forceRefreshing from the Auth until\n    // we support refreshing only the credentials.\n    const {\n      credentials\n    } = isLocationCredentialsProvider(apiOptions) ? await apiOptions.locationCredentialsProvider(options) : await amplify.Auth.fetchAuthSession();\n    assertValidationError(!!credentials, StorageValidationErrorCode.NoCredentials);\n    return credentials;\n  };\n  const {\n    bucket: defaultBucket,\n    region: defaultRegion,\n    dangerouslyConnectToHttpEndpointForTesting,\n    buckets\n  } = amplify.getConfig()?.Storage?.S3 ?? {};\n  const {\n    bucket = defaultBucket,\n    region = defaultRegion\n  } = apiOptions?.bucket && resolveBucketConfig(apiOptions, buckets) || {};\n  assertValidationError(!!bucket, StorageValidationErrorCode.NoBucket);\n  assertValidationError(!!region, StorageValidationErrorCode.NoRegion);\n  const {\n    defaultAccessLevel,\n    prefixResolver = resolvePrefix,\n    isObjectLockEnabled\n  } = amplify.libraryOptions?.Storage?.S3 ?? {};\n  const accessLevel = apiOptions?.accessLevel ?? defaultAccessLevel ?? DEFAULT_ACCESS_LEVEL;\n  const targetIdentityId = accessLevel === 'protected' ? apiOptions?.targetIdentityId ?? identityId : identityId;\n  const keyPrefix = await prefixResolver({\n    accessLevel,\n    targetIdentityId\n  });\n  return {\n    s3Config: {\n      credentials: credentialsProvider,\n      region,\n      useAccelerateEndpoint: apiOptions?.useAccelerateEndpoint,\n      ...(apiOptions?.customEndpoint ? {\n        customEndpoint: apiOptions.customEndpoint\n      } : {}),\n      ...(dangerouslyConnectToHttpEndpointForTesting ? {\n        customEndpoint: LOCAL_TESTING_S3_ENDPOINT,\n        forcePathStyle: true\n      } : {})\n    },\n    bucket,\n    keyPrefix,\n    identityId,\n    isObjectLockEnabled\n  };\n};\nconst isLocationCredentialsProvider = options => {\n  return !!options?.locationCredentialsProvider;\n};\nconst isInputWithCallbackPath = input => {\n  return input?.path && typeof input.path === 'function' || input?.destination?.path && typeof input.destination?.path === 'function' || input?.source?.path && typeof input.source?.path === 'function';\n};\nconst isDeprecatedInput = input => {\n  return isInputWithKey(input) || isInputWithPrefix(input) || isInputWithCopySourceOrDestination(input);\n};\nconst assertStorageInput = input => {\n  if (isDeprecatedInput(input) || isInputWithCallbackPath(input)) {\n    throw new StorageError({\n      name: INVALID_STORAGE_INPUT,\n      message: 'The input needs to have a path as a string value.',\n      recoverySuggestion: 'Please provide a valid path as a string value for the input.'\n    });\n  }\n};\nconst isInputWithKey = input => {\n  return !!(typeof input.key === 'string');\n};\nconst isInputWithPrefix = input => {\n  return !!(typeof input.prefix === 'string');\n};\nconst isInputWithCopySourceOrDestination = input => {\n  return !!(typeof input.source?.key === 'string' || typeof input.destination?.key === 'string');\n};\nconst resolveBucketConfig = (apiOptions, buckets) => {\n  if (typeof apiOptions.bucket === 'string') {\n    const bucketConfig = buckets?.[apiOptions.bucket];\n    assertValidationError(!!bucketConfig, StorageValidationErrorCode.InvalidStorageBucket);\n    return {\n      bucket: bucketConfig.bucketName,\n      region: bucketConfig.region\n    };\n  }\n  if (typeof apiOptions.bucket === 'object') {\n    return {\n      bucket: apiOptions.bucket.bucketName,\n      region: apiOptions.bucket.region\n    };\n  }\n};\nexport { resolveS3ConfigAndInput };","map":{"version":3,"names":["resolveS3ConfigAndInput","amplify","apiInput","options","apiOptions","identityId","Auth","fetchAuthSession","credentialsProvider","isLocationCredentialsProvider","assertStorageInput","credentials","locationCredentialsProvider","assertValidationError","StorageValidationErrorCode","NoCredentials","bucket","defaultBucket","region","defaultRegion","dangerouslyConnectToHttpEndpointForTesting","buckets","getConfig","Storage","S3","resolveBucketConfig","NoBucket","NoRegion","defaultAccessLevel","prefixResolver","resolvePrefix","isObjectLockEnabled","libraryOptions","accessLevel","DEFAULT_ACCESS_LEVEL","targetIdentityId","keyPrefix","s3Config","useAccelerateEndpoint","customEndpoint","LOCAL_TESTING_S3_ENDPOINT","forcePathStyle","isInputWithCallbackPath","input","path","destination","source","isDeprecatedInput","isInputWithKey","isInputWithPrefix","isInputWithCopySourceOrDestination","StorageError","name","INVALID_STORAGE_INPUT","message","recoverySuggestion","key","prefix","bucketConfig","InvalidStorageBucket","bucketName"],"sources":["C:\\Users\\vinzl\\workspace\\machicoulis\\daily-image-collector\\node_modules\\@aws-amplify\\storage\\src\\providers\\s3\\utils\\resolveS3ConfigAndInput.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { assertValidationError } from '../../../errors/utils/assertValidationError';\nimport { StorageValidationErrorCode } from '../../../errors/types/validation';\nimport { resolvePrefix as defaultPrefixResolver } from '../../../utils/resolvePrefix';\nimport { StorageError } from '../../../errors/StorageError';\nimport { INVALID_STORAGE_INPUT } from '../../../errors/constants';\nimport { DEFAULT_ACCESS_LEVEL, LOCAL_TESTING_S3_ENDPOINT } from './constants';\n/**\n * resolve the common input options for S3 API handlers from Amplify configuration and library options.\n *\n * @param {AmplifyClassV6} amplify The Amplify instance.\n * @param {S3ApiOptions} apiOptions The input options for S3 provider.\n * @returns {Promise<ResolvedS3ConfigAndInput>} The resolved common input options for S3 API handlers.\n * @throws A `StorageError` with `error.name` from `StorageValidationErrorCode` indicating invalid\n *   configurations or Amplify library options.\n *\n * @internal\n */\nexport const resolveS3ConfigAndInput = async (amplify, apiInput) => {\n    const { options: apiOptions } = apiInput ?? {};\n    /**\n     * IdentityId is always cached in memory so we can safely make calls here. It\n     * should be stable even for unauthenticated users, regardless of credentials.\n     */\n    const { identityId } = await amplify.Auth.fetchAuthSession();\n    /**\n     * A credentials provider function instead of a static credentials object is\n     * used because the long-running tasks like multipart upload may span over the\n     * credentials expiry. Auth.fetchAuthSession() automatically refreshes the\n     * credentials if they are expired.\n     *\n     * The optional forceRefresh option is set when the S3 service returns expired\n     * tokens error in the previous API call attempt.\n     */\n    const credentialsProvider = async (options) => {\n        if (isLocationCredentialsProvider(apiOptions)) {\n            assertStorageInput(apiInput);\n        }\n        // TODO: forceRefresh option of fetchAuthSession would refresh both tokens and\n        // AWS credentials. So we do not support forceRefreshing from the Auth until\n        // we support refreshing only the credentials.\n        const { credentials } = isLocationCredentialsProvider(apiOptions)\n            ? await apiOptions.locationCredentialsProvider(options)\n            : await amplify.Auth.fetchAuthSession();\n        assertValidationError(!!credentials, StorageValidationErrorCode.NoCredentials);\n        return credentials;\n    };\n    const { bucket: defaultBucket, region: defaultRegion, dangerouslyConnectToHttpEndpointForTesting, buckets, } = amplify.getConfig()?.Storage?.S3 ?? {};\n    const { bucket = defaultBucket, region = defaultRegion } = (apiOptions?.bucket && resolveBucketConfig(apiOptions, buckets)) || {};\n    assertValidationError(!!bucket, StorageValidationErrorCode.NoBucket);\n    assertValidationError(!!region, StorageValidationErrorCode.NoRegion);\n    const { defaultAccessLevel, prefixResolver = defaultPrefixResolver, isObjectLockEnabled, } = amplify.libraryOptions?.Storage?.S3 ?? {};\n    const accessLevel = apiOptions?.accessLevel ?? defaultAccessLevel ?? DEFAULT_ACCESS_LEVEL;\n    const targetIdentityId = accessLevel === 'protected'\n        ? (apiOptions?.targetIdentityId ?? identityId)\n        : identityId;\n    const keyPrefix = await prefixResolver({ accessLevel, targetIdentityId });\n    return {\n        s3Config: {\n            credentials: credentialsProvider,\n            region,\n            useAccelerateEndpoint: apiOptions?.useAccelerateEndpoint,\n            ...(apiOptions?.customEndpoint\n                ? { customEndpoint: apiOptions.customEndpoint }\n                : {}),\n            ...(dangerouslyConnectToHttpEndpointForTesting\n                ? {\n                    customEndpoint: LOCAL_TESTING_S3_ENDPOINT,\n                    forcePathStyle: true,\n                }\n                : {}),\n        },\n        bucket,\n        keyPrefix,\n        identityId,\n        isObjectLockEnabled,\n    };\n};\nconst isLocationCredentialsProvider = (options) => {\n    return !!options?.locationCredentialsProvider;\n};\nconst isInputWithCallbackPath = (input) => {\n    return ((input?.path &&\n        typeof input.path === 'function') ||\n        (input?.destination?.path &&\n            typeof input.destination?.path === 'function') ||\n        (input?.source?.path &&\n            typeof input.source?.path === 'function'));\n};\nconst isDeprecatedInput = (input) => {\n    return (isInputWithKey(input) ||\n        isInputWithPrefix(input) ||\n        isInputWithCopySourceOrDestination(input));\n};\nconst assertStorageInput = (input) => {\n    if (isDeprecatedInput(input) || isInputWithCallbackPath(input)) {\n        throw new StorageError({\n            name: INVALID_STORAGE_INPUT,\n            message: 'The input needs to have a path as a string value.',\n            recoverySuggestion: 'Please provide a valid path as a string value for the input.',\n        });\n    }\n};\nconst isInputWithKey = (input) => {\n    return !!(typeof input.key === 'string');\n};\nconst isInputWithPrefix = (input) => {\n    return !!(typeof input.prefix === 'string');\n};\nconst isInputWithCopySourceOrDestination = (input) => {\n    return !!(typeof input.source?.key === 'string' ||\n        typeof input.destination?.key === 'string');\n};\nconst resolveBucketConfig = (apiOptions, buckets) => {\n    if (typeof apiOptions.bucket === 'string') {\n        const bucketConfig = buckets?.[apiOptions.bucket];\n        assertValidationError(!!bucketConfig, StorageValidationErrorCode.InvalidStorageBucket);\n        return { bucket: bucketConfig.bucketName, region: bucketConfig.region };\n    }\n    if (typeof apiOptions.bucket === 'object') {\n        return {\n            bucket: apiOptions.bucket.bucketName,\n            region: apiOptions.bucket.region,\n        };\n    }\n};\n"],"mappings":";;;;;;;AAAA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACY,MAACA,uBAAuB,GAAG,MAAAA,CAAOC,OAAO,EAAEC,QAAQ,KAAK;EAChE,MAAM;IAAEC,OAAO,EAAEC;EAAU,CAAE,GAAGF,QAAQ,IAAI,EAAE;EAClD;AACA;AACA;AACA;EACI,MAAM;IAAEG;EAAU,CAAE,GAAG,MAAMJ,OAAO,CAACK,IAAI,CAACC,gBAAgB,EAAE;EAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMC,mBAAmB,GAAG,MAAOL,OAAO,IAAK;IAC3C,IAAIM,6BAA6B,CAACL,UAAU,CAAC,EAAE;MAC3CM,kBAAkB,CAACR,QAAQ,CAAC;IACxC;IACA;IACA;IACA;IACQ,MAAM;MAAES;IAAW,CAAE,GAAGF,6BAA6B,CAACL,UAAU,IAC1D,MAAMA,UAAU,CAACQ,2BAA2B,CAACT,OAAO,IACpD,MAAMF,OAAO,CAACK,IAAI,CAACC,gBAAgB,EAAE;IAC3CM,qBAAqB,CAAC,CAAC,CAACF,WAAW,EAAEG,0BAA0B,CAACC,aAAa,CAAC;IAC9E,OAAOJ,WAAW;EAC1B,CAAK;EACD,MAAM;IAAEK,MAAM,EAAEC,aAAa;IAAEC,MAAM,EAAEC,aAAa;IAAEC,0CAA0C;IAAEC;EAAO,CAAG,GAAGpB,OAAO,CAACqB,SAAS,EAAE,EAAEC,OAAO,EAAEC,EAAE,IAAI,EAAE;EACrJ,MAAM;IAAER,MAAM,GAAGC,aAAa;IAAEC,MAAM,GAAGC;EAAa,CAAE,GAAIf,UAAU,EAAEY,MAAM,IAAIS,mBAAmB,CAACrB,UAAU,EAAEiB,OAAO,CAAC,IAAK,EAAE;EACjIR,qBAAqB,CAAC,CAAC,CAACG,MAAM,EAAEF,0BAA0B,CAACY,QAAQ,CAAC;EACpEb,qBAAqB,CAAC,CAAC,CAACK,MAAM,EAAEJ,0BAA0B,CAACa,QAAQ,CAAC;EACpE,MAAM;IAAEC,kBAAkB;IAAEC,cAAc,GAAGC,aAAqB;IAAEC;EAAmB,CAAG,GAAG9B,OAAO,CAAC+B,cAAc,EAAET,OAAO,EAAEC,EAAE,IAAI,EAAE;EACtI,MAAMS,WAAW,GAAG7B,UAAU,EAAE6B,WAAW,IAAIL,kBAAkB,IAAIM,oBAAoB;EACzF,MAAMC,gBAAgB,GAAGF,WAAW,KAAK,cAClC7B,UAAU,EAAE+B,gBAAgB,IAAI9B,UAAU,GAC3CA,UAAU;EAChB,MAAM+B,SAAS,GAAG,MAAMP,cAAc,CAAC;IAAEI,WAAW;IAAEE;EAAgB,CAAE,CAAC;EACzE,OAAO;IACHE,QAAQ,EAAE;MACN1B,WAAW,EAAEH,mBAAmB;MAChCU,MAAM;MACNoB,qBAAqB,EAAElC,UAAU,EAAEkC,qBAAqB;MACxD,IAAIlC,UAAU,EAAEmC,cAAA,GACV;QAAEA,cAAc,EAAEnC,UAAU,CAACmC;MAAc,IAC3C,EAAE,CAAC;MACT,IAAInB,0CAAA,GACE;QACEmB,cAAc,EAAEC,yBAAyB;QACzCC,cAAc,EAAE;MACpC,IACkB,EAAE;IACpB,CAAS;IACDzB,MAAM;IACNoB,SAAS;IACT/B,UAAU;IACV0B;EACR,CAAK;AACL;AACA,MAAMtB,6BAA6B,GAAIN,OAAO,IAAK;EAC/C,OAAO,CAAC,CAACA,OAAO,EAAES,2BAA2B;AACjD,CAAC;AACD,MAAM8B,uBAAuB,GAAIC,KAAK,IAAK;EACvC,OAASA,KAAK,EAAEC,IAAI,IAChB,OAAOD,KAAK,CAACC,IAAI,KAAK,UAAU,IAC/BD,KAAK,EAAEE,WAAW,EAAED,IAAI,IACrB,OAAOD,KAAK,CAACE,WAAW,EAAED,IAAI,KAAK,UAAW,IACjDD,KAAK,EAAEG,MAAM,EAAEF,IAAI,IAChB,OAAOD,KAAK,CAACG,MAAM,EAAEF,IAAI,KAAK,UAAW;AACrD,CAAC;AACD,MAAMG,iBAAiB,GAAIJ,KAAK,IAAK;EACjC,OAAQK,cAAc,CAACL,KAAK,CAAC,IACzBM,iBAAiB,CAACN,KAAK,CAAC,IACxBO,kCAAkC,CAACP,KAAK,CAAC;AACjD,CAAC;AACD,MAAMjC,kBAAkB,GAAIiC,KAAK,IAAK;EAClC,IAAII,iBAAiB,CAACJ,KAAK,CAAC,IAAID,uBAAuB,CAACC,KAAK,CAAC,EAAE;IAC5D,MAAM,IAAIQ,YAAY,CAAC;MACnBC,IAAI,EAAEC,qBAAqB;MAC3BC,OAAO,EAAE,mDAAmD;MAC5DC,kBAAkB,EAAE;IAChC,CAAS,CAAC;EACV;AACA,CAAC;AACD,MAAMP,cAAc,GAAIL,KAAK,IAAK;EAC9B,OAAO,CAAC,EAAE,OAAOA,KAAK,CAACa,GAAG,KAAK,QAAQ,CAAC;AAC5C,CAAC;AACD,MAAMP,iBAAiB,GAAIN,KAAK,IAAK;EACjC,OAAO,CAAC,EAAE,OAAOA,KAAK,CAACc,MAAM,KAAK,QAAQ,CAAC;AAC/C,CAAC;AACD,MAAMP,kCAAkC,GAAIP,KAAK,IAAK;EAClD,OAAO,CAAC,EAAE,OAAOA,KAAK,CAACG,MAAM,EAAEU,GAAG,KAAK,QAAQ,IAC3C,OAAOb,KAAK,CAACE,WAAW,EAAEW,GAAG,KAAK,QAAQ,CAAC;AACnD,CAAC;AACD,MAAM/B,mBAAmB,GAAGA,CAACrB,UAAU,EAAEiB,OAAO,KAAK;EACjD,IAAI,OAAOjB,UAAU,CAACY,MAAM,KAAK,QAAQ,EAAE;IACvC,MAAM0C,YAAY,GAAGrC,OAAO,GAAGjB,UAAU,CAACY,MAAM,CAAC;IACjDH,qBAAqB,CAAC,CAAC,CAAC6C,YAAY,EAAE5C,0BAA0B,CAAC6C,oBAAoB,CAAC;IACtF,OAAO;MAAE3C,MAAM,EAAE0C,YAAY,CAACE,UAAU;MAAE1C,MAAM,EAAEwC,YAAY,CAACxC;IAAM,CAAE;EAC/E;EACI,IAAI,OAAOd,UAAU,CAACY,MAAM,KAAK,QAAQ,EAAE;IACvC,OAAO;MACHA,MAAM,EAAEZ,UAAU,CAACY,MAAM,CAAC4C,UAAU;MACpC1C,MAAM,EAAEd,UAAU,CAACY,MAAM,CAACE;IACtC,CAAS;EACT;AACA,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}