{"ast":null,"code":"'use strict';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.xhrTransferHandler = void 0;\nconst aws_client_utils_1 = require(\"@aws-amplify/core/internals/aws-client-utils\");\nconst core_1 = require(\"@aws-amplify/core\");\nconst CanceledError_1 = require(\"../../../../../errors/CanceledError\");\nconst StorageError_1 = require(\"../../../../../errors/StorageError\");\nconst constants_1 = require(\"./constants\");\nconst logger = new core_1.ConsoleLogger('xhr-http-handler');\n/**\n * Base transfer handler implementation using XMLHttpRequest to support upload and download progress events.\n *\n * @param request - The request object.\n * @param options - The request options.\n * @returns A promise that will be resolved with the response object.\n *\n * @internal\n */\nconst xhrTransferHandler = (request, options) => {\n  const {\n    url,\n    method,\n    headers,\n    body\n  } = request;\n  const {\n    onDownloadProgress,\n    onUploadProgress,\n    responseType,\n    abortSignal\n  } = options;\n  return new Promise((resolve, reject) => {\n    let xhr = new XMLHttpRequest();\n    xhr.open(method.toUpperCase(), url.toString());\n    Object.entries(headers).filter(([header]) => !FORBIDDEN_HEADERS.includes(header)).forEach(([header, value]) => {\n      xhr.setRequestHeader(header, value);\n    });\n    xhr.responseType = responseType;\n    if (onDownloadProgress) {\n      xhr.addEventListener('progress', event => {\n        onDownloadProgress(convertToTransferProgressEvent(event));\n        logger.debug(event);\n      });\n    }\n    if (onUploadProgress) {\n      xhr.upload.addEventListener('progress', event => {\n        onUploadProgress(convertToTransferProgressEvent(event));\n        logger.debug(event);\n      });\n    }\n    xhr.addEventListener('error', () => {\n      const networkError = new StorageError_1.StorageError({\n        message: constants_1.NETWORK_ERROR_MESSAGE,\n        name: constants_1.NETWORK_ERROR_CODE\n      });\n      logger.error(constants_1.NETWORK_ERROR_MESSAGE);\n      reject(networkError);\n      xhr = null; // clean up request\n    });\n    // Handle browser request cancellation (as opposed to a manual cancellation)\n    xhr.addEventListener('abort', () => {\n      // The abort event can be triggered after the error or load event. So we need to check if the xhr is null.\n      // When request is aborted by AbortSignal, the promise is rejected in the abortSignal's 'abort' event listener.\n      if (!xhr || abortSignal?.aborted) return;\n      // Handle abort request caused by browser instead of AbortController\n      // see: https://github.com/axios/axios/issues/537\n      const error = buildHandlerError(constants_1.ABORT_ERROR_MESSAGE, constants_1.ABORT_ERROR_CODE);\n      logger.error(constants_1.ABORT_ERROR_MESSAGE);\n      reject(error);\n      xhr = null; // clean up request\n    });\n    // Skip handling timeout error since we don't have a timeout\n    xhr.addEventListener('readystatechange', () => {\n      if (!xhr || xhr.readyState !== xhr.DONE) {\n        return;\n      }\n      const onloadend = () => {\n        // The load event is triggered after the error/abort/load event. So we need to check if the xhr is null.\n        if (!xhr) return;\n        const responseHeaders = convertResponseHeaders(xhr.getAllResponseHeaders());\n        const {\n          responseType: loadEndResponseType\n        } = xhr;\n        const responseBlob = xhr.response;\n        const responseText = loadEndResponseType === 'text' ? xhr.responseText : '';\n        const bodyMixIn = {\n          blob: () => Promise.resolve(responseBlob),\n          text: (0, aws_client_utils_1.withMemoization)(() => loadEndResponseType === 'blob' ? readBlobAsText(responseBlob) : Promise.resolve(responseText)),\n          json: () => Promise.reject(\n          // S3 does not support JSON response. So fail-fast here with nicer error message.\n          new Error('Parsing response to JSON is not implemented. Please use response.text() instead.'))\n        };\n        const response = {\n          statusCode: xhr.status,\n          headers: responseHeaders,\n          // The xhr.responseType is only set to 'blob' for streaming binary S3 object data. The streaming data is\n          // exposed via public interface of Storage.get(). So we need to return the response as a Blob object for\n          // backward compatibility. In other cases, the response payload is only used internally, we return it is\n          // {@link ResponseBodyMixin}\n          body: xhr.responseType === 'blob' ? Object.assign(responseBlob, bodyMixIn) : bodyMixIn\n        };\n        resolve(response);\n        xhr = null; // clean up request\n      };\n      // readystate handler is calling before onerror or ontimeout handlers,\n      // so we should call onloadend on the next 'tick'\n      // @see https://github.com/axios/axios/blob/9588fcdec8aca45c3ba2f7968988a5d03f23168c/lib/adapters/xhr.js#L98-L99\n      setTimeout(onloadend);\n    });\n    if (abortSignal) {\n      const onCanceled = () => {\n        // The abort event is triggered after the error or load event. So we need to check if the xhr is null.\n        if (!xhr) {\n          return;\n        }\n        const canceledError = new CanceledError_1.CanceledError({\n          name: constants_1.CANCELED_ERROR_CODE,\n          message: constants_1.CANCELED_ERROR_MESSAGE\n        });\n        reject(canceledError);\n        xhr.abort();\n        xhr = null;\n      };\n      abortSignal.aborted ? onCanceled() : abortSignal.addEventListener('abort', onCanceled);\n    }\n    if (typeof ReadableStream === 'function' && body instanceof ReadableStream) {\n      // This does not matter as previous implementation uses Axios which does not support ReadableStream anyway.\n      throw new Error('ReadableStream request payload is not supported.');\n    }\n    xhr.send(body ?? null);\n  });\n};\nexports.xhrTransferHandler = xhrTransferHandler;\nconst convertToTransferProgressEvent = event => ({\n  transferredBytes: event.loaded,\n  totalBytes: event.lengthComputable ? event.total : undefined\n});\nconst buildHandlerError = (message, name) => {\n  const error = new Error(message);\n  error.name = name;\n  return error;\n};\n/**\n * Convert xhr.getAllResponseHeaders() string to a Record<string, string>. Note that modern browser already returns\n * header names in lowercase.\n * @param xhrHeaders - string of headers returned from xhr.getAllResponseHeaders()\n */\nconst convertResponseHeaders = xhrHeaders => {\n  if (!xhrHeaders) {\n    return {};\n  }\n  return xhrHeaders.split('\\r\\n').reduce((headerMap, line) => {\n    const parts = line.split(': ');\n    const header = parts.shift();\n    const value = parts.join(': ');\n    headerMap[header.toLowerCase()] = value;\n    return headerMap;\n  }, {});\n};\nconst readBlobAsText = blob => {\n  const reader = new FileReader();\n  return new Promise((resolve, reject) => {\n    reader.onloadend = () => {\n      if (reader.readyState !== FileReader.DONE) {\n        return;\n      }\n      resolve(reader.result);\n    };\n    reader.onerror = () => {\n      reject(reader.error);\n    };\n    reader.readAsText(blob);\n  });\n};\n// To add more forbidden headers as found set by S3. Intentionally NOT list all of them here to save bundle size.\n// https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\nconst FORBIDDEN_HEADERS = ['host'];","map":{"version":3,"names":["Object","defineProperty","exports","value","xhrTransferHandler","aws_client_utils_1","require","core_1","CanceledError_1","StorageError_1","constants_1","logger","ConsoleLogger","request","options","url","method","headers","body","onDownloadProgress","onUploadProgress","responseType","abortSignal","Promise","resolve","reject","xhr","XMLHttpRequest","open","toUpperCase","toString","entries","filter","header","FORBIDDEN_HEADERS","includes","forEach","setRequestHeader","addEventListener","event","convertToTransferProgressEvent","debug","upload","networkError","StorageError","message","NETWORK_ERROR_MESSAGE","name","NETWORK_ERROR_CODE","error","aborted","buildHandlerError","ABORT_ERROR_MESSAGE","ABORT_ERROR_CODE","readyState","DONE","onloadend","responseHeaders","convertResponseHeaders","getAllResponseHeaders","loadEndResponseType","responseBlob","response","responseText","bodyMixIn","blob","text","withMemoization","readBlobAsText","json","Error","statusCode","status","assign","setTimeout","onCanceled","canceledError","CanceledError","CANCELED_ERROR_CODE","CANCELED_ERROR_MESSAGE","abort","ReadableStream","send","transferredBytes","loaded","totalBytes","lengthComputable","total","undefined","xhrHeaders","split","reduce","headerMap","line","parts","shift","join","toLowerCase","reader","FileReader","result","onerror","readAsText"],"sources":["C:\\Users\\vinzl\\workspace\\machicoulis\\daily-image-collector\\node_modules\\@aws-amplify\\storage\\src\\providers\\s3\\utils\\client\\runtime\\xhrTransferHandler.ts"],"sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.xhrTransferHandler = void 0;\nconst aws_client_utils_1 = require(\"@aws-amplify/core/internals/aws-client-utils\");\nconst core_1 = require(\"@aws-amplify/core\");\nconst CanceledError_1 = require(\"../../../../../errors/CanceledError\");\nconst StorageError_1 = require(\"../../../../../errors/StorageError\");\nconst constants_1 = require(\"./constants\");\nconst logger = new core_1.ConsoleLogger('xhr-http-handler');\n/**\n * Base transfer handler implementation using XMLHttpRequest to support upload and download progress events.\n *\n * @param request - The request object.\n * @param options - The request options.\n * @returns A promise that will be resolved with the response object.\n *\n * @internal\n */\nconst xhrTransferHandler = (request, options) => {\n    const { url, method, headers, body } = request;\n    const { onDownloadProgress, onUploadProgress, responseType, abortSignal } = options;\n    return new Promise((resolve, reject) => {\n        let xhr = new XMLHttpRequest();\n        xhr.open(method.toUpperCase(), url.toString());\n        Object.entries(headers)\n            .filter(([header]) => !FORBIDDEN_HEADERS.includes(header))\n            .forEach(([header, value]) => {\n            xhr.setRequestHeader(header, value);\n        });\n        xhr.responseType = responseType;\n        if (onDownloadProgress) {\n            xhr.addEventListener('progress', event => {\n                onDownloadProgress(convertToTransferProgressEvent(event));\n                logger.debug(event);\n            });\n        }\n        if (onUploadProgress) {\n            xhr.upload.addEventListener('progress', event => {\n                onUploadProgress(convertToTransferProgressEvent(event));\n                logger.debug(event);\n            });\n        }\n        xhr.addEventListener('error', () => {\n            const networkError = new StorageError_1.StorageError({\n                message: constants_1.NETWORK_ERROR_MESSAGE,\n                name: constants_1.NETWORK_ERROR_CODE,\n            });\n            logger.error(constants_1.NETWORK_ERROR_MESSAGE);\n            reject(networkError);\n            xhr = null; // clean up request\n        });\n        // Handle browser request cancellation (as opposed to a manual cancellation)\n        xhr.addEventListener('abort', () => {\n            // The abort event can be triggered after the error or load event. So we need to check if the xhr is null.\n            // When request is aborted by AbortSignal, the promise is rejected in the abortSignal's 'abort' event listener.\n            if (!xhr || abortSignal?.aborted)\n                return;\n            // Handle abort request caused by browser instead of AbortController\n            // see: https://github.com/axios/axios/issues/537\n            const error = buildHandlerError(constants_1.ABORT_ERROR_MESSAGE, constants_1.ABORT_ERROR_CODE);\n            logger.error(constants_1.ABORT_ERROR_MESSAGE);\n            reject(error);\n            xhr = null; // clean up request\n        });\n        // Skip handling timeout error since we don't have a timeout\n        xhr.addEventListener('readystatechange', () => {\n            if (!xhr || xhr.readyState !== xhr.DONE) {\n                return;\n            }\n            const onloadend = () => {\n                // The load event is triggered after the error/abort/load event. So we need to check if the xhr is null.\n                if (!xhr)\n                    return;\n                const responseHeaders = convertResponseHeaders(xhr.getAllResponseHeaders());\n                const { responseType: loadEndResponseType } = xhr;\n                const responseBlob = xhr.response;\n                const responseText = loadEndResponseType === 'text' ? xhr.responseText : '';\n                const bodyMixIn = {\n                    blob: () => Promise.resolve(responseBlob),\n                    text: (0, aws_client_utils_1.withMemoization)(() => loadEndResponseType === 'blob'\n                        ? readBlobAsText(responseBlob)\n                        : Promise.resolve(responseText)),\n                    json: () => Promise.reject(\n                    // S3 does not support JSON response. So fail-fast here with nicer error message.\n                    new Error('Parsing response to JSON is not implemented. Please use response.text() instead.')),\n                };\n                const response = {\n                    statusCode: xhr.status,\n                    headers: responseHeaders,\n                    // The xhr.responseType is only set to 'blob' for streaming binary S3 object data. The streaming data is\n                    // exposed via public interface of Storage.get(). So we need to return the response as a Blob object for\n                    // backward compatibility. In other cases, the response payload is only used internally, we return it is\n                    // {@link ResponseBodyMixin}\n                    body: (xhr.responseType === 'blob'\n                        ? Object.assign(responseBlob, bodyMixIn)\n                        : bodyMixIn),\n                };\n                resolve(response);\n                xhr = null; // clean up request\n            };\n            // readystate handler is calling before onerror or ontimeout handlers,\n            // so we should call onloadend on the next 'tick'\n            // @see https://github.com/axios/axios/blob/9588fcdec8aca45c3ba2f7968988a5d03f23168c/lib/adapters/xhr.js#L98-L99\n            setTimeout(onloadend);\n        });\n        if (abortSignal) {\n            const onCanceled = () => {\n                // The abort event is triggered after the error or load event. So we need to check if the xhr is null.\n                if (!xhr) {\n                    return;\n                }\n                const canceledError = new CanceledError_1.CanceledError({\n                    name: constants_1.CANCELED_ERROR_CODE,\n                    message: constants_1.CANCELED_ERROR_MESSAGE,\n                });\n                reject(canceledError);\n                xhr.abort();\n                xhr = null;\n            };\n            abortSignal.aborted\n                ? onCanceled()\n                : abortSignal.addEventListener('abort', onCanceled);\n        }\n        if (typeof ReadableStream === 'function' &&\n            body instanceof ReadableStream) {\n            // This does not matter as previous implementation uses Axios which does not support ReadableStream anyway.\n            throw new Error('ReadableStream request payload is not supported.');\n        }\n        xhr.send(body ?? null);\n    });\n};\nexports.xhrTransferHandler = xhrTransferHandler;\nconst convertToTransferProgressEvent = (event) => ({\n    transferredBytes: event.loaded,\n    totalBytes: event.lengthComputable ? event.total : undefined,\n});\nconst buildHandlerError = (message, name) => {\n    const error = new Error(message);\n    error.name = name;\n    return error;\n};\n/**\n * Convert xhr.getAllResponseHeaders() string to a Record<string, string>. Note that modern browser already returns\n * header names in lowercase.\n * @param xhrHeaders - string of headers returned from xhr.getAllResponseHeaders()\n */\nconst convertResponseHeaders = (xhrHeaders) => {\n    if (!xhrHeaders) {\n        return {};\n    }\n    return xhrHeaders\n        .split('\\r\\n')\n        .reduce((headerMap, line) => {\n        const parts = line.split(': ');\n        const header = parts.shift();\n        const value = parts.join(': ');\n        headerMap[header.toLowerCase()] = value;\n        return headerMap;\n    }, {});\n};\nconst readBlobAsText = (blob) => {\n    const reader = new FileReader();\n    return new Promise((resolve, reject) => {\n        reader.onloadend = () => {\n            if (reader.readyState !== FileReader.DONE) {\n                return;\n            }\n            resolve(reader.result);\n        };\n        reader.onerror = () => {\n            reject(reader.error);\n        };\n        reader.readAsText(blob);\n    });\n};\n// To add more forbidden headers as found set by S3. Intentionally NOT list all of them here to save bundle size.\n// https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name\nconst FORBIDDEN_HEADERS = ['host'];\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}