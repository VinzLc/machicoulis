{"ast":null,"code":"'use strict';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getMultipartUploadHandlers = void 0;\nconst core_1 = require(\"@aws-amplify/core\");\nconst utils_1 = require(\"@aws-amplify/core/internals/utils\");\nconst utils_2 = require(\"../../../../utils\");\nconst constants_1 = require(\"../../../../utils/constants\");\nconst StorageError_1 = require(\"../../../../../../errors/StorageError\");\nconst CanceledError_1 = require(\"../../../../../../errors/CanceledError\");\nconst s3data_1 = require(\"../../../../utils/client/s3data\");\nconst userAgent_1 = require(\"../../../../utils/userAgent\");\nconst utils_3 = require(\"../../../../../../utils\");\nconst crc32_1 = require(\"../../../../utils/crc32\");\nconst IntegrityError_1 = require(\"../../../../../../errors/IntegrityError\");\nconst uploadPartExecutor_1 = require(\"./uploadPartExecutor\");\nconst uploadCache_1 = require(\"./uploadCache\");\nconst progressTracker_1 = require(\"./progressTracker\");\nconst initialUpload_1 = require(\"./initialUpload\");\nconst getDataChunker_1 = require(\"./getDataChunker\");\nconst calculatePartSize_1 = require(\"./calculatePartSize\");\n/**\n * Create closure hiding the multipart upload implementation details and expose the upload job and control functions(\n * onPause, onResume, onCancel).\n *\n * @internal\n */\nconst getMultipartUploadHandlers = (uploadDataInput, size) => {\n  let resolveCallback;\n  let rejectCallback;\n  let inProgressUpload;\n  let resolvedS3Config;\n  let abortController;\n  let resolvedAccessLevel;\n  let resolvedBucket;\n  let resolvedKeyPrefix;\n  let resolvedIdentityId;\n  let uploadCacheKey;\n  let finalKey;\n  let expectedBucketOwner;\n  // Special flag that differentiates HTTP requests abort error caused by pause() from ones caused by cancel().\n  // The former one should NOT cause the upload job to throw, but cancels any pending HTTP requests.\n  // This should be replaced by a special abort reason. However,the support of this API is lagged behind.\n  let isAbortSignalFromPause = false;\n  const {\n    resumableUploadsCache\n  } = uploadDataInput.options ?? {};\n  const startUpload = async () => {\n    const {\n      options: uploadDataOptions,\n      data\n    } = uploadDataInput;\n    const resolvedS3Options = await (0, utils_2.resolveS3ConfigAndInput)(core_1.Amplify, uploadDataInput);\n    abortController = new AbortController();\n    isAbortSignalFromPause = false;\n    resolvedS3Config = resolvedS3Options.s3Config;\n    resolvedBucket = resolvedS3Options.bucket;\n    resolvedIdentityId = resolvedS3Options.identityId;\n    expectedBucketOwner = uploadDataOptions?.expectedBucketOwner;\n    const {\n      inputType,\n      objectKey\n    } = (0, utils_2.validateStorageOperationInput)(uploadDataInput, resolvedIdentityId);\n    const {\n      contentDisposition,\n      contentEncoding,\n      contentType = 'application/octet-stream',\n      metadata,\n      preventOverwrite,\n      onProgress\n    } = uploadDataOptions ?? {};\n    finalKey = objectKey;\n    // Resolve \"key\" specific options\n    if (inputType === constants_1.STORAGE_INPUT_KEY) {\n      const accessLevel = uploadDataOptions?.accessLevel;\n      resolvedKeyPrefix = resolvedS3Options.keyPrefix;\n      finalKey = resolvedKeyPrefix + objectKey;\n      resolvedAccessLevel = resolveAccessLevel(accessLevel);\n    }\n    const optionsHash = await (0, crc32_1.calculateContentCRC32)((0, uploadCache_1.serializeUploadOptions)(uploadDataOptions));\n    if (!inProgressUpload) {\n      const {\n        uploadId,\n        cachedParts,\n        finalCrc32\n      } = await (0, initialUpload_1.loadOrCreateMultipartUpload)({\n        s3Config: resolvedS3Config,\n        accessLevel: resolvedAccessLevel,\n        bucket: resolvedBucket,\n        keyPrefix: resolvedKeyPrefix,\n        key: objectKey,\n        contentType,\n        contentDisposition,\n        contentEncoding,\n        metadata,\n        data,\n        size,\n        abortSignal: abortController.signal,\n        checksumAlgorithm: uploadDataOptions?.checksumAlgorithm,\n        optionsHash,\n        resumableUploadsCache,\n        expectedBucketOwner\n      });\n      inProgressUpload = {\n        uploadId,\n        completedParts: cachedParts,\n        finalCrc32\n      };\n    }\n    uploadCacheKey = size ? (0, uploadCache_1.getUploadsCacheKey)({\n      file: data instanceof File ? data : undefined,\n      accessLevel: resolvedAccessLevel,\n      contentType: uploadDataOptions?.contentType,\n      bucket: resolvedBucket,\n      size,\n      key: objectKey,\n      optionsHash\n    }) : undefined;\n    const dataChunker = (0, getDataChunker_1.getDataChunker)(data, size);\n    const completedPartNumberSet = new Set(inProgressUpload.completedParts.map(({\n      PartNumber\n    }) => PartNumber));\n    const onPartUploadCompletion = (partNumber, eTag, crc32) => {\n      inProgressUpload?.completedParts.push({\n        PartNumber: partNumber,\n        ETag: eTag,\n        // TODO: crc32 can always be added once RN also has an implementation\n        ...(crc32 ? {\n          ChecksumCRC32: crc32\n        } : {})\n      });\n    };\n    const concurrentUploadsProgressTracker = (0, progressTracker_1.getConcurrentUploadsProgressTracker)({\n      size,\n      onProgress\n    });\n    const concurrentUploadPartExecutors = [];\n    for (let index = 0; index < constants_1.DEFAULT_QUEUE_SIZE; index++) {\n      concurrentUploadPartExecutors.push((0, uploadPartExecutor_1.uploadPartExecutor)({\n        dataChunkerGenerator: dataChunker,\n        completedPartNumberSet,\n        s3Config: resolvedS3Config,\n        abortSignal: abortController.signal,\n        bucket: resolvedBucket,\n        finalKey,\n        uploadId: inProgressUpload.uploadId,\n        onPartUploadCompletion,\n        onProgress: concurrentUploadsProgressTracker.getOnProgressListener(),\n        isObjectLockEnabled: resolvedS3Options.isObjectLockEnabled,\n        useCRC32Checksum: Boolean(inProgressUpload.finalCrc32),\n        expectedBucketOwner\n      }));\n    }\n    await Promise.all(concurrentUploadPartExecutors);\n    validateCompletedParts(inProgressUpload.completedParts, size);\n    const {\n      ETag: eTag\n    } = await (0, s3data_1.completeMultipartUpload)({\n      ...resolvedS3Config,\n      abortSignal: abortController.signal,\n      userAgentValue: (0, userAgent_1.getStorageUserAgentValue)(utils_1.StorageAction.UploadData)\n    }, {\n      Bucket: resolvedBucket,\n      Key: finalKey,\n      UploadId: inProgressUpload.uploadId,\n      ChecksumCRC32: inProgressUpload.finalCrc32,\n      ChecksumType: inProgressUpload.finalCrc32 ? 'FULL_OBJECT' : undefined,\n      IfNoneMatch: preventOverwrite ? '*' : undefined,\n      MultipartUpload: {\n        Parts: sortUploadParts(inProgressUpload.completedParts)\n      },\n      ExpectedBucketOwner: expectedBucketOwner\n    });\n    // If full-object CRC32 checksum is NOT enabled, we need to ensure the upload integrity by making extra HEAD call\n    // to verify the uploaded object size.\n    if (!inProgressUpload.finalCrc32) {\n      const {\n        ContentLength: uploadedObjectSize,\n        $metadata\n      } = await (0, s3data_1.headObject)(resolvedS3Config, {\n        Bucket: resolvedBucket,\n        Key: finalKey,\n        ExpectedBucketOwner: expectedBucketOwner\n      });\n      if (uploadedObjectSize && uploadedObjectSize !== size) {\n        throw new StorageError_1.StorageError({\n          name: 'Error',\n          message: `Upload failed. Expected object size ${size}, but got ${uploadedObjectSize}.`,\n          metadata: $metadata\n        });\n      }\n    }\n    if (resumableUploadsCache && uploadCacheKey) {\n      await (0, uploadCache_1.removeCachedUpload)(resumableUploadsCache, uploadCacheKey);\n    }\n    const result = {\n      eTag,\n      contentType,\n      metadata\n    };\n    return inputType === constants_1.STORAGE_INPUT_KEY ? {\n      key: objectKey,\n      ...result\n    } : {\n      path: objectKey,\n      ...result\n    };\n  };\n  const startUploadWithResumability = () => startUpload().then(resolveCallback).catch(error => {\n    const abortSignal = abortController?.signal;\n    if (abortSignal?.aborted && isAbortSignalFromPause) {\n      utils_3.logger.debug('upload paused.');\n    } else {\n      // Uncaught errors should be exposed to the users.\n      rejectCallback(error);\n    }\n  });\n  const multipartUploadJob = () => new Promise((resolve, reject) => {\n    resolveCallback = resolve;\n    rejectCallback = reject;\n    startUploadWithResumability();\n  });\n  const onPause = () => {\n    isAbortSignalFromPause = true;\n    abortController?.abort();\n  };\n  const onResume = () => {\n    startUploadWithResumability();\n  };\n  const onCancel = message => {\n    // 1. abort in-flight API requests\n    abortController?.abort(message);\n    const cancelUpload = async () => {\n      // 2. clear upload cache.\n      if (uploadCacheKey && resumableUploadsCache) {\n        await (0, uploadCache_1.removeCachedUpload)(resumableUploadsCache, uploadCacheKey);\n      }\n      // 3. clear multipart upload on server side.\n      await (0, s3data_1.abortMultipartUpload)(resolvedS3Config, {\n        Bucket: resolvedBucket,\n        Key: finalKey,\n        UploadId: inProgressUpload?.uploadId,\n        ExpectedBucketOwner: expectedBucketOwner\n      });\n    };\n    cancelUpload().catch(e => {\n      utils_3.logger.debug('error when cancelling upload task.', e);\n    });\n    rejectCallback(\n    // Internal error that should not be exposed to the users. They should use isCancelError() to check if\n    // the error is caused by cancel().\n    new CanceledError_1.CanceledError(message ? {\n      message\n    } : undefined));\n  };\n  return {\n    multipartUploadJob,\n    onPause,\n    onResume,\n    onCancel\n  };\n};\nexports.getMultipartUploadHandlers = getMultipartUploadHandlers;\nconst resolveAccessLevel = accessLevel => accessLevel ?? core_1.Amplify.libraryOptions.Storage?.S3?.defaultAccessLevel ?? constants_1.DEFAULT_ACCESS_LEVEL;\nconst validateCompletedParts = (completedParts, size) => {\n  const partsExpected = Math.ceil(size / (0, calculatePartSize_1.calculatePartSize)(size));\n  const validPartCount = completedParts.length === partsExpected;\n  const sorted = sortUploadParts(completedParts);\n  const validPartNumbers = sorted.every((part, index) => part.PartNumber === index + 1);\n  if (!validPartCount || !validPartNumbers) {\n    throw new IntegrityError_1.IntegrityError();\n  }\n};\nconst sortUploadParts = parts => {\n  return [...parts].sort((partA, partB) => partA.PartNumber - partB.PartNumber);\n};","map":{"version":3,"names":["Object","defineProperty","exports","value","getMultipartUploadHandlers","core_1","require","utils_1","utils_2","constants_1","StorageError_1","CanceledError_1","s3data_1","userAgent_1","utils_3","crc32_1","IntegrityError_1","uploadPartExecutor_1","uploadCache_1","progressTracker_1","initialUpload_1","getDataChunker_1","calculatePartSize_1","uploadDataInput","size","resolveCallback","rejectCallback","inProgressUpload","resolvedS3Config","abortController","resolvedAccessLevel","resolvedBucket","resolvedKeyPrefix","resolvedIdentityId","uploadCacheKey","finalKey","expectedBucketOwner","isAbortSignalFromPause","resumableUploadsCache","options","startUpload","uploadDataOptions","data","resolvedS3Options","resolveS3ConfigAndInput","Amplify","AbortController","s3Config","bucket","identityId","inputType","objectKey","validateStorageOperationInput","contentDisposition","contentEncoding","contentType","metadata","preventOverwrite","onProgress","STORAGE_INPUT_KEY","accessLevel","keyPrefix","resolveAccessLevel","optionsHash","calculateContentCRC32","serializeUploadOptions","uploadId","cachedParts","finalCrc32","loadOrCreateMultipartUpload","key","abortSignal","signal","checksumAlgorithm","completedParts","getUploadsCacheKey","file","File","undefined","dataChunker","getDataChunker","completedPartNumberSet","Set","map","PartNumber","onPartUploadCompletion","partNumber","eTag","crc32","push","ETag","ChecksumCRC32","concurrentUploadsProgressTracker","getConcurrentUploadsProgressTracker","concurrentUploadPartExecutors","index","DEFAULT_QUEUE_SIZE","uploadPartExecutor","dataChunkerGenerator","getOnProgressListener","isObjectLockEnabled","useCRC32Checksum","Boolean","Promise","all","validateCompletedParts","completeMultipartUpload","userAgentValue","getStorageUserAgentValue","StorageAction","UploadData","Bucket","Key","UploadId","ChecksumType","IfNoneMatch","MultipartUpload","Parts","sortUploadParts","ExpectedBucketOwner","ContentLength","uploadedObjectSize","$metadata","headObject","StorageError","name","message","removeCachedUpload","result","path","startUploadWithResumability","then","catch","error","aborted","logger","debug","multipartUploadJob","resolve","reject","onPause","abort","onResume","onCancel","cancelUpload","abortMultipartUpload","e","CanceledError","libraryOptions","Storage","S3","defaultAccessLevel","DEFAULT_ACCESS_LEVEL","partsExpected","Math","ceil","calculatePartSize","validPartCount","length","sorted","validPartNumbers","every","part","IntegrityError","parts","sort","partA","partB"],"sources":["C:\\Users\\vinzl\\workspace\\machicoulis\\daily-image-collector\\node_modules\\@aws-amplify\\storage\\src\\providers\\s3\\apis\\internal\\uploadData\\multipart\\uploadHandlers.ts"],"sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getMultipartUploadHandlers = void 0;\nconst core_1 = require(\"@aws-amplify/core\");\nconst utils_1 = require(\"@aws-amplify/core/internals/utils\");\nconst utils_2 = require(\"../../../../utils\");\nconst constants_1 = require(\"../../../../utils/constants\");\nconst StorageError_1 = require(\"../../../../../../errors/StorageError\");\nconst CanceledError_1 = require(\"../../../../../../errors/CanceledError\");\nconst s3data_1 = require(\"../../../../utils/client/s3data\");\nconst userAgent_1 = require(\"../../../../utils/userAgent\");\nconst utils_3 = require(\"../../../../../../utils\");\nconst crc32_1 = require(\"../../../../utils/crc32\");\nconst IntegrityError_1 = require(\"../../../../../../errors/IntegrityError\");\nconst uploadPartExecutor_1 = require(\"./uploadPartExecutor\");\nconst uploadCache_1 = require(\"./uploadCache\");\nconst progressTracker_1 = require(\"./progressTracker\");\nconst initialUpload_1 = require(\"./initialUpload\");\nconst getDataChunker_1 = require(\"./getDataChunker\");\nconst calculatePartSize_1 = require(\"./calculatePartSize\");\n/**\n * Create closure hiding the multipart upload implementation details and expose the upload job and control functions(\n * onPause, onResume, onCancel).\n *\n * @internal\n */\nconst getMultipartUploadHandlers = (uploadDataInput, size) => {\n    let resolveCallback;\n    let rejectCallback;\n    let inProgressUpload;\n    let resolvedS3Config;\n    let abortController;\n    let resolvedAccessLevel;\n    let resolvedBucket;\n    let resolvedKeyPrefix;\n    let resolvedIdentityId;\n    let uploadCacheKey;\n    let finalKey;\n    let expectedBucketOwner;\n    // Special flag that differentiates HTTP requests abort error caused by pause() from ones caused by cancel().\n    // The former one should NOT cause the upload job to throw, but cancels any pending HTTP requests.\n    // This should be replaced by a special abort reason. However,the support of this API is lagged behind.\n    let isAbortSignalFromPause = false;\n    const { resumableUploadsCache } = uploadDataInput.options ?? {};\n    const startUpload = async () => {\n        const { options: uploadDataOptions, data } = uploadDataInput;\n        const resolvedS3Options = await (0, utils_2.resolveS3ConfigAndInput)(core_1.Amplify, uploadDataInput);\n        abortController = new AbortController();\n        isAbortSignalFromPause = false;\n        resolvedS3Config = resolvedS3Options.s3Config;\n        resolvedBucket = resolvedS3Options.bucket;\n        resolvedIdentityId = resolvedS3Options.identityId;\n        expectedBucketOwner = uploadDataOptions?.expectedBucketOwner;\n        const { inputType, objectKey } = (0, utils_2.validateStorageOperationInput)(uploadDataInput, resolvedIdentityId);\n        const { contentDisposition, contentEncoding, contentType = 'application/octet-stream', metadata, preventOverwrite, onProgress, } = uploadDataOptions ?? {};\n        finalKey = objectKey;\n        // Resolve \"key\" specific options\n        if (inputType === constants_1.STORAGE_INPUT_KEY) {\n            const accessLevel = uploadDataOptions\n                ?.accessLevel;\n            resolvedKeyPrefix = resolvedS3Options.keyPrefix;\n            finalKey = resolvedKeyPrefix + objectKey;\n            resolvedAccessLevel = resolveAccessLevel(accessLevel);\n        }\n        const optionsHash = await (0, crc32_1.calculateContentCRC32)((0, uploadCache_1.serializeUploadOptions)(uploadDataOptions));\n        if (!inProgressUpload) {\n            const { uploadId, cachedParts, finalCrc32 } = await (0, initialUpload_1.loadOrCreateMultipartUpload)({\n                s3Config: resolvedS3Config,\n                accessLevel: resolvedAccessLevel,\n                bucket: resolvedBucket,\n                keyPrefix: resolvedKeyPrefix,\n                key: objectKey,\n                contentType,\n                contentDisposition,\n                contentEncoding,\n                metadata,\n                data,\n                size,\n                abortSignal: abortController.signal,\n                checksumAlgorithm: uploadDataOptions?.checksumAlgorithm,\n                optionsHash,\n                resumableUploadsCache,\n                expectedBucketOwner,\n            });\n            inProgressUpload = {\n                uploadId,\n                completedParts: cachedParts,\n                finalCrc32,\n            };\n        }\n        uploadCacheKey = size\n            ? (0, uploadCache_1.getUploadsCacheKey)({\n                file: data instanceof File ? data : undefined,\n                accessLevel: resolvedAccessLevel,\n                contentType: uploadDataOptions?.contentType,\n                bucket: resolvedBucket,\n                size,\n                key: objectKey,\n                optionsHash,\n            })\n            : undefined;\n        const dataChunker = (0, getDataChunker_1.getDataChunker)(data, size);\n        const completedPartNumberSet = new Set(inProgressUpload.completedParts.map(({ PartNumber }) => PartNumber));\n        const onPartUploadCompletion = (partNumber, eTag, crc32) => {\n            inProgressUpload?.completedParts.push({\n                PartNumber: partNumber,\n                ETag: eTag,\n                // TODO: crc32 can always be added once RN also has an implementation\n                ...(crc32 ? { ChecksumCRC32: crc32 } : {}),\n            });\n        };\n        const concurrentUploadsProgressTracker = (0, progressTracker_1.getConcurrentUploadsProgressTracker)({\n            size,\n            onProgress,\n        });\n        const concurrentUploadPartExecutors = [];\n        for (let index = 0; index < constants_1.DEFAULT_QUEUE_SIZE; index++) {\n            concurrentUploadPartExecutors.push((0, uploadPartExecutor_1.uploadPartExecutor)({\n                dataChunkerGenerator: dataChunker,\n                completedPartNumberSet,\n                s3Config: resolvedS3Config,\n                abortSignal: abortController.signal,\n                bucket: resolvedBucket,\n                finalKey,\n                uploadId: inProgressUpload.uploadId,\n                onPartUploadCompletion,\n                onProgress: concurrentUploadsProgressTracker.getOnProgressListener(),\n                isObjectLockEnabled: resolvedS3Options.isObjectLockEnabled,\n                useCRC32Checksum: Boolean(inProgressUpload.finalCrc32),\n                expectedBucketOwner,\n            }));\n        }\n        await Promise.all(concurrentUploadPartExecutors);\n        validateCompletedParts(inProgressUpload.completedParts, size);\n        const { ETag: eTag } = await (0, s3data_1.completeMultipartUpload)({\n            ...resolvedS3Config,\n            abortSignal: abortController.signal,\n            userAgentValue: (0, userAgent_1.getStorageUserAgentValue)(utils_1.StorageAction.UploadData),\n        }, {\n            Bucket: resolvedBucket,\n            Key: finalKey,\n            UploadId: inProgressUpload.uploadId,\n            ChecksumCRC32: inProgressUpload.finalCrc32,\n            ChecksumType: inProgressUpload.finalCrc32 ? 'FULL_OBJECT' : undefined,\n            IfNoneMatch: preventOverwrite ? '*' : undefined,\n            MultipartUpload: {\n                Parts: sortUploadParts(inProgressUpload.completedParts),\n            },\n            ExpectedBucketOwner: expectedBucketOwner,\n        });\n        // If full-object CRC32 checksum is NOT enabled, we need to ensure the upload integrity by making extra HEAD call\n        // to verify the uploaded object size.\n        if (!inProgressUpload.finalCrc32) {\n            const { ContentLength: uploadedObjectSize, $metadata } = await (0, s3data_1.headObject)(resolvedS3Config, {\n                Bucket: resolvedBucket,\n                Key: finalKey,\n                ExpectedBucketOwner: expectedBucketOwner,\n            });\n            if (uploadedObjectSize && uploadedObjectSize !== size) {\n                throw new StorageError_1.StorageError({\n                    name: 'Error',\n                    message: `Upload failed. Expected object size ${size}, but got ${uploadedObjectSize}.`,\n                    metadata: $metadata,\n                });\n            }\n        }\n        if (resumableUploadsCache && uploadCacheKey) {\n            await (0, uploadCache_1.removeCachedUpload)(resumableUploadsCache, uploadCacheKey);\n        }\n        const result = {\n            eTag,\n            contentType,\n            metadata,\n        };\n        return inputType === constants_1.STORAGE_INPUT_KEY\n            ? { key: objectKey, ...result }\n            : { path: objectKey, ...result };\n    };\n    const startUploadWithResumability = () => startUpload()\n        .then(resolveCallback)\n        .catch(error => {\n        const abortSignal = abortController?.signal;\n        if (abortSignal?.aborted && isAbortSignalFromPause) {\n            utils_3.logger.debug('upload paused.');\n        }\n        else {\n            // Uncaught errors should be exposed to the users.\n            rejectCallback(error);\n        }\n    });\n    const multipartUploadJob = () => new Promise((resolve, reject) => {\n        resolveCallback = resolve;\n        rejectCallback = reject;\n        startUploadWithResumability();\n    });\n    const onPause = () => {\n        isAbortSignalFromPause = true;\n        abortController?.abort();\n    };\n    const onResume = () => {\n        startUploadWithResumability();\n    };\n    const onCancel = (message) => {\n        // 1. abort in-flight API requests\n        abortController?.abort(message);\n        const cancelUpload = async () => {\n            // 2. clear upload cache.\n            if (uploadCacheKey && resumableUploadsCache) {\n                await (0, uploadCache_1.removeCachedUpload)(resumableUploadsCache, uploadCacheKey);\n            }\n            // 3. clear multipart upload on server side.\n            await (0, s3data_1.abortMultipartUpload)(resolvedS3Config, {\n                Bucket: resolvedBucket,\n                Key: finalKey,\n                UploadId: inProgressUpload?.uploadId,\n                ExpectedBucketOwner: expectedBucketOwner,\n            });\n        };\n        cancelUpload().catch(e => {\n            utils_3.logger.debug('error when cancelling upload task.', e);\n        });\n        rejectCallback(\n        // Internal error that should not be exposed to the users. They should use isCancelError() to check if\n        // the error is caused by cancel().\n        new CanceledError_1.CanceledError(message ? { message } : undefined));\n    };\n    return {\n        multipartUploadJob,\n        onPause,\n        onResume,\n        onCancel,\n    };\n};\nexports.getMultipartUploadHandlers = getMultipartUploadHandlers;\nconst resolveAccessLevel = (accessLevel) => accessLevel ??\n    core_1.Amplify.libraryOptions.Storage?.S3?.defaultAccessLevel ??\n    constants_1.DEFAULT_ACCESS_LEVEL;\nconst validateCompletedParts = (completedParts, size) => {\n    const partsExpected = Math.ceil(size / (0, calculatePartSize_1.calculatePartSize)(size));\n    const validPartCount = completedParts.length === partsExpected;\n    const sorted = sortUploadParts(completedParts);\n    const validPartNumbers = sorted.every((part, index) => part.PartNumber === index + 1);\n    if (!validPartCount || !validPartNumbers) {\n        throw new IntegrityError_1.IntegrityError();\n    }\n};\nconst sortUploadParts = (parts) => {\n    return [...parts].sort((partA, partB) => partA.PartNumber - partB.PartNumber);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}