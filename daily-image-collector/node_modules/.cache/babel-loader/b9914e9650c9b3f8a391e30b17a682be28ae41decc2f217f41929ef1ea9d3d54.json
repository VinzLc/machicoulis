{"ast":null,"code":"'use strict';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.deserializeCompletedPartList = exports.buildStorageServiceError = exports.deserializeMetadata = exports.emptyArrayGuard = exports.deserializeStringTag = exports.createStringEnumDeserializer = exports.deserializeTimestamp = exports.deserializeBoolean = exports.deserializeNumber = exports.map = void 0;\nconst StorageError_1 = require(\"../../../../../errors/StorageError\");\n/**\n * Maps an object to a new object using the provided instructions.\n * The instructions are a map of the returning mapped object's property names to a single instruction of how to map the\n * value from the original object to the new object. There are two types of instructions:\n *\n * 1. A string representing the property name of the original object to map to the new object. The value mapped from\n * the original object will be the same as the value in the new object, and it can ONLY be string.\n *\n * 2. An array of two elements. The first element is the property name of the original object to map to the new object.\n * The second element is a function that takes the value from the original object and returns the value to be mapped to\n * the new object. The function can return any type.\n *\n * Example:\n * ```typescript\n * const input = {\n *   Foo: 'foo',\n *   BarList: [{value: 'bar1'}, {value: 'bar2'}]\n * }\n * const output = map(input, {\n *   someFoo: 'Foo',\n *   bar: ['BarList', (barList) => barList.map(bar => bar.value)]\n *   baz: 'Baz' // Baz does not exist in input, so it will not be in the output.\n * });\n * // output = { someFoo: 'foo', bar: ['bar1', 'bar2'] }\n * ```\n *\n * @param obj The object containing the data to compose mapped object.\n * @param instructions The instructions mapping the object values to the new object.\n * @returns A new object with the mapped values.\n *\n * @internal\n */\nconst map = (obj, instructions) => {\n  const result = {};\n  for (const [key, instruction] of Object.entries(instructions)) {\n    const [accessor, deserializer] = Array.isArray(instruction) ? instruction : [instruction];\n    if (Object.prototype.hasOwnProperty.call(obj, accessor)) {\n      result[key] = deserializer ? deserializer(obj[accessor]) : String(obj[accessor]);\n    }\n  }\n  return result;\n};\nexports.map = map;\n/**\n * Deserializes a string to a number. Returns undefined if input is undefined.\n *\n * @internal\n */\nconst deserializeNumber = value => value ? Number(value) : undefined;\nexports.deserializeNumber = deserializeNumber;\n/**\n * Deserializes a string to a boolean. Returns undefined if input is undefined. Returns true if input is 'true',\n * otherwise false.\n *\n * @internal\n */\nconst deserializeBoolean = value => {\n  return value ? value === 'true' : undefined;\n};\nexports.deserializeBoolean = deserializeBoolean;\n/**\n * Deserializes a string to a Date. Returns undefined if input is undefined.\n * It supports epoch timestamp; rfc3339(cannot have a UTC, fractional precision supported); rfc7231(section 7.1.1.1)\n *\n * @see https://www.epoch101.com/\n * @see https://datatracker.ietf.org/doc/html/rfc3339.html#section-5.6\n * @see https://datatracker.ietf.org/doc/html/rfc7231.html#section-7.1.1.1\n *\n * @note For bundle size consideration, we use Date constructor to parse the timestamp string. There might be slight\n * difference among browsers.\n *\n * @internal\n */\nconst deserializeTimestamp = value => {\n  return value ? new Date(value) : undefined;\n};\nexports.deserializeTimestamp = deserializeTimestamp;\n/**\n * Create a function deserializing a string to an enum value. If the string is not a valid enum value, it throws a\n * StorageError.\n *\n * This utility is ONLY preferred if the enum value is critical. Since the enum values are hard-coded, new enum values\n * returned from service would break the library.\n *\n * @example\n * ```typescript\n * const deserializeStringEnum = createStringEnumDeserializer(['a', 'b', 'c'] as const, 'FieldName');\n * const deserializedArray = ['a', 'b', 'c'].map(deserializeStringEnum);\n * // deserializedArray = ['a', 'b', 'c']\n *\n * const invalidValue = deserializeStringEnum('d');\n * // Throws InvalidFieldName: Invalid FieldName: d\n * ```\n *\n * @internal\n */\nconst createStringEnumDeserializer = (enumValues, fieldName) => {\n  const deserializeStringEnum = value => {\n    const parsedEnumValue = value ? enumValues.find(enumValue => enumValue === value) : undefined;\n    if (!parsedEnumValue) {\n      throw new StorageError_1.StorageError({\n        name: `Invalid${fieldName}`,\n        message: `Invalid ${fieldName}: ${value}`,\n        recoverySuggestion: 'This is likely to be a bug. Please reach out to library authors.'\n      });\n    }\n    return parsedEnumValue;\n  };\n  return deserializeStringEnum;\n};\nexports.createStringEnumDeserializer = createStringEnumDeserializer;\n/**\n * Deserializes a string to a string tag type. The function simply casts the parsed string into a given string tag type.\n * It does NOT validate the string value against the string tag. This behavior is the same to AWS SDK parsing logic of\n * string tag types.\n *\n * If you need to verify the string value, you must use {@link createStringEnumDeserializer} instead.\n *\n * @internal\n */\nconst deserializeStringTag = value => String(value);\nexports.deserializeStringTag = deserializeStringTag;\n/**\n * Function that makes sure the deserializer receives non-empty array.\n *\n * @internal\n */\nconst emptyArrayGuard = (value, deserializer) => {\n  if (value === '') {\n    return [];\n  }\n  const valueArray = (Array.isArray(value) ? value : [value]).filter(e => e != null);\n  return deserializer(valueArray);\n};\nexports.emptyArrayGuard = emptyArrayGuard;\n/**\n * @internal\n */\nconst deserializeMetadata = headers => {\n  const objectMetadataHeaderPrefix = 'x-amz-meta-';\n  const deserialized = Object.keys(headers).filter(header => header.startsWith(objectMetadataHeaderPrefix)).reduce((acc, header) => {\n    acc[header.replace(objectMetadataHeaderPrefix, '')] = headers[header];\n    return acc;\n  }, {});\n  return Object.keys(deserialized).length > 0 ? deserialized : undefined;\n};\nexports.deserializeMetadata = deserializeMetadata;\n/**\n * Internal-only method to create a new StorageError from a service error with AWS SDK-compatible interfaces\n * @param error - The output of a service error parser, with AWS SDK-compatible interface(e.g. $metadata)\n * @returns A new StorageError.\n *\n * @internal\n */\nconst buildStorageServiceError = error => new StorageError_1.StorageError({\n  name: error.name,\n  message: error.message,\n  metadata: error.$metadata\n});\nexports.buildStorageServiceError = buildStorageServiceError;\n/**\n * Internal-only method used for deserializing the parts of a multipart upload.\n *\n * @internal\n */\nconst deserializeCompletedPartList = input => input.map(item => (0, exports.map)(item, {\n  PartNumber: ['PartNumber', exports.deserializeNumber],\n  ETag: 'ETag',\n  ChecksumCRC32: 'ChecksumCRC32'\n}));\nexports.deserializeCompletedPartList = deserializeCompletedPartList;","map":{"version":3,"names":["Object","defineProperty","exports","value","deserializeCompletedPartList","buildStorageServiceError","deserializeMetadata","emptyArrayGuard","deserializeStringTag","createStringEnumDeserializer","deserializeTimestamp","deserializeBoolean","deserializeNumber","map","StorageError_1","require","obj","instructions","result","key","instruction","entries","accessor","deserializer","Array","isArray","prototype","hasOwnProperty","call","String","Number","undefined","Date","enumValues","fieldName","deserializeStringEnum","parsedEnumValue","find","enumValue","StorageError","name","message","recoverySuggestion","valueArray","filter","e","headers","objectMetadataHeaderPrefix","deserialized","keys","header","startsWith","reduce","acc","replace","length","error","metadata","$metadata","input","item","PartNumber","ETag","ChecksumCRC32"],"sources":["C:\\Users\\vinzl\\workspace\\machicoulis\\daily-image-collector\\node_modules\\@aws-amplify\\storage\\src\\providers\\s3\\utils\\client\\utils\\deserializeHelpers.ts"],"sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deserializeCompletedPartList = exports.buildStorageServiceError = exports.deserializeMetadata = exports.emptyArrayGuard = exports.deserializeStringTag = exports.createStringEnumDeserializer = exports.deserializeTimestamp = exports.deserializeBoolean = exports.deserializeNumber = exports.map = void 0;\nconst StorageError_1 = require(\"../../../../../errors/StorageError\");\n/**\n * Maps an object to a new object using the provided instructions.\n * The instructions are a map of the returning mapped object's property names to a single instruction of how to map the\n * value from the original object to the new object. There are two types of instructions:\n *\n * 1. A string representing the property name of the original object to map to the new object. The value mapped from\n * the original object will be the same as the value in the new object, and it can ONLY be string.\n *\n * 2. An array of two elements. The first element is the property name of the original object to map to the new object.\n * The second element is a function that takes the value from the original object and returns the value to be mapped to\n * the new object. The function can return any type.\n *\n * Example:\n * ```typescript\n * const input = {\n *   Foo: 'foo',\n *   BarList: [{value: 'bar1'}, {value: 'bar2'}]\n * }\n * const output = map(input, {\n *   someFoo: 'Foo',\n *   bar: ['BarList', (barList) => barList.map(bar => bar.value)]\n *   baz: 'Baz' // Baz does not exist in input, so it will not be in the output.\n * });\n * // output = { someFoo: 'foo', bar: ['bar1', 'bar2'] }\n * ```\n *\n * @param obj The object containing the data to compose mapped object.\n * @param instructions The instructions mapping the object values to the new object.\n * @returns A new object with the mapped values.\n *\n * @internal\n */\nconst map = (obj, instructions) => {\n    const result = {};\n    for (const [key, instruction] of Object.entries(instructions)) {\n        const [accessor, deserializer] = Array.isArray(instruction)\n            ? instruction\n            : [instruction];\n        if (Object.prototype.hasOwnProperty.call(obj, accessor)) {\n            result[key] = deserializer\n                ? deserializer(obj[accessor])\n                : String(obj[accessor]);\n        }\n    }\n    return result;\n};\nexports.map = map;\n/**\n * Deserializes a string to a number. Returns undefined if input is undefined.\n *\n * @internal\n */\nconst deserializeNumber = (value) => value ? Number(value) : undefined;\nexports.deserializeNumber = deserializeNumber;\n/**\n * Deserializes a string to a boolean. Returns undefined if input is undefined. Returns true if input is 'true',\n * otherwise false.\n *\n * @internal\n */\nconst deserializeBoolean = (value) => {\n    return value ? value === 'true' : undefined;\n};\nexports.deserializeBoolean = deserializeBoolean;\n/**\n * Deserializes a string to a Date. Returns undefined if input is undefined.\n * It supports epoch timestamp; rfc3339(cannot have a UTC, fractional precision supported); rfc7231(section 7.1.1.1)\n *\n * @see https://www.epoch101.com/\n * @see https://datatracker.ietf.org/doc/html/rfc3339.html#section-5.6\n * @see https://datatracker.ietf.org/doc/html/rfc7231.html#section-7.1.1.1\n *\n * @note For bundle size consideration, we use Date constructor to parse the timestamp string. There might be slight\n * difference among browsers.\n *\n * @internal\n */\nconst deserializeTimestamp = (value) => {\n    return value ? new Date(value) : undefined;\n};\nexports.deserializeTimestamp = deserializeTimestamp;\n/**\n * Create a function deserializing a string to an enum value. If the string is not a valid enum value, it throws a\n * StorageError.\n *\n * This utility is ONLY preferred if the enum value is critical. Since the enum values are hard-coded, new enum values\n * returned from service would break the library.\n *\n * @example\n * ```typescript\n * const deserializeStringEnum = createStringEnumDeserializer(['a', 'b', 'c'] as const, 'FieldName');\n * const deserializedArray = ['a', 'b', 'c'].map(deserializeStringEnum);\n * // deserializedArray = ['a', 'b', 'c']\n *\n * const invalidValue = deserializeStringEnum('d');\n * // Throws InvalidFieldName: Invalid FieldName: d\n * ```\n *\n * @internal\n */\nconst createStringEnumDeserializer = (enumValues, fieldName) => {\n    const deserializeStringEnum = (value) => {\n        const parsedEnumValue = value\n            ? enumValues.find(enumValue => enumValue === value)\n            : undefined;\n        if (!parsedEnumValue) {\n            throw new StorageError_1.StorageError({\n                name: `Invalid${fieldName}`,\n                message: `Invalid ${fieldName}: ${value}`,\n                recoverySuggestion: 'This is likely to be a bug. Please reach out to library authors.',\n            });\n        }\n        return parsedEnumValue;\n    };\n    return deserializeStringEnum;\n};\nexports.createStringEnumDeserializer = createStringEnumDeserializer;\n/**\n * Deserializes a string to a string tag type. The function simply casts the parsed string into a given string tag type.\n * It does NOT validate the string value against the string tag. This behavior is the same to AWS SDK parsing logic of\n * string tag types.\n *\n * If you need to verify the string value, you must use {@link createStringEnumDeserializer} instead.\n *\n * @internal\n */\nconst deserializeStringTag = (value) => String(value);\nexports.deserializeStringTag = deserializeStringTag;\n/**\n * Function that makes sure the deserializer receives non-empty array.\n *\n * @internal\n */\nconst emptyArrayGuard = (value, deserializer) => {\n    if (value === '') {\n        return [];\n    }\n    const valueArray = (Array.isArray(value) ? value : [value]).filter(e => e != null);\n    return deserializer(valueArray);\n};\nexports.emptyArrayGuard = emptyArrayGuard;\n/**\n * @internal\n */\nconst deserializeMetadata = (headers) => {\n    const objectMetadataHeaderPrefix = 'x-amz-meta-';\n    const deserialized = Object.keys(headers)\n        .filter(header => header.startsWith(objectMetadataHeaderPrefix))\n        .reduce((acc, header) => {\n        acc[header.replace(objectMetadataHeaderPrefix, '')] = headers[header];\n        return acc;\n    }, {});\n    return Object.keys(deserialized).length > 0 ? deserialized : undefined;\n};\nexports.deserializeMetadata = deserializeMetadata;\n/**\n * Internal-only method to create a new StorageError from a service error with AWS SDK-compatible interfaces\n * @param error - The output of a service error parser, with AWS SDK-compatible interface(e.g. $metadata)\n * @returns A new StorageError.\n *\n * @internal\n */\nconst buildStorageServiceError = (error) => new StorageError_1.StorageError({\n    name: error.name,\n    message: error.message,\n    metadata: error.$metadata,\n});\nexports.buildStorageServiceError = buildStorageServiceError;\n/**\n * Internal-only method used for deserializing the parts of a multipart upload.\n *\n * @internal\n */\nconst deserializeCompletedPartList = (input) => input.map(item => (0, exports.map)(item, {\n    PartNumber: ['PartNumber', exports.deserializeNumber],\n    ETag: 'ETag',\n    ChecksumCRC32: 'ChecksumCRC32',\n}));\nexports.deserializeCompletedPartList = deserializeCompletedPartList;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}