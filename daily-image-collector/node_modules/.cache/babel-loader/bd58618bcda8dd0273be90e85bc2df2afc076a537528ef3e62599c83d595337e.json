{"ast":null,"code":"import '../../../../utils/client/s3data/base.mjs';\nimport '../../../../utils/client/s3data/getObject.mjs';\nimport '../../../../utils/client/s3data/listObjectsV2.mjs';\nimport '../../../../utils/client/s3data/putObject.mjs';\nimport { createMultipartUpload } from '../../../../utils/client/s3data/createMultipartUpload.mjs';\nimport '../../../../utils/client/s3data/uploadPart.mjs';\nimport '../../../../utils/client/s3data/completeMultipartUpload.mjs';\nimport '../../../../utils/client/s3data/listParts.mjs';\nimport '../../../../utils/client/s3data/abortMultipartUpload.mjs';\nimport '../../../../utils/client/s3data/copyObject.mjs';\nimport '../../../../utils/client/s3data/headObject.mjs';\nimport '../../../../utils/client/s3data/deleteObject.mjs';\nimport '../../../../../../errors/types/validation.mjs';\nimport '@aws-amplify/core/internals/utils';\nimport { logger } from '../../../../../../utils/logger.mjs';\nimport { constructContentDisposition } from '../../../../utils/constructContentDisposition.mjs';\nimport { CHECKSUM_ALGORITHM_CRC32 } from '../../../../utils/constants.mjs';\nimport { calculateContentCRC32 } from '../../../../utils/crc32.mjs';\nimport { getUploadsCacheKey, findCachedUploadPartsAndEvictExpired, cacheMultipartUpload } from './uploadCache.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n/**\n * Load the in-progress multipart upload from local storage or async storage(RN) if it exists, or create a new multipart\n * upload.\n *\n * @internal\n */\nconst loadOrCreateMultipartUpload = async ({\n  s3Config,\n  data,\n  size,\n  contentType,\n  bucket,\n  accessLevel,\n  keyPrefix,\n  key,\n  contentDisposition,\n  contentEncoding,\n  metadata,\n  abortSignal,\n  checksumAlgorithm,\n  optionsHash,\n  resumableUploadsCache,\n  expectedBucketOwner\n}) => {\n  const finalKey = keyPrefix !== undefined ? keyPrefix + key : key;\n  let cachedUpload;\n  if (!resumableUploadsCache) {\n    logger.debug('uploaded cache instance cannot be determined, skipping cache.');\n    cachedUpload = undefined;\n  } else {\n    const uploadCacheKey = getUploadsCacheKey({\n      size,\n      contentType,\n      file: data instanceof File ? data : undefined,\n      bucket,\n      accessLevel,\n      key,\n      optionsHash\n    });\n    const cachedUploadParts = await findCachedUploadPartsAndEvictExpired({\n      s3Config,\n      cacheKey: uploadCacheKey,\n      bucket,\n      finalKey,\n      resumableUploadsCache\n    });\n    cachedUpload = cachedUploadParts ? {\n      ...cachedUploadParts,\n      uploadCacheKey\n    } : undefined;\n  }\n  if (cachedUpload) {\n    return {\n      uploadId: cachedUpload.uploadId,\n      cachedParts: cachedUpload.parts,\n      finalCrc32: cachedUpload.finalCrc32\n    };\n  } else {\n    /**\n     * Note: This step reads the uploading file from beginning to end to calculate the CRC32 checksum of the entire\n     * object before sending the 1st byte over the wire. This is a performance bottleneck when uploading large files.\n     * The rationale to do this is S3 team wants to reduce the possibility of a file getting corrupted(on disk or in\n     * memory). So we calculate the full-object checksum as soon as possible in the upload flow.\n     *\n     * Going forward we should re-evaluate this decision with S3 team. The alternative is calling calculateContentCRC32()\n     * as we upload each part sequentially with seeds from already uploaded parts, ideally inside the data chunker.\n     */\n    const finalCrc32 = checksumAlgorithm === CHECKSUM_ALGORITHM_CRC32 ? await calculateContentCRC32(data) : undefined;\n    const {\n      UploadId\n    } = await createMultipartUpload({\n      ...s3Config,\n      abortSignal\n    }, {\n      Bucket: bucket,\n      Key: finalKey,\n      ContentType: contentType,\n      ContentDisposition: constructContentDisposition(contentDisposition),\n      ContentEncoding: contentEncoding,\n      Metadata: metadata,\n      ChecksumAlgorithm: finalCrc32 ? 'CRC32' : undefined,\n      ChecksumType: finalCrc32 ? 'FULL_OBJECT' : undefined,\n      ExpectedBucketOwner: expectedBucketOwner\n    });\n    if (resumableUploadsCache) {\n      const uploadCacheKey = getUploadsCacheKey({\n        size,\n        contentType,\n        file: data instanceof File ? data : undefined,\n        bucket,\n        accessLevel,\n        key,\n        optionsHash\n      });\n      await cacheMultipartUpload(resumableUploadsCache, uploadCacheKey, {\n        uploadId: UploadId,\n        bucket,\n        key,\n        finalCrc32,\n        fileName: data instanceof File ? data.name : ''\n      });\n    }\n    return {\n      uploadId: UploadId,\n      cachedParts: [],\n      finalCrc32\n    };\n  }\n};\nexport { loadOrCreateMultipartUpload };","map":{"version":3,"names":["loadOrCreateMultipartUpload","s3Config","data","size","contentType","bucket","accessLevel","keyPrefix","key","contentDisposition","contentEncoding","metadata","abortSignal","checksumAlgorithm","optionsHash","resumableUploadsCache","expectedBucketOwner","finalKey","undefined","cachedUpload","logger","debug","uploadCacheKey","getUploadsCacheKey","file","File","cachedUploadParts","findCachedUploadPartsAndEvictExpired","cacheKey","uploadId","cachedParts","parts","finalCrc32","CHECKSUM_ALGORITHM_CRC32","calculateContentCRC32","UploadId","createMultipartUpload","Bucket","Key","ContentType","ContentDisposition","constructContentDisposition","ContentEncoding","Metadata","ChecksumAlgorithm","ChecksumType","ExpectedBucketOwner","cacheMultipartUpload","fileName","name"],"sources":["C:\\Users\\vinzl\\workspace\\machicoulis\\daily-image-collector\\node_modules\\@aws-amplify\\storage\\src\\providers\\s3\\apis\\internal\\uploadData\\multipart\\initialUpload.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { createMultipartUpload } from '../../../../utils/client/s3data';\nimport { logger } from '../../../../../../utils';\nimport { constructContentDisposition } from '../../../../utils/constructContentDisposition';\nimport { CHECKSUM_ALGORITHM_CRC32 } from '../../../../utils/constants';\nimport { calculateContentCRC32 } from '../../../../utils/crc32';\nimport { cacheMultipartUpload, findCachedUploadPartsAndEvictExpired, getUploadsCacheKey, } from './uploadCache';\n/**\n * Load the in-progress multipart upload from local storage or async storage(RN) if it exists, or create a new multipart\n * upload.\n *\n * @internal\n */\nexport const loadOrCreateMultipartUpload = async ({ s3Config, data, size, contentType, bucket, accessLevel, keyPrefix, key, contentDisposition, contentEncoding, metadata, abortSignal, checksumAlgorithm, optionsHash, resumableUploadsCache, expectedBucketOwner, }) => {\n    const finalKey = keyPrefix !== undefined ? keyPrefix + key : key;\n    let cachedUpload;\n    if (!resumableUploadsCache) {\n        logger.debug('uploaded cache instance cannot be determined, skipping cache.');\n        cachedUpload = undefined;\n    }\n    else {\n        const uploadCacheKey = getUploadsCacheKey({\n            size,\n            contentType,\n            file: data instanceof File ? data : undefined,\n            bucket,\n            accessLevel,\n            key,\n            optionsHash,\n        });\n        const cachedUploadParts = await findCachedUploadPartsAndEvictExpired({\n            s3Config,\n            cacheKey: uploadCacheKey,\n            bucket,\n            finalKey,\n            resumableUploadsCache,\n        });\n        cachedUpload = cachedUploadParts\n            ? { ...cachedUploadParts, uploadCacheKey }\n            : undefined;\n    }\n    if (cachedUpload) {\n        return {\n            uploadId: cachedUpload.uploadId,\n            cachedParts: cachedUpload.parts,\n            finalCrc32: cachedUpload.finalCrc32,\n        };\n    }\n    else {\n        /**\n         * Note: This step reads the uploading file from beginning to end to calculate the CRC32 checksum of the entire\n         * object before sending the 1st byte over the wire. This is a performance bottleneck when uploading large files.\n         * The rationale to do this is S3 team wants to reduce the possibility of a file getting corrupted(on disk or in\n         * memory). So we calculate the full-object checksum as soon as possible in the upload flow.\n         *\n         * Going forward we should re-evaluate this decision with S3 team. The alternative is calling calculateContentCRC32()\n         * as we upload each part sequentially with seeds from already uploaded parts, ideally inside the data chunker.\n         */\n        const finalCrc32 = checksumAlgorithm === CHECKSUM_ALGORITHM_CRC32\n            ? await calculateContentCRC32(data)\n            : undefined;\n        const { UploadId } = await createMultipartUpload({\n            ...s3Config,\n            abortSignal,\n        }, {\n            Bucket: bucket,\n            Key: finalKey,\n            ContentType: contentType,\n            ContentDisposition: constructContentDisposition(contentDisposition),\n            ContentEncoding: contentEncoding,\n            Metadata: metadata,\n            ChecksumAlgorithm: finalCrc32 ? 'CRC32' : undefined,\n            ChecksumType: finalCrc32 ? 'FULL_OBJECT' : undefined,\n            ExpectedBucketOwner: expectedBucketOwner,\n        });\n        if (resumableUploadsCache) {\n            const uploadCacheKey = getUploadsCacheKey({\n                size,\n                contentType,\n                file: data instanceof File ? data : undefined,\n                bucket,\n                accessLevel,\n                key,\n                optionsHash,\n            });\n            await cacheMultipartUpload(resumableUploadsCache, uploadCacheKey, {\n                uploadId: UploadId,\n                bucket,\n                key,\n                finalCrc32,\n                fileName: data instanceof File ? data.name : '',\n            });\n        }\n        return {\n            uploadId: UploadId,\n            cachedParts: [],\n            finalCrc32,\n        };\n    }\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACY,MAACA,2BAA2B,GAAG,MAAAA,CAAO;EAAEC,QAAQ;EAAEC,IAAI;EAAEC,IAAI;EAAEC,WAAW;EAAEC,MAAM;EAAEC,WAAW;EAAEC,SAAS;EAAEC,GAAG;EAAEC,kBAAkB;EAAEC,eAAe;EAAEC,QAAQ;EAAEC,WAAW;EAAEC,iBAAiB;EAAEC,WAAW;EAAEC,qBAAqB;EAAEC;AAAmB,CAAG,KAAK;EACtQ,MAAMC,QAAQ,GAAGV,SAAS,KAAKW,SAAS,GAAGX,SAAS,GAAGC,GAAG,GAAGA,GAAG;EAChE,IAAIW,YAAY;EAChB,IAAI,CAACJ,qBAAqB,EAAE;IACxBK,MAAM,CAACC,KAAK,CAAC,+DAA+D,CAAC;IAC7EF,YAAY,GAAGD,SAAS;EAChC,OACS;IACD,MAAMI,cAAc,GAAGC,kBAAkB,CAAC;MACtCpB,IAAI;MACJC,WAAW;MACXoB,IAAI,EAAEtB,IAAI,YAAYuB,IAAI,GAAGvB,IAAI,GAAGgB,SAAS;MAC7Cb,MAAM;MACNC,WAAW;MACXE,GAAG;MACHM;IACZ,CAAS,CAAC;IACF,MAAMY,iBAAiB,GAAG,MAAMC,oCAAoC,CAAC;MACjE1B,QAAQ;MACR2B,QAAQ,EAAEN,cAAc;MACxBjB,MAAM;MACNY,QAAQ;MACRF;IACZ,CAAS,CAAC;IACFI,YAAY,GAAGO,iBAAA,GACT;MAAE,GAAGA,iBAAiB;MAAEJ;IAAc,IACtCJ,SAAS;EACvB;EACI,IAAIC,YAAY,EAAE;IACd,OAAO;MACHU,QAAQ,EAAEV,YAAY,CAACU,QAAQ;MAC/BC,WAAW,EAAEX,YAAY,CAACY,KAAK;MAC/BC,UAAU,EAAEb,YAAY,CAACa;IACrC,CAAS;EACT,OACS;IACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,MAAMA,UAAU,GAAGnB,iBAAiB,KAAKoB,wBAAA,GACnC,MAAMC,qBAAqB,CAAChC,IAAI,IAChCgB,SAAS;IACf,MAAM;MAAEiB;IAAQ,CAAE,GAAG,MAAMC,qBAAqB,CAAC;MAC7C,GAAGnC,QAAQ;MACXW;IACZ,CAAS,EAAE;MACCyB,MAAM,EAAEhC,MAAM;MACdiC,GAAG,EAAErB,QAAQ;MACbsB,WAAW,EAAEnC,WAAW;MACxBoC,kBAAkB,EAAEC,2BAA2B,CAAChC,kBAAkB,CAAC;MACnEiC,eAAe,EAAEhC,eAAe;MAChCiC,QAAQ,EAAEhC,QAAQ;MAClBiC,iBAAiB,EAAEZ,UAAU,GAAG,OAAO,GAAGd,SAAS;MACnD2B,YAAY,EAAEb,UAAU,GAAG,aAAa,GAAGd,SAAS;MACpD4B,mBAAmB,EAAE9B;IACjC,CAAS,CAAC;IACF,IAAID,qBAAqB,EAAE;MACvB,MAAMO,cAAc,GAAGC,kBAAkB,CAAC;QACtCpB,IAAI;QACJC,WAAW;QACXoB,IAAI,EAAEtB,IAAI,YAAYuB,IAAI,GAAGvB,IAAI,GAAGgB,SAAS;QAC7Cb,MAAM;QACNC,WAAW;QACXE,GAAG;QACHM;MAChB,CAAa,CAAC;MACF,MAAMiC,oBAAoB,CAAChC,qBAAqB,EAAEO,cAAc,EAAE;QAC9DO,QAAQ,EAAEM,QAAQ;QAClB9B,MAAM;QACNG,GAAG;QACHwB,UAAU;QACVgB,QAAQ,EAAE9C,IAAI,YAAYuB,IAAI,GAAGvB,IAAI,CAAC+C,IAAI,GAAG;MAC7D,CAAa,CAAC;IACd;IACQ,OAAO;MACHpB,QAAQ,EAAEM,QAAQ;MAClBL,WAAW,EAAE,EAAE;MACfE;IACZ,CAAS;EACT;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}