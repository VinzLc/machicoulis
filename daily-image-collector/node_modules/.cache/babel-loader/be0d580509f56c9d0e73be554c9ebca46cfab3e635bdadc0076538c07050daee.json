{"ast":null,"code":"import _objectSpread from \"C:/Users/vinzl/workspace/machicoulis/daily-image-collector/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { parse, print } from 'graphql';\nimport { catchError } from 'rxjs';\nimport { AmplifyUrl, getAmplifyUserAgent } from '@aws-amplify/core/internals/utils';\nimport { isCancelError } from '@aws-amplify/api-rest';\nimport { updateRequestToBeCancellable, cancel, post } from '@aws-amplify/api-rest/internals';\nimport { AWSAppSyncRealTimeProvider } from '../Providers/AWSAppSyncRealTimeProvider/index.mjs';\nimport { resolveConfig } from '../utils/resolveConfig.mjs';\nimport { resolveLibraryOptions } from '../utils/resolveLibraryOptions.mjs';\nimport { repackageUnauthorizedError } from '../utils/errors/repackageAuthError.mjs';\nimport { NO_ENDPOINT } from '../utils/errors/constants.mjs';\nimport { GraphQLApiError } from '../utils/errors/GraphQLApiError.mjs';\nimport '../utils/errors/validation.mjs';\nimport { createGraphQLResultWithError } from '../utils/errors/createGraphQLResultWithError.mjs';\nimport { isGraphQLResponseWithErrors } from './utils/runtimeTypeGuards/isGraphQLResponseWithErrors.mjs';\nimport { headerBasedAuth } from './graphqlAuth.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst USER_AGENT_HEADER = 'x-amz-user-agent';\nconst isAmplifyInstance = amplify => {\n  return typeof amplify !== 'function';\n};\n/**\n * Export Cloud Logic APIs\n */\nclass InternalGraphQLAPIClass {\n  constructor() {\n    /**\n     * @private\n     */\n    this.appSyncRealTime = new Map();\n    this._api = {\n      post,\n      cancelREST: cancel,\n      isCancelErrorREST: isCancelError,\n      updateRequestToBeCancellable\n    };\n  }\n  getModuleName() {\n    return 'InternalGraphQLAPI';\n  }\n  /**\n   * to get the operation type\n   * @param operation\n   */\n  getGraphqlOperationType(operation) {\n    const doc = parse(operation);\n    const definitions = doc.definitions;\n    const [{\n      operation: operationType\n    }] = definitions;\n    return operationType;\n  }\n  /**\n   * Executes a GraphQL operation\n   *\n   * @param options - GraphQL Options\n   * @param [additionalHeaders] - headers to merge in after any `libraryConfigHeaders` set in the config\n   * @returns An Observable if the query is a subscription query, else a promise of the graphql result.\n   */\n  graphql(amplify, _ref, additionalHeaders, customUserAgentDetails) {\n    let {\n      query: paramQuery,\n      variables = {},\n      authMode,\n      authToken,\n      endpoint,\n      apiKey\n    } = _ref;\n    const query = typeof paramQuery === 'string' ? parse(paramQuery) : parse(print(paramQuery));\n    const [operationDef = {}] = query.definitions.filter(def => def.kind === 'OperationDefinition');\n    const {\n      operation: operationType\n    } = operationDef;\n    const headers = additionalHeaders || {};\n    switch (operationType) {\n      case 'query':\n      case 'mutation':\n        {\n          const abortController = new AbortController();\n          let responsePromise;\n          if (isAmplifyInstance(amplify)) {\n            responsePromise = this._graphql(amplify, {\n              query,\n              variables,\n              authMode,\n              apiKey,\n              endpoint\n            }, headers, abortController, customUserAgentDetails, authToken);\n          } else {\n            // NOTE: this wrapper function must be await-able so the Amplify server context manager can\n            // destroy the context only after it completes\n            const wrapper = async amplifyInstance => {\n              const result = await this._graphql(amplifyInstance, {\n                query,\n                variables,\n                authMode,\n                apiKey,\n                endpoint\n              }, headers, abortController, customUserAgentDetails, authToken);\n              return result;\n            };\n            responsePromise = amplify(wrapper);\n          }\n          this._api.updateRequestToBeCancellable(responsePromise, abortController);\n          return responsePromise;\n        }\n      case 'subscription':\n        return this._graphqlSubscribe(amplify, {\n          query,\n          variables,\n          authMode,\n          apiKey,\n          endpoint\n        }, headers, customUserAgentDetails, authToken);\n      default:\n        throw new Error(\"invalid operation type: \".concat(operationType));\n    }\n  }\n  async _graphql(amplify, _ref2) {\n    let {\n      query,\n      variables,\n      authMode: authModeOverride,\n      endpoint: endpointOverride,\n      apiKey: apiKeyOverride\n    } = _ref2;\n    let additionalHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let abortController = arguments.length > 3 ? arguments[3] : undefined;\n    let customUserAgentDetails = arguments.length > 4 ? arguments[4] : undefined;\n    let authToken = arguments.length > 5 ? arguments[5] : undefined;\n    const {\n      apiKey,\n      region,\n      endpoint: appSyncGraphqlEndpoint,\n      customEndpoint,\n      customEndpointRegion,\n      defaultAuthMode\n    } = resolveConfig(amplify);\n    const initialAuthMode = authModeOverride || defaultAuthMode || 'iam';\n    // identityPool is an alias for iam. TODO: remove 'iam' in v7\n    const authMode = initialAuthMode === 'identityPool' ? 'iam' : initialAuthMode;\n    /**\n     * Retrieve library options from Amplify configuration.\n     * `customHeaders` here are from the Amplify configuration options,\n     * and are for non-AppSync endpoints only. These are *not* the same as\n     * `additionalHeaders`, which are custom headers that are either 1)\n     * included when configuring the API client or 2) passed along with\n     * individual requests.\n     */\n    const {\n      headers: customHeaders,\n      withCredentials\n    } = resolveLibraryOptions(amplify);\n    /**\n     * Client or request-specific custom headers that may or may not be\n     * returned by a function:\n     */\n    let additionalCustomHeaders;\n    if (typeof additionalHeaders === 'function') {\n      const requestOptions = {\n        method: 'POST',\n        url: new AmplifyUrl(endpointOverride || customEndpoint || appSyncGraphqlEndpoint || '').toString(),\n        queryString: print(query)\n      };\n      additionalCustomHeaders = await additionalHeaders(requestOptions);\n    } else {\n      additionalCustomHeaders = additionalHeaders;\n    }\n    // if an authorization header is set, have the explicit authToken take precedence\n    if (authToken) {\n      additionalCustomHeaders = _objectSpread(_objectSpread({}, additionalCustomHeaders), {}, {\n        Authorization: authToken\n      });\n    }\n    const authHeaders = await headerBasedAuth(amplify, authMode, apiKeyOverride !== null && apiKeyOverride !== void 0 ? apiKeyOverride : apiKey, additionalCustomHeaders);\n    const headers = _objectSpread(_objectSpread(_objectSpread(_objectSpread(_objectSpread({}, !customEndpoint && authHeaders), customEndpoint && (customEndpointRegion ? authHeaders : {}) || {}), customHeaders && (await customHeaders({\n      query: print(query),\n      variables\n    }))), additionalCustomHeaders), !customEndpoint && {\n      [USER_AGENT_HEADER]: getAmplifyUserAgent(customUserAgentDetails)\n    });\n    const body = {\n      query: print(query),\n      variables: variables || null\n    };\n    let signingServiceInfo;\n    /**\n     * We do not send the signing service info to the REST API under the\n     * following conditions (i.e. it will not sign the request):\n     *   - there is a custom endpoint but no region\n     *   - the auth mode is `none`, or `apiKey`\n     *   - the auth mode is a type other than the types listed below\n     */\n    if (customEndpoint && !customEndpointRegion || authMode !== 'oidc' && authMode !== 'userPool' && authMode !== 'iam' && authMode !== 'lambda') {\n      signingServiceInfo = undefined;\n    } else {\n      signingServiceInfo = {\n        service: !customEndpointRegion ? 'appsync' : 'execute-api',\n        region: !customEndpointRegion ? region : customEndpointRegion\n      };\n    }\n    const endpoint = endpointOverride || customEndpoint || appSyncGraphqlEndpoint;\n    if (!endpoint) {\n      throw createGraphQLResultWithError(new GraphQLApiError(NO_ENDPOINT));\n    }\n    let response;\n    try {\n      // \t// // See the inline doc of the REST `post()` API for possible errors to be thrown.\n      // \t// // As these errors are catastrophic they should be caught and handled by GraphQL\n      // \t// // API consumers.\n      const {\n        body: responseBody\n      } = await this._api.post(amplify, {\n        url: new AmplifyUrl(endpoint),\n        options: {\n          headers,\n          body,\n          signingServiceInfo,\n          withCredentials\n        },\n        abortController\n      });\n      response = await responseBody.json();\n    } catch (error) {\n      if (this.isCancelError(error)) {\n        throw error;\n      }\n      response = createGraphQLResultWithError(error);\n    }\n    if (isGraphQLResponseWithErrors(response)) {\n      throw repackageUnauthorizedError(response);\n    }\n    return response;\n  }\n  /**\n   * Checks to see if an error thrown is from an api request cancellation\n   * @param {any} error - Any error\n   * @return {boolean} - A boolean indicating if the error was from an api request cancellation\n   */\n  isCancelError(error) {\n    return this._api.isCancelErrorREST(error);\n  }\n  /**\n   * Cancels an inflight request. Only applicable for graphql queries and mutations\n   * @param {any} request - request to cancel\n   * @returns - A boolean indicating if the request was cancelled\n   */\n  cancel(request, message) {\n    return this._api.cancelREST(request, message);\n  }\n  _graphqlSubscribe(amplify, _ref3) {\n    var _this$appSyncRealTime;\n    let {\n      query,\n      variables,\n      authMode: authModeOverride,\n      apiKey: apiKeyOverride,\n      endpoint\n    } = _ref3;\n    let additionalHeaders = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let customUserAgentDetails = arguments.length > 3 ? arguments[3] : undefined;\n    let authToken = arguments.length > 4 ? arguments[4] : undefined;\n    const config = resolveConfig(amplify);\n    const initialAuthMode = authModeOverride || (config === null || config === void 0 ? void 0 : config.defaultAuthMode) || 'iam';\n    // identityPool is an alias for iam. TODO: remove 'iam' in v7\n    const authMode = initialAuthMode === 'identityPool' ? 'iam' : initialAuthMode;\n    /**\n     * Retrieve library options from Amplify configuration.\n     * `libraryConfigHeaders` are from the Amplify configuration options,\n     * and will not be overwritten by other custom headers. These are *not*\n     * the same as `additionalHeaders`, which are custom headers that are\n     * either 1)included when configuring the API client or 2) passed along\n     * with individual requests.\n     */\n    const {\n      headers: libraryConfigHeaders\n    } = resolveLibraryOptions(amplify);\n    const appSyncGraphqlEndpoint = endpoint !== null && endpoint !== void 0 ? endpoint : config === null || config === void 0 ? void 0 : config.endpoint;\n    // TODO: This could probably be an exception. But, lots of tests rely on\n    // attempting to connect to nowhere. So, I'm treating as the opposite of\n    // a Chesterton's fence for now. (A fence I shouldn't build, because I don't\n    // know why somethings depends on its absence!)\n    const memoKey = appSyncGraphqlEndpoint !== null && appSyncGraphqlEndpoint !== void 0 ? appSyncGraphqlEndpoint : 'none';\n    const realtimeProvider = (_this$appSyncRealTime = this.appSyncRealTime.get(memoKey)) !== null && _this$appSyncRealTime !== void 0 ? _this$appSyncRealTime : new AWSAppSyncRealTimeProvider();\n    this.appSyncRealTime.set(memoKey, realtimeProvider);\n    return realtimeProvider.subscribe({\n      query: print(query),\n      variables,\n      appSyncGraphqlEndpoint,\n      region: config === null || config === void 0 ? void 0 : config.region,\n      authenticationType: authMode,\n      apiKey: apiKeyOverride !== null && apiKeyOverride !== void 0 ? apiKeyOverride : config === null || config === void 0 ? void 0 : config.apiKey,\n      additionalHeaders,\n      authToken,\n      libraryConfigHeaders\n    }, customUserAgentDetails).pipe(catchError(e => {\n      if (e.errors) {\n        throw repackageUnauthorizedError(e);\n      }\n      throw e;\n    }));\n  }\n}\nconst InternalGraphQLAPI = new InternalGraphQLAPIClass();\nexport { InternalGraphQLAPI, InternalGraphQLAPIClass };","map":{"version":3,"names":["USER_AGENT_HEADER","isAmplifyInstance","amplify","InternalGraphQLAPIClass","constructor","appSyncRealTime","Map","_api","post","cancelREST","cancel","isCancelErrorREST","isCancelError","updateRequestToBeCancellable","getModuleName","getGraphqlOperationType","operation","doc","parse","definitions","operationType","graphql","_ref","additionalHeaders","customUserAgentDetails","query","paramQuery","variables","authMode","authToken","endpoint","apiKey","print","operationDef","filter","def","kind","headers","abortController","AbortController","responsePromise","_graphql","wrapper","amplifyInstance","result","_graphqlSubscribe","Error","concat","_ref2","authModeOverride","endpointOverride","apiKeyOverride","arguments","length","undefined","region","appSyncGraphqlEndpoint","customEndpoint","customEndpointRegion","defaultAuthMode","resolveConfig","initialAuthMode","customHeaders","withCredentials","resolveLibraryOptions","additionalCustomHeaders","requestOptions","method","url","AmplifyUrl","toString","queryString","_objectSpread","Authorization","authHeaders","headerBasedAuth","getAmplifyUserAgent","body","signingServiceInfo","service","createGraphQLResultWithError","GraphQLApiError","NO_ENDPOINT","response","responseBody","options","json","error","isGraphQLResponseWithErrors","repackageUnauthorizedError","request","message","_ref3","_this$appSyncRealTime","config","libraryConfigHeaders","memoKey","realtimeProvider","get","AWSAppSyncRealTimeProvider","set","subscribe","authenticationType","pipe","catchError","e","errors","InternalGraphQLAPI"],"sources":["C:\\Users\\vinzl\\workspace\\machicoulis\\daily-image-collector\\node_modules\\@aws-amplify\\api-graphql\\src\\internals\\InternalGraphQLAPI.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { parse, print, } from 'graphql';\nimport { catchError } from 'rxjs';\nimport { AmplifyUrl, getAmplifyUserAgent, } from '@aws-amplify/core/internals/utils';\nimport { isCancelError as isCancelErrorREST } from '@aws-amplify/api-rest';\nimport { cancel as cancelREST, post, updateRequestToBeCancellable, } from '@aws-amplify/api-rest/internals';\nimport { AWSAppSyncRealTimeProvider } from '../Providers/AWSAppSyncRealTimeProvider';\nimport { resolveConfig, resolveLibraryOptions } from '../utils';\nimport { repackageUnauthorizedError } from '../utils/errors/repackageAuthError';\nimport { NO_ENDPOINT } from '../utils/errors/constants';\nimport { GraphQLApiError, createGraphQLResultWithError } from '../utils/errors';\nimport { isGraphQLResponseWithErrors } from './utils/runtimeTypeGuards/isGraphQLResponseWithErrors';\nimport { headerBasedAuth } from './graphqlAuth';\nconst USER_AGENT_HEADER = 'x-amz-user-agent';\nconst isAmplifyInstance = (amplify) => {\n    return typeof amplify !== 'function';\n};\n/**\n * Export Cloud Logic APIs\n */\nexport class InternalGraphQLAPIClass {\n    constructor() {\n        /**\n         * @private\n         */\n        this.appSyncRealTime = new Map();\n        this._api = {\n            post,\n            cancelREST,\n            isCancelErrorREST,\n            updateRequestToBeCancellable,\n        };\n    }\n    getModuleName() {\n        return 'InternalGraphQLAPI';\n    }\n    /**\n     * to get the operation type\n     * @param operation\n     */\n    getGraphqlOperationType(operation) {\n        const doc = parse(operation);\n        const definitions = doc.definitions;\n        const [{ operation: operationType }] = definitions;\n        return operationType;\n    }\n    /**\n     * Executes a GraphQL operation\n     *\n     * @param options - GraphQL Options\n     * @param [additionalHeaders] - headers to merge in after any `libraryConfigHeaders` set in the config\n     * @returns An Observable if the query is a subscription query, else a promise of the graphql result.\n     */\n    graphql(amplify, { query: paramQuery, variables = {}, authMode, authToken, endpoint, apiKey, }, additionalHeaders, customUserAgentDetails) {\n        const query = typeof paramQuery === 'string'\n            ? parse(paramQuery)\n            : parse(print(paramQuery));\n        const [operationDef = {}] = query.definitions.filter(def => def.kind === 'OperationDefinition');\n        const { operation: operationType } = operationDef;\n        const headers = additionalHeaders || {};\n        switch (operationType) {\n            case 'query':\n            case 'mutation': {\n                const abortController = new AbortController();\n                let responsePromise;\n                if (isAmplifyInstance(amplify)) {\n                    responsePromise = this._graphql(amplify, { query, variables, authMode, apiKey, endpoint }, headers, abortController, customUserAgentDetails, authToken);\n                }\n                else {\n                    // NOTE: this wrapper function must be await-able so the Amplify server context manager can\n                    // destroy the context only after it completes\n                    const wrapper = async (amplifyInstance) => {\n                        const result = await this._graphql(amplifyInstance, { query, variables, authMode, apiKey, endpoint }, headers, abortController, customUserAgentDetails, authToken);\n                        return result;\n                    };\n                    responsePromise = amplify(wrapper);\n                }\n                this._api.updateRequestToBeCancellable(responsePromise, abortController);\n                return responsePromise;\n            }\n            case 'subscription':\n                return this._graphqlSubscribe(amplify, { query, variables, authMode, apiKey, endpoint }, headers, customUserAgentDetails, authToken);\n            default:\n                throw new Error(`invalid operation type: ${operationType}`);\n        }\n    }\n    async _graphql(amplify, { query, variables, authMode: authModeOverride, endpoint: endpointOverride, apiKey: apiKeyOverride, }, additionalHeaders = {}, abortController, customUserAgentDetails, authToken) {\n        const { apiKey, region, endpoint: appSyncGraphqlEndpoint, customEndpoint, customEndpointRegion, defaultAuthMode, } = resolveConfig(amplify);\n        const initialAuthMode = authModeOverride || defaultAuthMode || 'iam';\n        // identityPool is an alias for iam. TODO: remove 'iam' in v7\n        const authMode = initialAuthMode === 'identityPool' ? 'iam' : initialAuthMode;\n        /**\n         * Retrieve library options from Amplify configuration.\n         * `customHeaders` here are from the Amplify configuration options,\n         * and are for non-AppSync endpoints only. These are *not* the same as\n         * `additionalHeaders`, which are custom headers that are either 1)\n         * included when configuring the API client or 2) passed along with\n         * individual requests.\n         */\n        const { headers: customHeaders, withCredentials } = resolveLibraryOptions(amplify);\n        /**\n         * Client or request-specific custom headers that may or may not be\n         * returned by a function:\n         */\n        let additionalCustomHeaders;\n        if (typeof additionalHeaders === 'function') {\n            const requestOptions = {\n                method: 'POST',\n                url: new AmplifyUrl(endpointOverride || customEndpoint || appSyncGraphqlEndpoint || '').toString(),\n                queryString: print(query),\n            };\n            additionalCustomHeaders = await additionalHeaders(requestOptions);\n        }\n        else {\n            additionalCustomHeaders = additionalHeaders;\n        }\n        // if an authorization header is set, have the explicit authToken take precedence\n        if (authToken) {\n            additionalCustomHeaders = {\n                ...additionalCustomHeaders,\n                Authorization: authToken,\n            };\n        }\n        const authHeaders = await headerBasedAuth(amplify, authMode, apiKeyOverride ?? apiKey, additionalCustomHeaders);\n        const headers = {\n            ...(!customEndpoint && authHeaders),\n            /**\n             * Custom endpoint headers.\n             * If there is both a custom endpoint and custom region present, we get the headers.\n             * If there is a custom endpoint but no region, we return an empty object.\n             * If neither are present, we return an empty object.\n             */\n            ...((customEndpoint && (customEndpointRegion ? authHeaders : {})) || {}),\n            // Custom headers included in Amplify configuration options:\n            ...(customHeaders &&\n                (await customHeaders({\n                    query: print(query),\n                    variables,\n                }))),\n            // Custom headers from individual requests or API client configuration:\n            ...additionalCustomHeaders,\n            // User agent headers:\n            ...(!customEndpoint && {\n                [USER_AGENT_HEADER]: getAmplifyUserAgent(customUserAgentDetails),\n            }),\n        };\n        const body = {\n            query: print(query),\n            variables: variables || null,\n        };\n        let signingServiceInfo;\n        /**\n         * We do not send the signing service info to the REST API under the\n         * following conditions (i.e. it will not sign the request):\n         *   - there is a custom endpoint but no region\n         *   - the auth mode is `none`, or `apiKey`\n         *   - the auth mode is a type other than the types listed below\n         */\n        if ((customEndpoint && !customEndpointRegion) ||\n            (authMode !== 'oidc' &&\n                authMode !== 'userPool' &&\n                authMode !== 'iam' &&\n                authMode !== 'lambda')) {\n            signingServiceInfo = undefined;\n        }\n        else {\n            signingServiceInfo = {\n                service: !customEndpointRegion ? 'appsync' : 'execute-api',\n                region: !customEndpointRegion ? region : customEndpointRegion,\n            };\n        }\n        const endpoint = endpointOverride || customEndpoint || appSyncGraphqlEndpoint;\n        if (!endpoint) {\n            throw createGraphQLResultWithError(new GraphQLApiError(NO_ENDPOINT));\n        }\n        let response;\n        try {\n            // \t// // See the inline doc of the REST `post()` API for possible errors to be thrown.\n            // \t// // As these errors are catastrophic they should be caught and handled by GraphQL\n            // \t// // API consumers.\n            const { body: responseBody } = await this._api.post(amplify, {\n                url: new AmplifyUrl(endpoint),\n                options: {\n                    headers,\n                    body,\n                    signingServiceInfo,\n                    withCredentials,\n                },\n                abortController,\n            });\n            response = await responseBody.json();\n        }\n        catch (error) {\n            if (this.isCancelError(error)) {\n                throw error;\n            }\n            response = createGraphQLResultWithError(error);\n        }\n        if (isGraphQLResponseWithErrors(response)) {\n            throw repackageUnauthorizedError(response);\n        }\n        return response;\n    }\n    /**\n     * Checks to see if an error thrown is from an api request cancellation\n     * @param {any} error - Any error\n     * @return {boolean} - A boolean indicating if the error was from an api request cancellation\n     */\n    isCancelError(error) {\n        return this._api.isCancelErrorREST(error);\n    }\n    /**\n     * Cancels an inflight request. Only applicable for graphql queries and mutations\n     * @param {any} request - request to cancel\n     * @returns - A boolean indicating if the request was cancelled\n     */\n    cancel(request, message) {\n        return this._api.cancelREST(request, message);\n    }\n    _graphqlSubscribe(amplify, { query, variables, authMode: authModeOverride, apiKey: apiKeyOverride, endpoint, }, additionalHeaders = {}, customUserAgentDetails, authToken) {\n        const config = resolveConfig(amplify);\n        const initialAuthMode = authModeOverride || config?.defaultAuthMode || 'iam';\n        // identityPool is an alias for iam. TODO: remove 'iam' in v7\n        const authMode = initialAuthMode === 'identityPool' ? 'iam' : initialAuthMode;\n        /**\n         * Retrieve library options from Amplify configuration.\n         * `libraryConfigHeaders` are from the Amplify configuration options,\n         * and will not be overwritten by other custom headers. These are *not*\n         * the same as `additionalHeaders`, which are custom headers that are\n         * either 1)included when configuring the API client or 2) passed along\n         * with individual requests.\n         */\n        const { headers: libraryConfigHeaders } = resolveLibraryOptions(amplify);\n        const appSyncGraphqlEndpoint = endpoint ?? config?.endpoint;\n        // TODO: This could probably be an exception. But, lots of tests rely on\n        // attempting to connect to nowhere. So, I'm treating as the opposite of\n        // a Chesterton's fence for now. (A fence I shouldn't build, because I don't\n        // know why somethings depends on its absence!)\n        const memoKey = appSyncGraphqlEndpoint ?? 'none';\n        const realtimeProvider = this.appSyncRealTime.get(memoKey) ?? new AWSAppSyncRealTimeProvider();\n        this.appSyncRealTime.set(memoKey, realtimeProvider);\n        return realtimeProvider\n            .subscribe({\n            query: print(query),\n            variables,\n            appSyncGraphqlEndpoint,\n            region: config?.region,\n            authenticationType: authMode,\n            apiKey: apiKeyOverride ?? config?.apiKey,\n            additionalHeaders,\n            authToken,\n            libraryConfigHeaders,\n        }, customUserAgentDetails)\n            .pipe(catchError(e => {\n            if (e.errors) {\n                throw repackageUnauthorizedError(e);\n            }\n            throw e;\n        }));\n    }\n}\nexport const InternalGraphQLAPI = new InternalGraphQLAPIClass();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}