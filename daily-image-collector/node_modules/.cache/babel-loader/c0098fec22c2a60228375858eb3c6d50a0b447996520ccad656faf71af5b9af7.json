{"ast":null,"code":"'use strict';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CacheList = void 0;\nconst errorHelpers_1 = require(\"./errorHelpers\");\nclass DoubleLinkedNode {\n  constructor(keyVal) {\n    this.key = keyVal || '';\n    this.prevNode = null;\n    this.nextNode = null;\n  }\n}\n/**\n * double linked list plus a hash table inside\n * each key in the cache stored as a node in the list\n * recently visited node will be rotated to the head\n * so the Last Recently Visited node will be at the tail\n *\n * @member head - dummy head of the linked list\n * @member tail - dummy tail of the linked list\n * @member hashtable - the hashtable which maps cache key to list node\n * @member length - length of the list\n */\nclass CacheList {\n  /**\n   * initialization\n   */\n  constructor() {\n    this.head = new DoubleLinkedNode();\n    this.tail = new DoubleLinkedNode();\n    this.hashtable = {};\n    this.length = 0;\n    this.head.nextNode = this.tail;\n    this.tail.prevNode = this.head;\n  }\n  /**\n   * insert node to the head of the list\n   *\n   * @param node\n   */\n  insertNodeToHead(node) {\n    const tmp = this.head.nextNode;\n    this.head.nextNode = node;\n    node.nextNode = tmp;\n    node.prevNode = this.head;\n    (0, errorHelpers_1.assert)(tmp !== null, errorHelpers_1.CacheErrorCode.NullPreviousNode);\n    tmp.prevNode = node;\n    this.length = this.length + 1;\n  }\n  /**\n   * remove node\n   *\n   * @param node\n   */\n  removeNode(node) {\n    (0, errorHelpers_1.assert)(node.prevNode !== null, errorHelpers_1.CacheErrorCode.NullPreviousNode);\n    (0, errorHelpers_1.assert)(node.nextNode !== null, errorHelpers_1.CacheErrorCode.NullNextNode);\n    node.prevNode.nextNode = node.nextNode;\n    node.nextNode.prevNode = node.prevNode;\n    node.prevNode = null;\n    node.nextNode = null;\n    this.length = this.length - 1;\n  }\n  /**\n   * @return true if list is empty\n   */\n  isEmpty() {\n    return this.length === 0;\n  }\n  /**\n   * refresh node so it is rotated to the head\n   *\n   * @param key - key of the node\n   */\n  refresh(key) {\n    const node = this.hashtable[key];\n    this.removeNode(node);\n    this.insertNodeToHead(node);\n  }\n  /**\n   * insert new node to the head and add it in the hashtable\n   *\n   * @param key - the key of the node\n   */\n  insertItem(key) {\n    const node = new DoubleLinkedNode(key);\n    this.hashtable[key] = node;\n    this.insertNodeToHead(node);\n  }\n  /**\n   * @return the LAST Recently Visited key\n   */\n  getLastItem() {\n    (0, errorHelpers_1.assert)(this.tail.prevNode !== null, errorHelpers_1.CacheErrorCode.NullPreviousNode);\n    return this.tail.prevNode.key;\n  }\n  /**\n   * remove the cache key from the list and hashtable\n   * @param key - the key of the node\n   */\n  removeItem(key) {\n    const removedItem = this.hashtable[key];\n    this.removeNode(removedItem);\n    delete this.hashtable[key];\n  }\n  /**\n   * @return length of the list\n   */\n  getSize() {\n    return this.length;\n  }\n  /**\n   * @return true if the key is in the hashtable\n   * @param key\n   */\n  containsKey(key) {\n    return key in this.hashtable;\n  }\n  /**\n   * clean up the list and hashtable\n   */\n  clearList() {\n    for (const key of Object.keys(this.hashtable)) {\n      if (Object.prototype.hasOwnProperty.call(this.hashtable, key)) {\n        delete this.hashtable[key];\n      }\n    }\n    this.head.nextNode = this.tail;\n    this.tail.prevNode = this.head;\n    this.length = 0;\n  }\n  /**\n   * @return all keys in the hashtable\n   */\n  getKeys() {\n    return Object.keys(this.hashtable);\n  }\n  /**\n   * mainly for test\n   *\n   * @param key\n   * @return true if key is the head node\n   */\n  isHeadNode(key) {\n    const node = this.hashtable[key];\n    return node.prevNode === this.head;\n  }\n  /**\n   * mainly for test\n   *\n   * @param key\n   * @return true if key is the tail node\n   */\n  isTailNode(key) {\n    const node = this.hashtable[key];\n    return node.nextNode === this.tail;\n  }\n}\nexports.CacheList = CacheList;","map":{"version":3,"names":["Object","defineProperty","exports","value","CacheList","errorHelpers_1","require","DoubleLinkedNode","constructor","keyVal","key","prevNode","nextNode","head","tail","hashtable","length","insertNodeToHead","node","tmp","assert","CacheErrorCode","NullPreviousNode","removeNode","NullNextNode","isEmpty","refresh","insertItem","getLastItem","removeItem","removedItem","getSize","containsKey","clearList","keys","prototype","hasOwnProperty","call","getKeys","isHeadNode","isTailNode"],"sources":["C:\\Users\\vinzl\\workspace\\machicoulis\\daily-image-collector\\node_modules\\@aws-amplify\\core\\src\\Cache\\utils\\CacheList.ts"],"sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CacheList = void 0;\nconst errorHelpers_1 = require(\"./errorHelpers\");\nclass DoubleLinkedNode {\n    constructor(keyVal) {\n        this.key = keyVal || '';\n        this.prevNode = null;\n        this.nextNode = null;\n    }\n}\n/**\n * double linked list plus a hash table inside\n * each key in the cache stored as a node in the list\n * recently visited node will be rotated to the head\n * so the Last Recently Visited node will be at the tail\n *\n * @member head - dummy head of the linked list\n * @member tail - dummy tail of the linked list\n * @member hashtable - the hashtable which maps cache key to list node\n * @member length - length of the list\n */\nclass CacheList {\n    /**\n     * initialization\n     */\n    constructor() {\n        this.head = new DoubleLinkedNode();\n        this.tail = new DoubleLinkedNode();\n        this.hashtable = {};\n        this.length = 0;\n        this.head.nextNode = this.tail;\n        this.tail.prevNode = this.head;\n    }\n    /**\n     * insert node to the head of the list\n     *\n     * @param node\n     */\n    insertNodeToHead(node) {\n        const tmp = this.head.nextNode;\n        this.head.nextNode = node;\n        node.nextNode = tmp;\n        node.prevNode = this.head;\n        (0, errorHelpers_1.assert)(tmp !== null, errorHelpers_1.CacheErrorCode.NullPreviousNode);\n        tmp.prevNode = node;\n        this.length = this.length + 1;\n    }\n    /**\n     * remove node\n     *\n     * @param node\n     */\n    removeNode(node) {\n        (0, errorHelpers_1.assert)(node.prevNode !== null, errorHelpers_1.CacheErrorCode.NullPreviousNode);\n        (0, errorHelpers_1.assert)(node.nextNode !== null, errorHelpers_1.CacheErrorCode.NullNextNode);\n        node.prevNode.nextNode = node.nextNode;\n        node.nextNode.prevNode = node.prevNode;\n        node.prevNode = null;\n        node.nextNode = null;\n        this.length = this.length - 1;\n    }\n    /**\n     * @return true if list is empty\n     */\n    isEmpty() {\n        return this.length === 0;\n    }\n    /**\n     * refresh node so it is rotated to the head\n     *\n     * @param key - key of the node\n     */\n    refresh(key) {\n        const node = this.hashtable[key];\n        this.removeNode(node);\n        this.insertNodeToHead(node);\n    }\n    /**\n     * insert new node to the head and add it in the hashtable\n     *\n     * @param key - the key of the node\n     */\n    insertItem(key) {\n        const node = new DoubleLinkedNode(key);\n        this.hashtable[key] = node;\n        this.insertNodeToHead(node);\n    }\n    /**\n     * @return the LAST Recently Visited key\n     */\n    getLastItem() {\n        (0, errorHelpers_1.assert)(this.tail.prevNode !== null, errorHelpers_1.CacheErrorCode.NullPreviousNode);\n        return this.tail.prevNode.key;\n    }\n    /**\n     * remove the cache key from the list and hashtable\n     * @param key - the key of the node\n     */\n    removeItem(key) {\n        const removedItem = this.hashtable[key];\n        this.removeNode(removedItem);\n        delete this.hashtable[key];\n    }\n    /**\n     * @return length of the list\n     */\n    getSize() {\n        return this.length;\n    }\n    /**\n     * @return true if the key is in the hashtable\n     * @param key\n     */\n    containsKey(key) {\n        return key in this.hashtable;\n    }\n    /**\n     * clean up the list and hashtable\n     */\n    clearList() {\n        for (const key of Object.keys(this.hashtable)) {\n            if (Object.prototype.hasOwnProperty.call(this.hashtable, key)) {\n                delete this.hashtable[key];\n            }\n        }\n        this.head.nextNode = this.tail;\n        this.tail.prevNode = this.head;\n        this.length = 0;\n    }\n    /**\n     * @return all keys in the hashtable\n     */\n    getKeys() {\n        return Object.keys(this.hashtable);\n    }\n    /**\n     * mainly for test\n     *\n     * @param key\n     * @return true if key is the head node\n     */\n    isHeadNode(key) {\n        const node = this.hashtable[key];\n        return node.prevNode === this.head;\n    }\n    /**\n     * mainly for test\n     *\n     * @param key\n     * @return true if key is the tail node\n     */\n    isTailNode(key) {\n        const node = this.hashtable[key];\n        return node.nextNode === this.tail;\n    }\n}\nexports.CacheList = CacheList;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}