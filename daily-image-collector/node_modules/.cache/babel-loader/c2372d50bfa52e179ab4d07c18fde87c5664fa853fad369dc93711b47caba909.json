{"ast":null,"code":"import _objectSpread from \"C:/Users/vinzl/workspace/machicoulis/daily-image-collector/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { Amplify } from '@aws-amplify/core';\nimport { amplifyUuid } from '@aws-amplify/core/internals/utils';\nimport { AppSyncEventProvider } from '../../Providers/AWSAppSyncEventsProvider/index.mjs';\nimport { appsyncRequest } from './appsyncRequest.mjs';\nimport { configure, normalizeAuth, serializeEvents } from './utils.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n// Keeps a list of open channels in the websocket\nconst openChannels = new Set();\n/**\n * @experimental API may change in future versions\n *\n * Establish a WebSocket connection to an Events channel\n *\n * @example\n * const channel = await events.connect(\"default/channel\")\n *\n * channel.subscribe({\n *   next: (data) => { console.log(data) },\n *   error: (err) => { console.error(err) },\n * })\n *\n * @example // authMode override\n * const channel = await events.connect(\"default/channel\", { authMode: \"userPool\" })\n *\n * @param channel - channel path; `<namespace>/<channel>`\n * @param options - request overrides: `authMode`, `authToken`\n *\n */\nasync function connect(channel, options) {\n  const providerOptions = configure();\n  providerOptions.authenticationType = normalizeAuth(options === null || options === void 0 ? void 0 : options.authMode, providerOptions.authenticationType);\n  providerOptions.apiKey = (options === null || options === void 0 ? void 0 : options.apiKey) || providerOptions.apiKey;\n  providerOptions.authToken = (options === null || options === void 0 ? void 0 : options.authToken) || providerOptions.authToken;\n  await AppSyncEventProvider.connect(providerOptions);\n  const channelId = amplifyUuid();\n  openChannels.add(channelId);\n  let _subscription;\n  const sub = (observer, subOptions) => {\n    if (!openChannels.has(channelId)) {\n      throw new Error('Channel is closed');\n    }\n    const subscribeOptions = _objectSpread(_objectSpread({}, providerOptions), {}, {\n      query: channel\n    });\n    subscribeOptions.authenticationType = normalizeAuth(subOptions === null || subOptions === void 0 ? void 0 : subOptions.authMode, subscribeOptions.authenticationType);\n    subscribeOptions.apiKey = (subOptions === null || subOptions === void 0 ? void 0 : subOptions.apiKey) || subscribeOptions.apiKey;\n    subscribeOptions.authToken = (subOptions === null || subOptions === void 0 ? void 0 : subOptions.authToken) || subscribeOptions.authToken;\n    _subscription = AppSyncEventProvider.subscribe(subscribeOptions).subscribe(observer);\n    return _subscription;\n  };\n  const pub = async (event, pubOptions) => {\n    if (!openChannels.has(channelId)) {\n      throw new Error('Channel is closed');\n    }\n    const publishOptions = _objectSpread(_objectSpread({}, providerOptions), {}, {\n      query: channel,\n      variables: event\n    });\n    publishOptions.authenticationType = normalizeAuth(pubOptions === null || pubOptions === void 0 ? void 0 : pubOptions.authMode, publishOptions.authenticationType);\n    publishOptions.apiKey = (pubOptions === null || pubOptions === void 0 ? void 0 : pubOptions.apiKey) || publishOptions.apiKey;\n    publishOptions.authToken = (pubOptions === null || pubOptions === void 0 ? void 0 : pubOptions.authToken) || publishOptions.authToken;\n    return AppSyncEventProvider.publish(publishOptions);\n  };\n  const close = async () => {\n    _subscription && _subscription.unsubscribe();\n    openChannels.delete(channelId);\n    setTimeout(() => {\n      if (openChannels.size === 0) {\n        AppSyncEventProvider.closeIfNoActiveSubscription();\n      }\n    }, 1000);\n  };\n  return {\n    subscribe: sub,\n    close,\n    publish: pub\n  };\n}\n/**\n * @experimental API may change in future versions\n *\n * Publish events to a channel via HTTP request\n *\n * @example\n * await events.post(\"default/channel\", { some: \"event\" })\n *\n * @example // event batching\n * await events.post(\"default/channel\", [{ some: \"event\" }, { some: \"event2\" }])\n *\n * @example // authMode override\n * await events.post(\"default/channel\", { some: \"event\" }, { authMode: \"userPool\" })\n *\n * @param channel - channel path; `<namespace>/<channel>`\n * @param event - JSON-serializable value or an array of values\n * @param options - request overrides: `authMode`, `authToken`\n *\n * @returns void on success\n * @throws on error\n */\nasync function post(channel, event, options) {\n  var _res$failed;\n  const providerOptions = configure();\n  providerOptions.authenticationType = normalizeAuth(options === null || options === void 0 ? void 0 : options.authMode, providerOptions.authenticationType);\n  providerOptions.apiKey = (options === null || options === void 0 ? void 0 : options.apiKey) || providerOptions.apiKey;\n  providerOptions.authToken = (options === null || options === void 0 ? void 0 : options.authToken) || providerOptions.authToken;\n  // trailing slash required in publish\n  const normalizedChannelName = channel[0] === '/' ? channel : \"/\".concat(channel);\n  const publishOptions = _objectSpread(_objectSpread({}, providerOptions), {}, {\n    query: normalizedChannelName,\n    variables: serializeEvents(event)\n  });\n  const abortController = new AbortController();\n  const res = await appsyncRequest(Amplify, publishOptions, {}, abortController);\n  if (((_res$failed = res.failed) === null || _res$failed === void 0 ? void 0 : _res$failed.length) > 0) {\n    return res.failed;\n  }\n}\n/**\n * @experimental API may change in future versions\n *\n * Close WebSocket connection, disconnect listeners and reconnect observers\n *\n * @example\n * await events.closeAll()\n *\n * @returns void on success\n * @throws on error\n */\nasync function closeAll() {\n  await AppSyncEventProvider.close();\n}\nexport { closeAll, connect, post };","map":{"version":3,"names":["openChannels","Set","connect","channel","options","providerOptions","configure","authenticationType","normalizeAuth","authMode","apiKey","authToken","AppSyncEventProvider","channelId","amplifyUuid","add","_subscription","sub","observer","subOptions","has","Error","subscribeOptions","_objectSpread","query","subscribe","pub","event","pubOptions","publishOptions","variables","publish","close","unsubscribe","delete","setTimeout","size","closeIfNoActiveSubscription","post","_res$failed","normalizedChannelName","concat","serializeEvents","abortController","AbortController","res","appsyncRequest","Amplify","failed","length","closeAll"],"sources":["C:\\Users\\vinzl\\workspace\\machicoulis\\daily-image-collector\\node_modules\\@aws-amplify\\api-graphql\\src\\internals\\events\\index.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Amplify } from '@aws-amplify/core';\nimport { amplifyUuid } from '@aws-amplify/core/internals/utils';\nimport { AppSyncEventProvider as eventProvider } from '../../Providers/AWSAppSyncEventsProvider';\nimport { appsyncRequest } from './appsyncRequest';\nimport { configure, normalizeAuth, serializeEvents } from './utils';\n// Keeps a list of open channels in the websocket\nconst openChannels = new Set();\n/**\n * @experimental API may change in future versions\n *\n * Establish a WebSocket connection to an Events channel\n *\n * @example\n * const channel = await events.connect(\"default/channel\")\n *\n * channel.subscribe({\n *   next: (data) => { console.log(data) },\n *   error: (err) => { console.error(err) },\n * })\n *\n * @example // authMode override\n * const channel = await events.connect(\"default/channel\", { authMode: \"userPool\" })\n *\n * @param channel - channel path; `<namespace>/<channel>`\n * @param options - request overrides: `authMode`, `authToken`\n *\n */\nasync function connect(channel, options) {\n    const providerOptions = configure();\n    providerOptions.authenticationType = normalizeAuth(options?.authMode, providerOptions.authenticationType);\n    providerOptions.apiKey = options?.apiKey || providerOptions.apiKey;\n    providerOptions.authToken = options?.authToken || providerOptions.authToken;\n    await eventProvider.connect(providerOptions);\n    const channelId = amplifyUuid();\n    openChannels.add(channelId);\n    let _subscription;\n    const sub = (observer, subOptions) => {\n        if (!openChannels.has(channelId)) {\n            throw new Error('Channel is closed');\n        }\n        const subscribeOptions = { ...providerOptions, query: channel };\n        subscribeOptions.authenticationType = normalizeAuth(subOptions?.authMode, subscribeOptions.authenticationType);\n        subscribeOptions.apiKey = subOptions?.apiKey || subscribeOptions.apiKey;\n        subscribeOptions.authToken =\n            subOptions?.authToken || subscribeOptions.authToken;\n        _subscription = eventProvider\n            .subscribe(subscribeOptions)\n            .subscribe(observer);\n        return _subscription;\n    };\n    const pub = async (event, pubOptions) => {\n        if (!openChannels.has(channelId)) {\n            throw new Error('Channel is closed');\n        }\n        const publishOptions = {\n            ...providerOptions,\n            query: channel,\n            variables: event,\n        };\n        publishOptions.authenticationType = normalizeAuth(pubOptions?.authMode, publishOptions.authenticationType);\n        publishOptions.apiKey = pubOptions?.apiKey || publishOptions.apiKey;\n        publishOptions.authToken =\n            pubOptions?.authToken || publishOptions.authToken;\n        return eventProvider.publish(publishOptions);\n    };\n    const close = async () => {\n        _subscription && _subscription.unsubscribe();\n        openChannels.delete(channelId);\n        setTimeout(() => {\n            if (openChannels.size === 0) {\n                eventProvider.closeIfNoActiveSubscription();\n            }\n        }, 1000);\n    };\n    return {\n        subscribe: sub,\n        close,\n        publish: pub,\n    };\n}\n/**\n * @experimental API may change in future versions\n *\n * Publish events to a channel via HTTP request\n *\n * @example\n * await events.post(\"default/channel\", { some: \"event\" })\n *\n * @example // event batching\n * await events.post(\"default/channel\", [{ some: \"event\" }, { some: \"event2\" }])\n *\n * @example // authMode override\n * await events.post(\"default/channel\", { some: \"event\" }, { authMode: \"userPool\" })\n *\n * @param channel - channel path; `<namespace>/<channel>`\n * @param event - JSON-serializable value or an array of values\n * @param options - request overrides: `authMode`, `authToken`\n *\n * @returns void on success\n * @throws on error\n */\nasync function post(channel, event, options) {\n    const providerOptions = configure();\n    providerOptions.authenticationType = normalizeAuth(options?.authMode, providerOptions.authenticationType);\n    providerOptions.apiKey = options?.apiKey || providerOptions.apiKey;\n    providerOptions.authToken = options?.authToken || providerOptions.authToken;\n    // trailing slash required in publish\n    const normalizedChannelName = channel[0] === '/' ? channel : `/${channel}`;\n    const publishOptions = {\n        ...providerOptions,\n        query: normalizedChannelName,\n        variables: serializeEvents(event),\n    };\n    const abortController = new AbortController();\n    const res = await appsyncRequest(Amplify, publishOptions, {}, abortController);\n    if (res.failed?.length > 0) {\n        return res.failed;\n    }\n}\n/**\n * @experimental API may change in future versions\n *\n * Close WebSocket connection, disconnect listeners and reconnect observers\n *\n * @example\n * await events.closeAll()\n *\n * @returns void on success\n * @throws on error\n */\nasync function closeAll() {\n    await eventProvider.close();\n}\nexport { connect, post, closeAll };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}