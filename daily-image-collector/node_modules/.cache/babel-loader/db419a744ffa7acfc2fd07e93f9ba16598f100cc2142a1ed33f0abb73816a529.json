{"ast":null,"code":"'use strict';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StorageCacheCommon = void 0;\nconst Logger_1 = require(\"../Logger\");\nconst constants_1 = require(\"./constants\");\nconst utils_1 = require(\"./utils\");\nconst errorHelpers_1 = require(\"./utils/errorHelpers\");\nconst logger = new Logger_1.ConsoleLogger('StorageCache');\n/**\n * Initialization of the cache\n *\n */\nclass StorageCacheCommon {\n  /**\n   * Initialize the cache\n   *\n   * @param config - Custom configuration for this instance.\n   */\n  constructor({\n    config,\n    keyValueStorage\n  }) {\n    this.config = {\n      ...constants_1.defaultConfig,\n      ...config\n    };\n    this.keyValueStorage = keyValueStorage;\n    this.sanitizeConfig();\n  }\n  getModuleName() {\n    return 'Cache';\n  }\n  /**\n   * Set custom configuration for the cache instance.\n   *\n   * @param config - customized configuration (without keyPrefix, which can't be changed)\n   *\n   * @return - the current configuration\n   */\n  configure(config) {\n    if (config) {\n      if (config.keyPrefix) {\n        logger.warn('keyPrefix can not be re-configured on an existing Cache instance.');\n      }\n      this.config = {\n        ...this.config,\n        ...config\n      };\n    }\n    this.sanitizeConfig();\n    return this.config;\n  }\n  /**\n   * return the current size of the cache\n   * @return {Promise}\n   */\n  async getCurrentCacheSize() {\n    let size = await this.getStorage().getItem((0, utils_1.getCurrentSizeKey)(this.config.keyPrefix));\n    if (!size) {\n      await this.getStorage().setItem((0, utils_1.getCurrentSizeKey)(this.config.keyPrefix), '0');\n      size = '0';\n    }\n    return Number(size);\n  }\n  /**\n   * Set item into cache. You can put number, string, boolean or object.\n   * The cache will first check whether has the same key.\n   * If it has, it will delete the old item and then put the new item in\n   * The cache will pop out items if it is full\n   * You can specify the cache item options. The cache will abort and output a warning:\n   * If the key is invalid\n   * If the size of the item exceeds itemMaxSize.\n   * If the value is undefined\n   * If incorrect cache item configuration\n   * If error happened with browser storage\n   *\n   * @param {String} key - the key of the item\n   * @param {Object} value - the value of the item\n   * @param {Object} [options] - optional, the specified meta-data\n   *\n   * @return {Promise}\n   */\n  async setItem(key, value, options) {\n    logger.debug(`Set item: key is ${key}, value is ${value} with options: ${options}`);\n    if (!key || key === constants_1.currentSizeKey) {\n      logger.warn(`Invalid key: should not be empty or reserved key: '${constants_1.currentSizeKey}'`);\n      return;\n    }\n    if (typeof value === 'undefined') {\n      logger.warn(`The value of item should not be undefined!`);\n      return;\n    }\n    const cacheItemOptions = {\n      priority: options?.priority !== undefined ? options.priority : this.config.defaultPriority,\n      expires: options?.expires !== undefined ? options.expires : this.config.defaultTTL + (0, utils_1.getCurrentTime)()\n    };\n    if (cacheItemOptions.priority < 1 || cacheItemOptions.priority > 5) {\n      logger.warn(`Invalid parameter: priority due to out or range. It should be within 1 and 5.`);\n      return;\n    }\n    const prefixedKey = `${this.config.keyPrefix}${key}`;\n    const item = this.fillCacheItem(prefixedKey, value, cacheItemOptions);\n    // check whether this item is too big;\n    if (item.byteSize > this.config.itemMaxSize) {\n      logger.warn(`Item with key: ${key} you are trying to put into is too big!`);\n      return;\n    }\n    try {\n      // first look into the storage, if it exists, delete it.\n      const val = await this.getStorage().getItem(prefixedKey);\n      if (val) {\n        await this.removeCacheItem(prefixedKey, JSON.parse(val).byteSize);\n      }\n      // check whether the cache is full\n      if (await this.isCacheFull(item.byteSize)) {\n        const validKeys = await this.clearInvalidAndGetRemainingKeys();\n        if (await this.isCacheFull(item.byteSize)) {\n          const sizeToPop = await this.sizeToPop(item.byteSize);\n          await this.popOutItems(validKeys, sizeToPop);\n        }\n      }\n      // put item in the cache\n      return this.setCacheItem(prefixedKey, item);\n    } catch (e) {\n      logger.warn(`setItem failed! ${e}`);\n    }\n  }\n  /**\n   * Get item from cache. It will return null if item doesnâ€™t exist or it has been expired.\n   * If you specified callback function in the options,\n   * then the function will be executed if no such item in the cache\n   * and finally put the return value into cache.\n   * Please make sure the callback function will return the value you want to put into the cache.\n   * The cache will abort output a warning:\n   * If the key is invalid\n   * If error happened with AsyncStorage\n   *\n   * @param {String} key - the key of the item\n   * @param {Object} [options] - the options of callback function\n   *\n   * @return {Promise} - return a promise resolves to be the value of the item\n   */\n  async getItem(key, options) {\n    logger.debug(`Get item: key is ${key} with options ${options}`);\n    let cached;\n    if (!key || key === constants_1.currentSizeKey) {\n      logger.warn(`Invalid key: should not be empty or reserved key: '${constants_1.currentSizeKey}'`);\n      return null;\n    }\n    const prefixedKey = `${this.config.keyPrefix}${key}`;\n    try {\n      cached = await this.getStorage().getItem(prefixedKey);\n      if (cached != null) {\n        if (await this.isExpired(prefixedKey)) {\n          // if expired, remove that item and return null\n          await this.removeCacheItem(prefixedKey, JSON.parse(cached).byteSize);\n        } else {\n          // if not expired, update its visitedTime and return the value\n          const item = await this.updateVisitedTime(JSON.parse(cached), prefixedKey);\n          return item.data;\n        }\n      }\n      if (options?.callback) {\n        const val = options.callback();\n        if (val !== null) {\n          await this.setItem(key, val, options);\n        }\n        return val;\n      }\n      return null;\n    } catch (e) {\n      logger.warn(`getItem failed! ${e}`);\n      return null;\n    }\n  }\n  /**\n   * remove item from the cache\n   * The cache will abort output a warning:\n   * If error happened with AsyncStorage\n   * @param {String} key - the key of the item\n   * @return {Promise}\n   */\n  async removeItem(key) {\n    logger.debug(`Remove item: key is ${key}`);\n    if (!key || key === constants_1.currentSizeKey) {\n      logger.warn(`Invalid key: should not be empty or reserved key: '${constants_1.currentSizeKey}'`);\n      return;\n    }\n    const prefixedKey = `${this.config.keyPrefix}${key}`;\n    try {\n      const val = await this.getStorage().getItem(prefixedKey);\n      if (val) {\n        await this.removeCacheItem(prefixedKey, JSON.parse(val).byteSize);\n      }\n    } catch (e) {\n      logger.warn(`removeItem failed! ${e}`);\n    }\n  }\n  /**\n   * Return all the keys owned by this cache.\n   * Will return an empty array if error occurred.\n   *\n   * @return {Promise}\n   */\n  async getAllKeys() {\n    try {\n      return await this.getAllCacheKeys();\n    } catch (e) {\n      logger.warn(`getAllkeys failed! ${e}`);\n      return [];\n    }\n  }\n  getStorage() {\n    return this.keyValueStorage;\n  }\n  /**\n   * check whether item is expired\n   *\n   * @param key - the key of the item\n   *\n   * @return true if the item is expired.\n   */\n  async isExpired(key) {\n    const text = await this.getStorage().getItem(key);\n    (0, errorHelpers_1.assert)(text !== null, errorHelpers_1.CacheErrorCode.NoCacheItem, `Key: ${key}`);\n    const item = JSON.parse(text);\n    if ((0, utils_1.getCurrentTime)() >= item.expires) {\n      return true;\n    }\n    return false;\n  }\n  /**\n   * delete item from cache\n   *\n   * @param prefixedKey - the key of the item\n   * @param size - optional, the byte size of the item\n   */\n  async removeCacheItem(prefixedKey, size) {\n    const item = await this.getStorage().getItem(prefixedKey);\n    (0, errorHelpers_1.assert)(item !== null, errorHelpers_1.CacheErrorCode.NoCacheItem, `Key: ${prefixedKey}`);\n    const itemSize = size ?? JSON.parse(item).byteSize;\n    // first try to update the current size of the cache\n    await this.decreaseCurrentSizeInBytes(itemSize);\n    // try to remove the item from cache\n    try {\n      await this.getStorage().removeItem(prefixedKey);\n    } catch (removeItemError) {\n      // if some error happened, we need to rollback the current size\n      await this.increaseCurrentSizeInBytes(itemSize);\n      logger.error(`Failed to remove item: ${removeItemError}`);\n    }\n  }\n  /**\n   * produce a JSON object with meta-data and data value\n   * @param value - the value of the item\n   * @param options - optional, the specified meta-data\n   *\n   * @return - the item which has the meta-data and the value\n   */\n  fillCacheItem(key, value, options) {\n    const item = {\n      key,\n      data: value,\n      timestamp: (0, utils_1.getCurrentTime)(),\n      visitedTime: (0, utils_1.getCurrentTime)(),\n      priority: options.priority ?? 0,\n      expires: options.expires ?? 0,\n      type: typeof value,\n      byteSize: 0\n    };\n    // calculate byte size\n    item.byteSize = (0, utils_1.getByteLength)(JSON.stringify(item));\n    // re-calculate using cache item with updated byteSize property\n    item.byteSize = (0, utils_1.getByteLength)(JSON.stringify(item));\n    return item;\n  }\n  sanitizeConfig() {\n    if (this.config.itemMaxSize > this.config.capacityInBytes) {\n      logger.error('Invalid parameter: itemMaxSize. It should be smaller than capacityInBytes. Setting back to default.');\n      this.config.itemMaxSize = constants_1.defaultConfig.itemMaxSize;\n    }\n    if (this.config.defaultPriority > 5 || this.config.defaultPriority < 1) {\n      logger.error('Invalid parameter: defaultPriority. It should be between 1 and 5. Setting back to default.');\n      this.config.defaultPriority = constants_1.defaultConfig.defaultPriority;\n    }\n    if (Number(this.config.warningThreshold) > 1 || Number(this.config.warningThreshold) < 0) {\n      logger.error('Invalid parameter: warningThreshold. It should be between 0 and 1. Setting back to default.');\n      this.config.warningThreshold = constants_1.defaultConfig.warningThreshold;\n    }\n    // Set 5MB limit\n    const cacheLimit = 5 * 1024 * 1024;\n    if (this.config.capacityInBytes > cacheLimit) {\n      logger.error('Cache Capacity should be less than 5MB. Setting back to default. Setting back to default.');\n      this.config.capacityInBytes = constants_1.defaultConfig.capacityInBytes;\n    }\n  }\n  /**\n   * increase current size of the cache\n   *\n   * @param amount - the amount of the cache szie which need to be increased\n   */\n  async increaseCurrentSizeInBytes(amount) {\n    const size = await this.getCurrentCacheSize();\n    await this.getStorage().setItem((0, utils_1.getCurrentSizeKey)(this.config.keyPrefix), (size + amount).toString());\n  }\n  /**\n   * decrease current size of the cache\n   *\n   * @param amount - the amount of the cache size which needs to be decreased\n   */\n  async decreaseCurrentSizeInBytes(amount) {\n    const size = await this.getCurrentCacheSize();\n    await this.getStorage().setItem((0, utils_1.getCurrentSizeKey)(this.config.keyPrefix), (size - amount).toString());\n  }\n  /**\n   * update the visited time if item has been visited\n   *\n   * @param item - the item which need to be updated\n   * @param prefixedKey - the key of the item\n   *\n   * @return the updated item\n   */\n  async updateVisitedTime(item, prefixedKey) {\n    item.visitedTime = (0, utils_1.getCurrentTime)();\n    await this.getStorage().setItem(prefixedKey, JSON.stringify(item));\n    return item;\n  }\n  /**\n   * put item into cache\n   *\n   * @param prefixedKey - the key of the item\n   * @param itemData - the value of the item\n   * @param itemSizeInBytes - the byte size of the item\n   */\n  async setCacheItem(prefixedKey, item) {\n    // first try to update the current size of the cache.\n    await this.increaseCurrentSizeInBytes(item.byteSize);\n    // try to add the item into cache\n    try {\n      await this.getStorage().setItem(prefixedKey, JSON.stringify(item));\n    } catch (setItemErr) {\n      // if some error happened, we need to rollback the current size\n      await this.decreaseCurrentSizeInBytes(item.byteSize);\n      logger.error(`Failed to set item ${setItemErr}`);\n    }\n  }\n  /**\n   * total space needed when poping out items\n   *\n   * @param itemSize\n   *\n   * @return total space needed\n   */\n  async sizeToPop(itemSize) {\n    const cur = await this.getCurrentCacheSize();\n    const spaceItemNeed = cur + itemSize - this.config.capacityInBytes;\n    const cacheThresholdSpace = (1 - this.config.warningThreshold) * this.config.capacityInBytes;\n    return spaceItemNeed > cacheThresholdSpace ? spaceItemNeed : cacheThresholdSpace;\n  }\n  /**\n   * see whether cache is full\n   *\n   * @param itemSize\n   *\n   * @return true if cache is full\n   */\n  async isCacheFull(itemSize) {\n    const cur = await this.getCurrentCacheSize();\n    return itemSize + cur > this.config.capacityInBytes;\n  }\n  /**\n   * get all the items we have, sort them by their priority,\n   * if priority is same, sort them by their last visited time\n   * pop out items from the low priority (5 is the lowest)\n   * @private\n   * @param keys - all the keys in this cache\n   * @param sizeToPop - the total size of the items which needed to be poped out\n   */\n  async popOutItems(keys, sizeToPop) {\n    const items = [];\n    let remainedSize = sizeToPop;\n    for (const key of keys) {\n      const val = await this.getStorage().getItem(key);\n      if (val != null) {\n        const item = JSON.parse(val);\n        items.push(item);\n      }\n    }\n    // first compare priority\n    // then compare visited time\n    items.sort((a, b) => {\n      if (a.priority > b.priority) {\n        return -1;\n      } else if (a.priority < b.priority) {\n        return 1;\n      } else {\n        if (a.visitedTime < b.visitedTime) {\n          return -1;\n        } else return 1;\n      }\n    });\n    for (const item of items) {\n      // pop out items until we have enough room for new item\n      await this.removeCacheItem(item.key, item.byteSize);\n      remainedSize -= item.byteSize;\n      if (remainedSize <= 0) {\n        return;\n      }\n    }\n  }\n  /**\n   * Scan the storage and combine the following operations for efficiency\n   *   1. Clear out all expired keys owned by this cache, not including the size key.\n   *   2. Return the remaining keys.\n   *\n   * @return The remaining valid keys\n   */\n  async clearInvalidAndGetRemainingKeys() {\n    const remainingKeys = [];\n    const keys = await this.getAllCacheKeys({\n      omitSizeKey: true\n    });\n    for (const key of keys) {\n      if (await this.isExpired(key)) {\n        await this.removeCacheItem(key);\n      } else {\n        remainingKeys.push(key);\n      }\n    }\n    return remainingKeys;\n  }\n  /**\n   * clear the entire cache\n   * The cache will abort and output a warning if error occurs\n   * @return {Promise}\n   */\n  async clear() {\n    logger.debug(`Clear Cache`);\n    try {\n      const keys = await this.getAllKeys();\n      for (const key of keys) {\n        const prefixedKey = `${this.config.keyPrefix}${key}`;\n        await this.getStorage().removeItem(prefixedKey);\n      }\n    } catch (e) {\n      logger.warn(`clear failed! ${e}`);\n    }\n  }\n}\nexports.StorageCacheCommon = StorageCacheCommon;","map":{"version":3,"names":["Object","defineProperty","exports","value","StorageCacheCommon","Logger_1","require","constants_1","utils_1","errorHelpers_1","logger","ConsoleLogger","constructor","config","keyValueStorage","defaultConfig","sanitizeConfig","getModuleName","configure","keyPrefix","warn","getCurrentCacheSize","size","getStorage","getItem","getCurrentSizeKey","setItem","Number","key","options","debug","currentSizeKey","cacheItemOptions","priority","undefined","defaultPriority","expires","defaultTTL","getCurrentTime","prefixedKey","item","fillCacheItem","byteSize","itemMaxSize","val","removeCacheItem","JSON","parse","isCacheFull","validKeys","clearInvalidAndGetRemainingKeys","sizeToPop","popOutItems","setCacheItem","e","cached","isExpired","updateVisitedTime","data","callback","removeItem","getAllKeys","getAllCacheKeys","text","assert","CacheErrorCode","NoCacheItem","itemSize","decreaseCurrentSizeInBytes","removeItemError","increaseCurrentSizeInBytes","error","timestamp","visitedTime","type","getByteLength","stringify","capacityInBytes","warningThreshold","cacheLimit","amount","toString","setItemErr","cur","spaceItemNeed","cacheThresholdSpace","keys","items","remainedSize","push","sort","a","b","remainingKeys","omitSizeKey","clear"],"sources":["C:\\Users\\vinzl\\workspace\\machicoulis\\daily-image-collector\\node_modules\\@aws-amplify\\core\\src\\Cache\\StorageCacheCommon.ts"],"sourcesContent":["\"use strict\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StorageCacheCommon = void 0;\nconst Logger_1 = require(\"../Logger\");\nconst constants_1 = require(\"./constants\");\nconst utils_1 = require(\"./utils\");\nconst errorHelpers_1 = require(\"./utils/errorHelpers\");\nconst logger = new Logger_1.ConsoleLogger('StorageCache');\n/**\n * Initialization of the cache\n *\n */\nclass StorageCacheCommon {\n    /**\n     * Initialize the cache\n     *\n     * @param config - Custom configuration for this instance.\n     */\n    constructor({ config, keyValueStorage, }) {\n        this.config = {\n            ...constants_1.defaultConfig,\n            ...config,\n        };\n        this.keyValueStorage = keyValueStorage;\n        this.sanitizeConfig();\n    }\n    getModuleName() {\n        return 'Cache';\n    }\n    /**\n     * Set custom configuration for the cache instance.\n     *\n     * @param config - customized configuration (without keyPrefix, which can't be changed)\n     *\n     * @return - the current configuration\n     */\n    configure(config) {\n        if (config) {\n            if (config.keyPrefix) {\n                logger.warn('keyPrefix can not be re-configured on an existing Cache instance.');\n            }\n            this.config = {\n                ...this.config,\n                ...config,\n            };\n        }\n        this.sanitizeConfig();\n        return this.config;\n    }\n    /**\n     * return the current size of the cache\n     * @return {Promise}\n     */\n    async getCurrentCacheSize() {\n        let size = await this.getStorage().getItem((0, utils_1.getCurrentSizeKey)(this.config.keyPrefix));\n        if (!size) {\n            await this.getStorage().setItem((0, utils_1.getCurrentSizeKey)(this.config.keyPrefix), '0');\n            size = '0';\n        }\n        return Number(size);\n    }\n    /**\n     * Set item into cache. You can put number, string, boolean or object.\n     * The cache will first check whether has the same key.\n     * If it has, it will delete the old item and then put the new item in\n     * The cache will pop out items if it is full\n     * You can specify the cache item options. The cache will abort and output a warning:\n     * If the key is invalid\n     * If the size of the item exceeds itemMaxSize.\n     * If the value is undefined\n     * If incorrect cache item configuration\n     * If error happened with browser storage\n     *\n     * @param {String} key - the key of the item\n     * @param {Object} value - the value of the item\n     * @param {Object} [options] - optional, the specified meta-data\n     *\n     * @return {Promise}\n     */\n    async setItem(key, value, options) {\n        logger.debug(`Set item: key is ${key}, value is ${value} with options: ${options}`);\n        if (!key || key === constants_1.currentSizeKey) {\n            logger.warn(`Invalid key: should not be empty or reserved key: '${constants_1.currentSizeKey}'`);\n            return;\n        }\n        if (typeof value === 'undefined') {\n            logger.warn(`The value of item should not be undefined!`);\n            return;\n        }\n        const cacheItemOptions = {\n            priority: options?.priority !== undefined\n                ? options.priority\n                : this.config.defaultPriority,\n            expires: options?.expires !== undefined\n                ? options.expires\n                : this.config.defaultTTL + (0, utils_1.getCurrentTime)(),\n        };\n        if (cacheItemOptions.priority < 1 || cacheItemOptions.priority > 5) {\n            logger.warn(`Invalid parameter: priority due to out or range. It should be within 1 and 5.`);\n            return;\n        }\n        const prefixedKey = `${this.config.keyPrefix}${key}`;\n        const item = this.fillCacheItem(prefixedKey, value, cacheItemOptions);\n        // check whether this item is too big;\n        if (item.byteSize > this.config.itemMaxSize) {\n            logger.warn(`Item with key: ${key} you are trying to put into is too big!`);\n            return;\n        }\n        try {\n            // first look into the storage, if it exists, delete it.\n            const val = await this.getStorage().getItem(prefixedKey);\n            if (val) {\n                await this.removeCacheItem(prefixedKey, JSON.parse(val).byteSize);\n            }\n            // check whether the cache is full\n            if (await this.isCacheFull(item.byteSize)) {\n                const validKeys = await this.clearInvalidAndGetRemainingKeys();\n                if (await this.isCacheFull(item.byteSize)) {\n                    const sizeToPop = await this.sizeToPop(item.byteSize);\n                    await this.popOutItems(validKeys, sizeToPop);\n                }\n            }\n            // put item in the cache\n            return this.setCacheItem(prefixedKey, item);\n        }\n        catch (e) {\n            logger.warn(`setItem failed! ${e}`);\n        }\n    }\n    /**\n     * Get item from cache. It will return null if item doesnâ€™t exist or it has been expired.\n     * If you specified callback function in the options,\n     * then the function will be executed if no such item in the cache\n     * and finally put the return value into cache.\n     * Please make sure the callback function will return the value you want to put into the cache.\n     * The cache will abort output a warning:\n     * If the key is invalid\n     * If error happened with AsyncStorage\n     *\n     * @param {String} key - the key of the item\n     * @param {Object} [options] - the options of callback function\n     *\n     * @return {Promise} - return a promise resolves to be the value of the item\n     */\n    async getItem(key, options) {\n        logger.debug(`Get item: key is ${key} with options ${options}`);\n        let cached;\n        if (!key || key === constants_1.currentSizeKey) {\n            logger.warn(`Invalid key: should not be empty or reserved key: '${constants_1.currentSizeKey}'`);\n            return null;\n        }\n        const prefixedKey = `${this.config.keyPrefix}${key}`;\n        try {\n            cached = await this.getStorage().getItem(prefixedKey);\n            if (cached != null) {\n                if (await this.isExpired(prefixedKey)) {\n                    // if expired, remove that item and return null\n                    await this.removeCacheItem(prefixedKey, JSON.parse(cached).byteSize);\n                }\n                else {\n                    // if not expired, update its visitedTime and return the value\n                    const item = await this.updateVisitedTime(JSON.parse(cached), prefixedKey);\n                    return item.data;\n                }\n            }\n            if (options?.callback) {\n                const val = options.callback();\n                if (val !== null) {\n                    await this.setItem(key, val, options);\n                }\n                return val;\n            }\n            return null;\n        }\n        catch (e) {\n            logger.warn(`getItem failed! ${e}`);\n            return null;\n        }\n    }\n    /**\n     * remove item from the cache\n     * The cache will abort output a warning:\n     * If error happened with AsyncStorage\n     * @param {String} key - the key of the item\n     * @return {Promise}\n     */\n    async removeItem(key) {\n        logger.debug(`Remove item: key is ${key}`);\n        if (!key || key === constants_1.currentSizeKey) {\n            logger.warn(`Invalid key: should not be empty or reserved key: '${constants_1.currentSizeKey}'`);\n            return;\n        }\n        const prefixedKey = `${this.config.keyPrefix}${key}`;\n        try {\n            const val = await this.getStorage().getItem(prefixedKey);\n            if (val) {\n                await this.removeCacheItem(prefixedKey, JSON.parse(val).byteSize);\n            }\n        }\n        catch (e) {\n            logger.warn(`removeItem failed! ${e}`);\n        }\n    }\n    /**\n     * Return all the keys owned by this cache.\n     * Will return an empty array if error occurred.\n     *\n     * @return {Promise}\n     */\n    async getAllKeys() {\n        try {\n            return await this.getAllCacheKeys();\n        }\n        catch (e) {\n            logger.warn(`getAllkeys failed! ${e}`);\n            return [];\n        }\n    }\n    getStorage() {\n        return this.keyValueStorage;\n    }\n    /**\n     * check whether item is expired\n     *\n     * @param key - the key of the item\n     *\n     * @return true if the item is expired.\n     */\n    async isExpired(key) {\n        const text = await this.getStorage().getItem(key);\n        (0, errorHelpers_1.assert)(text !== null, errorHelpers_1.CacheErrorCode.NoCacheItem, `Key: ${key}`);\n        const item = JSON.parse(text);\n        if ((0, utils_1.getCurrentTime)() >= item.expires) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * delete item from cache\n     *\n     * @param prefixedKey - the key of the item\n     * @param size - optional, the byte size of the item\n     */\n    async removeCacheItem(prefixedKey, size) {\n        const item = await this.getStorage().getItem(prefixedKey);\n        (0, errorHelpers_1.assert)(item !== null, errorHelpers_1.CacheErrorCode.NoCacheItem, `Key: ${prefixedKey}`);\n        const itemSize = size ?? JSON.parse(item).byteSize;\n        // first try to update the current size of the cache\n        await this.decreaseCurrentSizeInBytes(itemSize);\n        // try to remove the item from cache\n        try {\n            await this.getStorage().removeItem(prefixedKey);\n        }\n        catch (removeItemError) {\n            // if some error happened, we need to rollback the current size\n            await this.increaseCurrentSizeInBytes(itemSize);\n            logger.error(`Failed to remove item: ${removeItemError}`);\n        }\n    }\n    /**\n     * produce a JSON object with meta-data and data value\n     * @param value - the value of the item\n     * @param options - optional, the specified meta-data\n     *\n     * @return - the item which has the meta-data and the value\n     */\n    fillCacheItem(key, value, options) {\n        const item = {\n            key,\n            data: value,\n            timestamp: (0, utils_1.getCurrentTime)(),\n            visitedTime: (0, utils_1.getCurrentTime)(),\n            priority: options.priority ?? 0,\n            expires: options.expires ?? 0,\n            type: typeof value,\n            byteSize: 0,\n        };\n        // calculate byte size\n        item.byteSize = (0, utils_1.getByteLength)(JSON.stringify(item));\n        // re-calculate using cache item with updated byteSize property\n        item.byteSize = (0, utils_1.getByteLength)(JSON.stringify(item));\n        return item;\n    }\n    sanitizeConfig() {\n        if (this.config.itemMaxSize > this.config.capacityInBytes) {\n            logger.error('Invalid parameter: itemMaxSize. It should be smaller than capacityInBytes. Setting back to default.');\n            this.config.itemMaxSize = constants_1.defaultConfig.itemMaxSize;\n        }\n        if (this.config.defaultPriority > 5 || this.config.defaultPriority < 1) {\n            logger.error('Invalid parameter: defaultPriority. It should be between 1 and 5. Setting back to default.');\n            this.config.defaultPriority = constants_1.defaultConfig.defaultPriority;\n        }\n        if (Number(this.config.warningThreshold) > 1 ||\n            Number(this.config.warningThreshold) < 0) {\n            logger.error('Invalid parameter: warningThreshold. It should be between 0 and 1. Setting back to default.');\n            this.config.warningThreshold = constants_1.defaultConfig.warningThreshold;\n        }\n        // Set 5MB limit\n        const cacheLimit = 5 * 1024 * 1024;\n        if (this.config.capacityInBytes > cacheLimit) {\n            logger.error('Cache Capacity should be less than 5MB. Setting back to default. Setting back to default.');\n            this.config.capacityInBytes = constants_1.defaultConfig.capacityInBytes;\n        }\n    }\n    /**\n     * increase current size of the cache\n     *\n     * @param amount - the amount of the cache szie which need to be increased\n     */\n    async increaseCurrentSizeInBytes(amount) {\n        const size = await this.getCurrentCacheSize();\n        await this.getStorage().setItem((0, utils_1.getCurrentSizeKey)(this.config.keyPrefix), (size + amount).toString());\n    }\n    /**\n     * decrease current size of the cache\n     *\n     * @param amount - the amount of the cache size which needs to be decreased\n     */\n    async decreaseCurrentSizeInBytes(amount) {\n        const size = await this.getCurrentCacheSize();\n        await this.getStorage().setItem((0, utils_1.getCurrentSizeKey)(this.config.keyPrefix), (size - amount).toString());\n    }\n    /**\n     * update the visited time if item has been visited\n     *\n     * @param item - the item which need to be updated\n     * @param prefixedKey - the key of the item\n     *\n     * @return the updated item\n     */\n    async updateVisitedTime(item, prefixedKey) {\n        item.visitedTime = (0, utils_1.getCurrentTime)();\n        await this.getStorage().setItem(prefixedKey, JSON.stringify(item));\n        return item;\n    }\n    /**\n     * put item into cache\n     *\n     * @param prefixedKey - the key of the item\n     * @param itemData - the value of the item\n     * @param itemSizeInBytes - the byte size of the item\n     */\n    async setCacheItem(prefixedKey, item) {\n        // first try to update the current size of the cache.\n        await this.increaseCurrentSizeInBytes(item.byteSize);\n        // try to add the item into cache\n        try {\n            await this.getStorage().setItem(prefixedKey, JSON.stringify(item));\n        }\n        catch (setItemErr) {\n            // if some error happened, we need to rollback the current size\n            await this.decreaseCurrentSizeInBytes(item.byteSize);\n            logger.error(`Failed to set item ${setItemErr}`);\n        }\n    }\n    /**\n     * total space needed when poping out items\n     *\n     * @param itemSize\n     *\n     * @return total space needed\n     */\n    async sizeToPop(itemSize) {\n        const cur = await this.getCurrentCacheSize();\n        const spaceItemNeed = cur + itemSize - this.config.capacityInBytes;\n        const cacheThresholdSpace = (1 - this.config.warningThreshold) * this.config.capacityInBytes;\n        return spaceItemNeed > cacheThresholdSpace\n            ? spaceItemNeed\n            : cacheThresholdSpace;\n    }\n    /**\n     * see whether cache is full\n     *\n     * @param itemSize\n     *\n     * @return true if cache is full\n     */\n    async isCacheFull(itemSize) {\n        const cur = await this.getCurrentCacheSize();\n        return itemSize + cur > this.config.capacityInBytes;\n    }\n    /**\n     * get all the items we have, sort them by their priority,\n     * if priority is same, sort them by their last visited time\n     * pop out items from the low priority (5 is the lowest)\n     * @private\n     * @param keys - all the keys in this cache\n     * @param sizeToPop - the total size of the items which needed to be poped out\n     */\n    async popOutItems(keys, sizeToPop) {\n        const items = [];\n        let remainedSize = sizeToPop;\n        for (const key of keys) {\n            const val = await this.getStorage().getItem(key);\n            if (val != null) {\n                const item = JSON.parse(val);\n                items.push(item);\n            }\n        }\n        // first compare priority\n        // then compare visited time\n        items.sort((a, b) => {\n            if (a.priority > b.priority) {\n                return -1;\n            }\n            else if (a.priority < b.priority) {\n                return 1;\n            }\n            else {\n                if (a.visitedTime < b.visitedTime) {\n                    return -1;\n                }\n                else\n                    return 1;\n            }\n        });\n        for (const item of items) {\n            // pop out items until we have enough room for new item\n            await this.removeCacheItem(item.key, item.byteSize);\n            remainedSize -= item.byteSize;\n            if (remainedSize <= 0) {\n                return;\n            }\n        }\n    }\n    /**\n     * Scan the storage and combine the following operations for efficiency\n     *   1. Clear out all expired keys owned by this cache, not including the size key.\n     *   2. Return the remaining keys.\n     *\n     * @return The remaining valid keys\n     */\n    async clearInvalidAndGetRemainingKeys() {\n        const remainingKeys = [];\n        const keys = await this.getAllCacheKeys({\n            omitSizeKey: true,\n        });\n        for (const key of keys) {\n            if (await this.isExpired(key)) {\n                await this.removeCacheItem(key);\n            }\n            else {\n                remainingKeys.push(key);\n            }\n        }\n        return remainingKeys;\n    }\n    /**\n     * clear the entire cache\n     * The cache will abort and output a warning if error occurs\n     * @return {Promise}\n     */\n    async clear() {\n        logger.debug(`Clear Cache`);\n        try {\n            const keys = await this.getAllKeys();\n            for (const key of keys) {\n                const prefixedKey = `${this.config.keyPrefix}${key}`;\n                await this.getStorage().removeItem(prefixedKey);\n            }\n        }\n        catch (e) {\n            logger.warn(`clear failed! ${e}`);\n        }\n    }\n}\nexports.StorageCacheCommon = StorageCacheCommon;\n"],"mappings":";;AACA;AACA;AACAA,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEC,KAAK,EAAE;AAAI,CAAE,CAAC;AAC7DD,OAAO,CAACE,kBAAkB,GAAG,MAAM;AACnC,MAAMC,QAAQ,GAAGC,OAAO,CAAC,WAAW,CAAC;AACrC,MAAMC,WAAW,GAAGD,OAAO,CAAC,aAAa,CAAC;AAC1C,MAAME,OAAO,GAAGF,OAAO,CAAC,SAAS,CAAC;AAClC,MAAMG,cAAc,GAAGH,OAAO,CAAC,sBAAsB,CAAC;AACtD,MAAMI,MAAM,GAAG,IAAIL,QAAQ,CAACM,aAAa,CAAC,cAAc,CAAC;AACzD;AACA;AACA;AACA;AACA,MAAMP,kBAAkB,CAAC;EACzB;AACA;AACA;AACA;AACA;EACIQ,WAAWA,CAAC;IAAEC,MAAM;IAAEC;EAAe,CAAG,EAAE;IACtC,IAAI,CAACD,MAAM,GAAG;MACV,GAAGN,WAAW,CAACQ,aAAa;MAC5B,GAAGF;IACf,CAAS;IACD,IAAI,CAACC,eAAe,GAAGA,eAAe;IACtC,IAAI,CAACE,cAAc,EAAE;EAC7B;EACIC,aAAaA,CAAA,EAAG;IACZ,OAAO,OAAO;EACtB;EACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIC,SAASA,CAACL,MAAM,EAAE;IACd,IAAIA,MAAM,EAAE;MACR,IAAIA,MAAM,CAACM,SAAS,EAAE;QAClBT,MAAM,CAACU,IAAI,CAAC,mEAAmE,CAAC;MAChG;MACY,IAAI,CAACP,MAAM,GAAG;QACV,GAAG,IAAI,CAACA,MAAM;QACd,GAAGA;MACnB,CAAa;IACb;IACQ,IAAI,CAACG,cAAc,EAAE;IACrB,OAAO,IAAI,CAACH,MAAM;EAC1B;EACA;AACA;AACA;AACA;EACI,MAAMQ,mBAAmBA,CAAA,EAAG;IACxB,IAAIC,IAAI,GAAG,MAAM,IAAI,CAACC,UAAU,EAAE,CAACC,OAAO,CAAC,IAAIhB,OAAO,CAACiB,iBAAiB,EAAE,IAAI,CAACZ,MAAM,CAACM,SAAS,CAAC,CAAC;IACjG,IAAI,CAACG,IAAI,EAAE;MACP,MAAM,IAAI,CAACC,UAAU,EAAE,CAACG,OAAO,CAAC,IAAIlB,OAAO,CAACiB,iBAAiB,EAAE,IAAI,CAACZ,MAAM,CAACM,SAAS,CAAC,EAAE,GAAG,CAAC;MAC3FG,IAAI,GAAG,GAAG;IACtB;IACQ,OAAOK,MAAM,CAACL,IAAI,CAAC;EAC3B;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMI,OAAOA,CAACE,GAAG,EAAEzB,KAAK,EAAE0B,OAAO,EAAE;IAC/BnB,MAAM,CAACoB,KAAK,CAAC,oBAAoBF,GAAG,cAAczB,KAAK,kBAAkB0B,OAAO,EAAE,CAAC;IACnF,IAAI,CAACD,GAAG,IAAIA,GAAG,KAAKrB,WAAW,CAACwB,cAAc,EAAE;MAC5CrB,MAAM,CAACU,IAAI,CAAC,sDAAsDb,WAAW,CAACwB,cAAc,GAAG,CAAC;MAChG;IACZ;IACQ,IAAI,OAAO5B,KAAK,KAAK,WAAW,EAAE;MAC9BO,MAAM,CAACU,IAAI,CAAC,4CAA4C,CAAC;MACzD;IACZ;IACQ,MAAMY,gBAAgB,GAAG;MACrBC,QAAQ,EAAEJ,OAAO,EAAEI,QAAQ,KAAKC,SAAA,GAC1BL,OAAO,CAACI,QAAA,GACR,IAAI,CAACpB,MAAM,CAACsB,eAAe;MACjCC,OAAO,EAAEP,OAAO,EAAEO,OAAO,KAAKF,SAAA,GACxBL,OAAO,CAACO,OAAA,GACR,IAAI,CAACvB,MAAM,CAACwB,UAAU,GAAG,IAAI7B,OAAO,CAAC8B,cAAc;IACrE,CAAS;IACD,IAAIN,gBAAgB,CAACC,QAAQ,GAAG,CAAC,IAAID,gBAAgB,CAACC,QAAQ,GAAG,CAAC,EAAE;MAChEvB,MAAM,CAACU,IAAI,CAAC,+EAA+E,CAAC;MAC5F;IACZ;IACQ,MAAMmB,WAAW,GAAG,GAAG,IAAI,CAAC1B,MAAM,CAACM,SAAS,GAAGS,GAAG,EAAE;IACpD,MAAMY,IAAI,GAAG,IAAI,CAACC,aAAa,CAACF,WAAW,EAAEpC,KAAK,EAAE6B,gBAAgB,CAAC;IAC7E;IACQ,IAAIQ,IAAI,CAACE,QAAQ,GAAG,IAAI,CAAC7B,MAAM,CAAC8B,WAAW,EAAE;MACzCjC,MAAM,CAACU,IAAI,CAAC,kBAAkBQ,GAAG,yCAAyC,CAAC;MAC3E;IACZ;IACQ,IAAI;MACZ;MACY,MAAMgB,GAAG,GAAG,MAAM,IAAI,CAACrB,UAAU,EAAE,CAACC,OAAO,CAACe,WAAW,CAAC;MACxD,IAAIK,GAAG,EAAE;QACL,MAAM,IAAI,CAACC,eAAe,CAACN,WAAW,EAAEO,IAAI,CAACC,KAAK,CAACH,GAAG,CAAC,CAACF,QAAQ,CAAC;MACjF;MACA;MACY,IAAI,MAAM,IAAI,CAACM,WAAW,CAACR,IAAI,CAACE,QAAQ,CAAC,EAAE;QACvC,MAAMO,SAAS,GAAG,MAAM,IAAI,CAACC,+BAA+B,EAAE;QAC9D,IAAI,MAAM,IAAI,CAACF,WAAW,CAACR,IAAI,CAACE,QAAQ,CAAC,EAAE;UACvC,MAAMS,SAAS,GAAG,MAAM,IAAI,CAACA,SAAS,CAACX,IAAI,CAACE,QAAQ,CAAC;UACrD,MAAM,IAAI,CAACU,WAAW,CAACH,SAAS,EAAEE,SAAS,CAAC;QAChE;MACA;MACA;MACY,OAAO,IAAI,CAACE,YAAY,CAACd,WAAW,EAAEC,IAAI,CAAC;IACvD,EACQ,OAAOc,CAAC,EAAE;MACN5C,MAAM,CAACU,IAAI,CAAC,mBAAmBkC,CAAC,EAAE,CAAC;IAC/C;EACA;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAM9B,OAAOA,CAACI,GAAG,EAAEC,OAAO,EAAE;IACxBnB,MAAM,CAACoB,KAAK,CAAC,oBAAoBF,GAAG,iBAAiBC,OAAO,EAAE,CAAC;IAC/D,IAAI0B,MAAM;IACV,IAAI,CAAC3B,GAAG,IAAIA,GAAG,KAAKrB,WAAW,CAACwB,cAAc,EAAE;MAC5CrB,MAAM,CAACU,IAAI,CAAC,sDAAsDb,WAAW,CAACwB,cAAc,GAAG,CAAC;MAChG,OAAO,IAAI;IACvB;IACQ,MAAMQ,WAAW,GAAG,GAAG,IAAI,CAAC1B,MAAM,CAACM,SAAS,GAAGS,GAAG,EAAE;IACpD,IAAI;MACA2B,MAAM,GAAG,MAAM,IAAI,CAAChC,UAAU,EAAE,CAACC,OAAO,CAACe,WAAW,CAAC;MACrD,IAAIgB,MAAM,IAAI,IAAI,EAAE;QAChB,IAAI,MAAM,IAAI,CAACC,SAAS,CAACjB,WAAW,CAAC,EAAE;UACvD;UACoB,MAAM,IAAI,CAACM,eAAe,CAACN,WAAW,EAAEO,IAAI,CAACC,KAAK,CAACQ,MAAM,CAAC,CAACb,QAAQ,CAAC;QACxF,OACqB;UACrB;UACoB,MAAMF,IAAI,GAAG,MAAM,IAAI,CAACiB,iBAAiB,CAACX,IAAI,CAACC,KAAK,CAACQ,MAAM,CAAC,EAAEhB,WAAW,CAAC;UAC1E,OAAOC,IAAI,CAACkB,IAAI;QACpC;MACA;MACY,IAAI7B,OAAO,EAAE8B,QAAQ,EAAE;QACnB,MAAMf,GAAG,GAAGf,OAAO,CAAC8B,QAAQ,EAAE;QAC9B,IAAIf,GAAG,KAAK,IAAI,EAAE;UACd,MAAM,IAAI,CAAClB,OAAO,CAACE,GAAG,EAAEgB,GAAG,EAAEf,OAAO,CAAC;QACzD;QACgB,OAAOe,GAAG;MAC1B;MACY,OAAO,IAAI;IACvB,EACQ,OAAOU,CAAC,EAAE;MACN5C,MAAM,CAACU,IAAI,CAAC,mBAAmBkC,CAAC,EAAE,CAAC;MACnC,OAAO,IAAI;IACvB;EACA;EACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMM,UAAUA,CAAChC,GAAG,EAAE;IAClBlB,MAAM,CAACoB,KAAK,CAAC,uBAAuBF,GAAG,EAAE,CAAC;IAC1C,IAAI,CAACA,GAAG,IAAIA,GAAG,KAAKrB,WAAW,CAACwB,cAAc,EAAE;MAC5CrB,MAAM,CAACU,IAAI,CAAC,sDAAsDb,WAAW,CAACwB,cAAc,GAAG,CAAC;MAChG;IACZ;IACQ,MAAMQ,WAAW,GAAG,GAAG,IAAI,CAAC1B,MAAM,CAACM,SAAS,GAAGS,GAAG,EAAE;IACpD,IAAI;MACA,MAAMgB,GAAG,GAAG,MAAM,IAAI,CAACrB,UAAU,EAAE,CAACC,OAAO,CAACe,WAAW,CAAC;MACxD,IAAIK,GAAG,EAAE;QACL,MAAM,IAAI,CAACC,eAAe,CAACN,WAAW,EAAEO,IAAI,CAACC,KAAK,CAACH,GAAG,CAAC,CAACF,QAAQ,CAAC;MACjF;IACA,EACQ,OAAOY,CAAC,EAAE;MACN5C,MAAM,CAACU,IAAI,CAAC,sBAAsBkC,CAAC,EAAE,CAAC;IAClD;EACA;EACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMO,UAAUA,CAAA,EAAG;IACf,IAAI;MACA,OAAO,MAAM,IAAI,CAACC,eAAe,EAAE;IAC/C,EACQ,OAAOR,CAAC,EAAE;MACN5C,MAAM,CAACU,IAAI,CAAC,sBAAsBkC,CAAC,EAAE,CAAC;MACtC,OAAO,EAAE;IACrB;EACA;EACI/B,UAAUA,CAAA,EAAG;IACT,OAAO,IAAI,CAACT,eAAe;EACnC;EACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAM0C,SAASA,CAAC5B,GAAG,EAAE;IACjB,MAAMmC,IAAI,GAAG,MAAM,IAAI,CAACxC,UAAU,EAAE,CAACC,OAAO,CAACI,GAAG,CAAC;IACjD,IAAInB,cAAc,CAACuD,MAAM,EAAED,IAAI,KAAK,IAAI,EAAEtD,cAAc,CAACwD,cAAc,CAACC,WAAW,EAAE,QAAQtC,GAAG,EAAE,CAAC;IACnG,MAAMY,IAAI,GAAGM,IAAI,CAACC,KAAK,CAACgB,IAAI,CAAC;IAC7B,IAAI,IAAIvD,OAAO,CAAC8B,cAAc,GAAG,IAAIE,IAAI,CAACJ,OAAO,EAAE;MAC/C,OAAO,IAAI;IACvB;IACQ,OAAO,KAAK;EACpB;EACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMS,eAAeA,CAACN,WAAW,EAAEjB,IAAI,EAAE;IACrC,MAAMkB,IAAI,GAAG,MAAM,IAAI,CAACjB,UAAU,EAAE,CAACC,OAAO,CAACe,WAAW,CAAC;IACzD,IAAI9B,cAAc,CAACuD,MAAM,EAAExB,IAAI,KAAK,IAAI,EAAE/B,cAAc,CAACwD,cAAc,CAACC,WAAW,EAAE,QAAQ3B,WAAW,EAAE,CAAC;IAC3G,MAAM4B,QAAQ,GAAG7C,IAAI,IAAIwB,IAAI,CAACC,KAAK,CAACP,IAAI,CAAC,CAACE,QAAQ;IAC1D;IACQ,MAAM,IAAI,CAAC0B,0BAA0B,CAACD,QAAQ,CAAC;IACvD;IACQ,IAAI;MACA,MAAM,IAAI,CAAC5C,UAAU,EAAE,CAACqC,UAAU,CAACrB,WAAW,CAAC;IAC3D,EACQ,OAAO8B,eAAe,EAAE;MAChC;MACY,MAAM,IAAI,CAACC,0BAA0B,CAACH,QAAQ,CAAC;MAC/CzD,MAAM,CAAC6D,KAAK,CAAC,0BAA0BF,eAAe,EAAE,CAAC;IACrE;EACA;EACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI5B,aAAaA,CAACb,GAAG,EAAEzB,KAAK,EAAE0B,OAAO,EAAE;IAC/B,MAAMW,IAAI,GAAG;MACTZ,GAAG;MACH8B,IAAI,EAAEvD,KAAK;MACXqE,SAAS,EAAE,IAAIhE,OAAO,CAAC8B,cAAc,GAAG;MACxCmC,WAAW,EAAE,IAAIjE,OAAO,CAAC8B,cAAc,GAAG;MAC1CL,QAAQ,EAAEJ,OAAO,CAACI,QAAQ,IAAI,CAAC;MAC/BG,OAAO,EAAEP,OAAO,CAACO,OAAO,IAAI,CAAC;MAC7BsC,IAAI,EAAE,OAAOvE,KAAK;MAClBuC,QAAQ,EAAE;IACtB,CAAS;IACT;IACQF,IAAI,CAACE,QAAQ,GAAG,IAAIlC,OAAO,CAACmE,aAAa,EAAE7B,IAAI,CAAC8B,SAAS,CAACpC,IAAI,CAAC,CAAC;IACxE;IACQA,IAAI,CAACE,QAAQ,GAAG,IAAIlC,OAAO,CAACmE,aAAa,EAAE7B,IAAI,CAAC8B,SAAS,CAACpC,IAAI,CAAC,CAAC;IAChE,OAAOA,IAAI;EACnB;EACIxB,cAAcA,CAAA,EAAG;IACb,IAAI,IAAI,CAACH,MAAM,CAAC8B,WAAW,GAAG,IAAI,CAAC9B,MAAM,CAACgE,eAAe,EAAE;MACvDnE,MAAM,CAAC6D,KAAK,CAAC,qGAAqG,CAAC;MACnH,IAAI,CAAC1D,MAAM,CAAC8B,WAAW,GAAGpC,WAAW,CAACQ,aAAa,CAAC4B,WAAW;IAC3E;IACQ,IAAI,IAAI,CAAC9B,MAAM,CAACsB,eAAe,GAAG,CAAC,IAAI,IAAI,CAACtB,MAAM,CAACsB,eAAe,GAAG,CAAC,EAAE;MACpEzB,MAAM,CAAC6D,KAAK,CAAC,4FAA4F,CAAC;MAC1G,IAAI,CAAC1D,MAAM,CAACsB,eAAe,GAAG5B,WAAW,CAACQ,aAAa,CAACoB,eAAe;IACnF;IACQ,IAAIR,MAAM,CAAC,IAAI,CAACd,MAAM,CAACiE,gBAAgB,CAAC,GAAG,CAAC,IACxCnD,MAAM,CAAC,IAAI,CAACd,MAAM,CAACiE,gBAAgB,CAAC,GAAG,CAAC,EAAE;MAC1CpE,MAAM,CAAC6D,KAAK,CAAC,6FAA6F,CAAC;MAC3G,IAAI,CAAC1D,MAAM,CAACiE,gBAAgB,GAAGvE,WAAW,CAACQ,aAAa,CAAC+D,gBAAgB;IACrF;IACA;IACQ,MAAMC,UAAU,GAAG,CAAC,GAAG,IAAI,GAAG,IAAI;IAClC,IAAI,IAAI,CAAClE,MAAM,CAACgE,eAAe,GAAGE,UAAU,EAAE;MAC1CrE,MAAM,CAAC6D,KAAK,CAAC,2FAA2F,CAAC;MACzG,IAAI,CAAC1D,MAAM,CAACgE,eAAe,GAAGtE,WAAW,CAACQ,aAAa,CAAC8D,eAAe;IACnF;EACA;EACA;AACA;AACA;AACA;AACA;EACI,MAAMP,0BAA0BA,CAACU,MAAM,EAAE;IACrC,MAAM1D,IAAI,GAAG,MAAM,IAAI,CAACD,mBAAmB,EAAE;IAC7C,MAAM,IAAI,CAACE,UAAU,EAAE,CAACG,OAAO,CAAC,IAAIlB,OAAO,CAACiB,iBAAiB,EAAE,IAAI,CAACZ,MAAM,CAACM,SAAS,CAAC,EAAE,CAACG,IAAI,GAAG0D,MAAM,EAAEC,QAAQ,EAAE,CAAC;EAC1H;EACA;AACA;AACA;AACA;AACA;EACI,MAAMb,0BAA0BA,CAACY,MAAM,EAAE;IACrC,MAAM1D,IAAI,GAAG,MAAM,IAAI,CAACD,mBAAmB,EAAE;IAC7C,MAAM,IAAI,CAACE,UAAU,EAAE,CAACG,OAAO,CAAC,IAAIlB,OAAO,CAACiB,iBAAiB,EAAE,IAAI,CAACZ,MAAM,CAACM,SAAS,CAAC,EAAE,CAACG,IAAI,GAAG0D,MAAM,EAAEC,QAAQ,EAAE,CAAC;EAC1H;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMxB,iBAAiBA,CAACjB,IAAI,EAAED,WAAW,EAAE;IACvCC,IAAI,CAACiC,WAAW,GAAG,IAAIjE,OAAO,CAAC8B,cAAc,GAAG;IAChD,MAAM,IAAI,CAACf,UAAU,EAAE,CAACG,OAAO,CAACa,WAAW,EAAEO,IAAI,CAAC8B,SAAS,CAACpC,IAAI,CAAC,CAAC;IAClE,OAAOA,IAAI;EACnB;EACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMa,YAAYA,CAACd,WAAW,EAAEC,IAAI,EAAE;IAC1C;IACQ,MAAM,IAAI,CAAC8B,0BAA0B,CAAC9B,IAAI,CAACE,QAAQ,CAAC;IAC5D;IACQ,IAAI;MACA,MAAM,IAAI,CAACnB,UAAU,EAAE,CAACG,OAAO,CAACa,WAAW,EAAEO,IAAI,CAAC8B,SAAS,CAACpC,IAAI,CAAC,CAAC;IAC9E,EACQ,OAAO0C,UAAU,EAAE;MAC3B;MACY,MAAM,IAAI,CAACd,0BAA0B,CAAC5B,IAAI,CAACE,QAAQ,CAAC;MACpDhC,MAAM,CAAC6D,KAAK,CAAC,sBAAsBW,UAAU,EAAE,CAAC;IAC5D;EACA;EACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAM/B,SAASA,CAACgB,QAAQ,EAAE;IACtB,MAAMgB,GAAG,GAAG,MAAM,IAAI,CAAC9D,mBAAmB,EAAE;IAC5C,MAAM+D,aAAa,GAAGD,GAAG,GAAGhB,QAAQ,GAAG,IAAI,CAACtD,MAAM,CAACgE,eAAe;IAClE,MAAMQ,mBAAmB,GAAG,CAAC,CAAC,GAAG,IAAI,CAACxE,MAAM,CAACiE,gBAAgB,IAAI,IAAI,CAACjE,MAAM,CAACgE,eAAe;IAC5F,OAAOO,aAAa,GAAGC,mBAAA,GACjBD,aAAA,GACAC,mBAAmB;EACjC;EACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMrC,WAAWA,CAACmB,QAAQ,EAAE;IACxB,MAAMgB,GAAG,GAAG,MAAM,IAAI,CAAC9D,mBAAmB,EAAE;IAC5C,OAAO8C,QAAQ,GAAGgB,GAAG,GAAG,IAAI,CAACtE,MAAM,CAACgE,eAAe;EAC3D;EACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMzB,WAAWA,CAACkC,IAAI,EAAEnC,SAAS,EAAE;IAC/B,MAAMoC,KAAK,GAAG,EAAE;IAChB,IAAIC,YAAY,GAAGrC,SAAS;IAC5B,KAAK,MAAMvB,GAAG,IAAI0D,IAAI,EAAE;MACpB,MAAM1C,GAAG,GAAG,MAAM,IAAI,CAACrB,UAAU,EAAE,CAACC,OAAO,CAACI,GAAG,CAAC;MAChD,IAAIgB,GAAG,IAAI,IAAI,EAAE;QACb,MAAMJ,IAAI,GAAGM,IAAI,CAACC,KAAK,CAACH,GAAG,CAAC;QAC5B2C,KAAK,CAACE,IAAI,CAACjD,IAAI,CAAC;MAChC;IACA;IACA;IACA;IACQ+C,KAAK,CAACG,IAAI,CAAC,CAACC,CAAC,EAAEC,CAAC,KAAK;MACjB,IAAID,CAAC,CAAC1D,QAAQ,GAAG2D,CAAC,CAAC3D,QAAQ,EAAE;QACzB,OAAO,EAAE;MACzB,OACiB,IAAI0D,CAAC,CAAC1D,QAAQ,GAAG2D,CAAC,CAAC3D,QAAQ,EAAE;QAC9B,OAAO,CAAC;MACxB,OACiB;QACD,IAAI0D,CAAC,CAAClB,WAAW,GAAGmB,CAAC,CAACnB,WAAW,EAAE;UAC/B,OAAO,EAAE;QAC7B,OAEoB,OAAO,CAAC;MAC5B;IACA,CAAS,CAAC;IACF,KAAK,MAAMjC,IAAI,IAAI+C,KAAK,EAAE;MAClC;MACY,MAAM,IAAI,CAAC1C,eAAe,CAACL,IAAI,CAACZ,GAAG,EAAEY,IAAI,CAACE,QAAQ,CAAC;MACnD8C,YAAY,IAAIhD,IAAI,CAACE,QAAQ;MAC7B,IAAI8C,YAAY,IAAI,CAAC,EAAE;QACnB;MAChB;IACA;EACA;EACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,MAAMtC,+BAA+BA,CAAA,EAAG;IACpC,MAAM2C,aAAa,GAAG,EAAE;IACxB,MAAMP,IAAI,GAAG,MAAM,IAAI,CAACxB,eAAe,CAAC;MACpCgC,WAAW,EAAE;IACzB,CAAS,CAAC;IACF,KAAK,MAAMlE,GAAG,IAAI0D,IAAI,EAAE;MACpB,IAAI,MAAM,IAAI,CAAC9B,SAAS,CAAC5B,GAAG,CAAC,EAAE;QAC3B,MAAM,IAAI,CAACiB,eAAe,CAACjB,GAAG,CAAC;MAC/C,OACiB;QACDiE,aAAa,CAACJ,IAAI,CAAC7D,GAAG,CAAC;MACvC;IACA;IACQ,OAAOiE,aAAa;EAC5B;EACA;AACA;AACA;AACA;AACA;EACI,MAAME,KAAKA,CAAA,EAAG;IACVrF,MAAM,CAACoB,KAAK,CAAC,aAAa,CAAC;IAC3B,IAAI;MACA,MAAMwD,IAAI,GAAG,MAAM,IAAI,CAACzB,UAAU,EAAE;MACpC,KAAK,MAAMjC,GAAG,IAAI0D,IAAI,EAAE;QACpB,MAAM/C,WAAW,GAAG,GAAG,IAAI,CAAC1B,MAAM,CAACM,SAAS,GAAGS,GAAG,EAAE;QACpD,MAAM,IAAI,CAACL,UAAU,EAAE,CAACqC,UAAU,CAACrB,WAAW,CAAC;MAC/D;IACA,EACQ,OAAOe,CAAC,EAAE;MACN5C,MAAM,CAACU,IAAI,CAAC,iBAAiBkC,CAAC,EAAE,CAAC;IAC7C;EACA;AACA;AACApD,OAAO,CAACE,kBAAkB,GAAGA,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}