{"ast":null,"code":"import { USER_AGENT_HEADER, getAmplifyUserAgent } from '@aws-amplify/core/internals/utils';\nimport { MESSAGE_TYPES, DEFAULT_KEEP_ALIVE_TIMEOUT } from '../constants.mjs';\nimport { AWSWebSocketProvider } from '../AWSWebSocketProvider/index.mjs';\nimport { awsRealTimeHeaderBasedAuth } from '../AWSWebSocketProvider/authHeaders.mjs';\nimport { serializeEvents } from '../../internals/events/utils.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst PROVIDER_NAME = 'AWSAppSyncEventsProvider';\nconst WS_PROTOCOL_NAME = 'aws-appsync-event-ws';\nconst CONNECT_URI = ''; // events does not expect a connect uri\nclass AWSAppSyncEventProvider extends AWSWebSocketProvider {\n  constructor() {\n    super({\n      providerName: PROVIDER_NAME,\n      wsProtocolName: WS_PROTOCOL_NAME,\n      connectUri: CONNECT_URI\n    });\n    this.allowNoSubscriptions = true;\n  }\n  getProviderName() {\n    return PROVIDER_NAME;\n  }\n  async connect(options) {\n    return super.connect(options);\n  }\n  subscribe(options, customUserAgentDetails) {\n    return super.subscribe(options, customUserAgentDetails).pipe();\n  }\n  async publish(options, customUserAgentDetails) {\n    return super.publish(options, customUserAgentDetails);\n  }\n  closeIfNoActiveSubscription() {\n    this._closeSocketIfRequired();\n  }\n  async _prepareSubscriptionPayload({\n    options,\n    subscriptionId,\n    customUserAgentDetails,\n    additionalCustomHeaders,\n    libraryConfigHeaders,\n    publish\n  }) {\n    const {\n      appSyncGraphqlEndpoint,\n      authenticationType,\n      query,\n      apiKey,\n      region,\n      variables\n    } = options;\n    const data = {\n      channel: query,\n      events: variables !== undefined ? serializeEvents(variables) : undefined\n    };\n    const serializedData = JSON.stringify(data);\n    const headers = {\n      ...(await awsRealTimeHeaderBasedAuth({\n        apiKey,\n        appSyncGraphqlEndpoint,\n        authenticationType,\n        payload: serializedData,\n        canonicalUri: '',\n        region,\n        additionalCustomHeaders\n      })),\n      ...libraryConfigHeaders,\n      ...additionalCustomHeaders,\n      [USER_AGENT_HEADER]: getAmplifyUserAgent(customUserAgentDetails)\n    };\n    const subscriptionMessage = {\n      id: subscriptionId,\n      channel: query,\n      events: variables !== undefined ? serializeEvents(variables) : undefined,\n      authorization: {\n        ...headers\n      },\n      payload: {\n        events: variables !== undefined ? serializeEvents(variables) : undefined,\n        channel: query,\n        extensions: {\n          authorization: {\n            ...headers\n          }\n        }\n      },\n      type: publish ? MESSAGE_TYPES.EVENT_PUBLISH : MESSAGE_TYPES.EVENT_SUBSCRIBE\n    };\n    const serializedSubscriptionMessage = JSON.stringify(subscriptionMessage);\n    return serializedSubscriptionMessage;\n  }\n  _handleSubscriptionData(message) {\n    this.logger.debug(`subscription message from AWS AppSync Events: ${message.data}`);\n    const {\n      id = '',\n      event: payload,\n      type\n    } = JSON.parse(String(message.data));\n    const {\n      observer = null,\n      query = '',\n      variables = {}\n    } = this.subscriptionObserverMap.get(id) || {};\n    this.logger.debug({\n      id,\n      observer,\n      query,\n      variables\n    });\n    if (type === MESSAGE_TYPES.DATA && payload) {\n      const deserializedEvent = JSON.parse(payload);\n      if (observer) {\n        observer.next({\n          id,\n          type,\n          event: deserializedEvent\n        });\n      } else {\n        this.logger.debug(`observer not found for id: ${id}`);\n      }\n      return [true, {\n        id,\n        type,\n        payload: deserializedEvent\n      }];\n    }\n    return [false, {\n      id,\n      type,\n      payload\n    }];\n  }\n  _unsubscribeMessage(subscriptionId) {\n    return {\n      id: subscriptionId,\n      type: MESSAGE_TYPES.EVENT_STOP\n    };\n  }\n  _extractConnectionTimeout(data) {\n    const {\n      connectionTimeoutMs = DEFAULT_KEEP_ALIVE_TIMEOUT\n    } = data;\n    return connectionTimeoutMs;\n  }\n  _extractErrorCodeAndType(data) {\n    const {\n      errors: [{\n        errorType = '',\n        errorCode = 0\n      } = {}] = []\n    } = data;\n    return {\n      errorCode,\n      errorType\n    };\n  }\n}\nconst AppSyncEventProvider = new AWSAppSyncEventProvider();\nexport { AWSAppSyncEventProvider, AppSyncEventProvider };","map":{"version":3,"names":["PROVIDER_NAME","WS_PROTOCOL_NAME","CONNECT_URI","AWSAppSyncEventProvider","AWSWebSocketProvider","constructor","providerName","wsProtocolName","connectUri","allowNoSubscriptions","getProviderName","connect","options","subscribe","customUserAgentDetails","pipe","publish","closeIfNoActiveSubscription","_closeSocketIfRequired","_prepareSubscriptionPayload","subscriptionId","additionalCustomHeaders","libraryConfigHeaders","appSyncGraphqlEndpoint","authenticationType","query","apiKey","region","variables","data","channel","events","undefined","serializeEvents","serializedData","JSON","stringify","headers","awsRealTimeHeaderBasedAuth","payload","canonicalUri","USER_AGENT_HEADER","getAmplifyUserAgent","subscriptionMessage","id","authorization","extensions","type","MESSAGE_TYPES","EVENT_PUBLISH","EVENT_SUBSCRIBE","serializedSubscriptionMessage","_handleSubscriptionData","message","logger","debug","event","parse","String","observer","subscriptionObserverMap","get","DATA","deserializedEvent","next","_unsubscribeMessage","EVENT_STOP","_extractConnectionTimeout","connectionTimeoutMs","DEFAULT_KEEP_ALIVE_TIMEOUT","_extractErrorCodeAndType","errors","errorType","errorCode","AppSyncEventProvider"],"sources":["C:\\Users\\vinzl\\workspace\\machicoulis\\daily-image-collector\\node_modules\\@aws-amplify\\api-graphql\\src\\Providers\\AWSAppSyncEventsProvider\\index.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { USER_AGENT_HEADER, getAmplifyUserAgent, } from '@aws-amplify/core/internals/utils';\nimport { DEFAULT_KEEP_ALIVE_TIMEOUT, MESSAGE_TYPES } from '../constants';\nimport { AWSWebSocketProvider } from '../AWSWebSocketProvider';\nimport { awsRealTimeHeaderBasedAuth } from '../AWSWebSocketProvider/authHeaders';\nimport { serializeEvents } from '../../internals/events/utils';\nconst PROVIDER_NAME = 'AWSAppSyncEventsProvider';\nconst WS_PROTOCOL_NAME = 'aws-appsync-event-ws';\nconst CONNECT_URI = ''; // events does not expect a connect uri\nexport class AWSAppSyncEventProvider extends AWSWebSocketProvider {\n    constructor() {\n        super({\n            providerName: PROVIDER_NAME,\n            wsProtocolName: WS_PROTOCOL_NAME,\n            connectUri: CONNECT_URI,\n        });\n        this.allowNoSubscriptions = true;\n    }\n    getProviderName() {\n        return PROVIDER_NAME;\n    }\n    async connect(options) {\n        return super.connect(options);\n    }\n    subscribe(options, customUserAgentDetails) {\n        return super.subscribe(options, customUserAgentDetails).pipe();\n    }\n    async publish(options, customUserAgentDetails) {\n        return super.publish(options, customUserAgentDetails);\n    }\n    closeIfNoActiveSubscription() {\n        this._closeSocketIfRequired();\n    }\n    async _prepareSubscriptionPayload({ options, subscriptionId, customUserAgentDetails, additionalCustomHeaders, libraryConfigHeaders, publish, }) {\n        const { appSyncGraphqlEndpoint, authenticationType, query, apiKey, region, variables, } = options;\n        const data = {\n            channel: query,\n            events: variables !== undefined ? serializeEvents(variables) : undefined,\n        };\n        const serializedData = JSON.stringify(data);\n        const headers = {\n            ...(await awsRealTimeHeaderBasedAuth({\n                apiKey,\n                appSyncGraphqlEndpoint,\n                authenticationType,\n                payload: serializedData,\n                canonicalUri: '',\n                region,\n                additionalCustomHeaders,\n            })),\n            ...libraryConfigHeaders,\n            ...additionalCustomHeaders,\n            [USER_AGENT_HEADER]: getAmplifyUserAgent(customUserAgentDetails),\n        };\n        const subscriptionMessage = {\n            id: subscriptionId,\n            channel: query,\n            events: variables !== undefined ? serializeEvents(variables) : undefined,\n            authorization: {\n                ...headers,\n            },\n            payload: {\n                events: variables !== undefined ? serializeEvents(variables) : undefined,\n                channel: query,\n                extensions: {\n                    authorization: {\n                        ...headers,\n                    },\n                },\n            },\n            type: publish\n                ? MESSAGE_TYPES.EVENT_PUBLISH\n                : MESSAGE_TYPES.EVENT_SUBSCRIBE,\n        };\n        const serializedSubscriptionMessage = JSON.stringify(subscriptionMessage);\n        return serializedSubscriptionMessage;\n    }\n    _handleSubscriptionData(message) {\n        this.logger.debug(`subscription message from AWS AppSync Events: ${message.data}`);\n        const { id = '', event: payload, type, } = JSON.parse(String(message.data));\n        const { observer = null, query = '', variables = {}, } = this.subscriptionObserverMap.get(id) || {};\n        this.logger.debug({ id, observer, query, variables });\n        if (type === MESSAGE_TYPES.DATA && payload) {\n            const deserializedEvent = JSON.parse(payload);\n            if (observer) {\n                observer.next({ id, type, event: deserializedEvent });\n            }\n            else {\n                this.logger.debug(`observer not found for id: ${id}`);\n            }\n            return [true, { id, type, payload: deserializedEvent }];\n        }\n        return [false, { id, type, payload }];\n    }\n    _unsubscribeMessage(subscriptionId) {\n        return {\n            id: subscriptionId,\n            type: MESSAGE_TYPES.EVENT_STOP,\n        };\n    }\n    _extractConnectionTimeout(data) {\n        const { connectionTimeoutMs = DEFAULT_KEEP_ALIVE_TIMEOUT } = data;\n        return connectionTimeoutMs;\n    }\n    _extractErrorCodeAndType(data) {\n        const { errors: [{ errorType = '', errorCode = 0 } = {}] = [] } = data;\n        return { errorCode, errorType };\n    }\n}\nexport const AppSyncEventProvider = new AWSAppSyncEventProvider();\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}