{"ast":null,"code":"import { Amplify } from '@aws-amplify/core';\nimport { amplifyUuid } from '@aws-amplify/core/internals/utils';\nimport { AppSyncEventProvider } from '../../Providers/AWSAppSyncEventsProvider/index.mjs';\nimport { appsyncRequest } from './appsyncRequest.mjs';\nimport { configure, normalizeAuth, serializeEvents } from './utils.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n// Keeps a list of open channels in the websocket\nconst openChannels = new Set();\n/**\n * @experimental API may change in future versions\n *\n * Establish a WebSocket connection to an Events channel\n *\n * @example\n * const channel = await events.connect(\"default/channel\")\n *\n * channel.subscribe({\n *   next: (data) => { console.log(data) },\n *   error: (err) => { console.error(err) },\n * })\n *\n * @example // authMode override\n * const channel = await events.connect(\"default/channel\", { authMode: \"userPool\" })\n *\n * @param channel - channel path; `<namespace>/<channel>`\n * @param options - request overrides: `authMode`, `authToken`\n *\n */\nasync function connect(channel, options) {\n  const providerOptions = configure();\n  providerOptions.authenticationType = normalizeAuth(options?.authMode, providerOptions.authenticationType);\n  providerOptions.apiKey = options?.apiKey || providerOptions.apiKey;\n  providerOptions.authToken = options?.authToken || providerOptions.authToken;\n  await AppSyncEventProvider.connect(providerOptions);\n  const channelId = amplifyUuid();\n  openChannels.add(channelId);\n  let _subscription;\n  const sub = (observer, subOptions) => {\n    if (!openChannels.has(channelId)) {\n      throw new Error('Channel is closed');\n    }\n    const subscribeOptions = {\n      ...providerOptions,\n      query: channel\n    };\n    subscribeOptions.authenticationType = normalizeAuth(subOptions?.authMode, subscribeOptions.authenticationType);\n    subscribeOptions.apiKey = subOptions?.apiKey || subscribeOptions.apiKey;\n    subscribeOptions.authToken = subOptions?.authToken || subscribeOptions.authToken;\n    _subscription = AppSyncEventProvider.subscribe(subscribeOptions).subscribe(observer);\n    return _subscription;\n  };\n  const pub = async (event, pubOptions) => {\n    if (!openChannels.has(channelId)) {\n      throw new Error('Channel is closed');\n    }\n    const publishOptions = {\n      ...providerOptions,\n      query: channel,\n      variables: event\n    };\n    publishOptions.authenticationType = normalizeAuth(pubOptions?.authMode, publishOptions.authenticationType);\n    publishOptions.apiKey = pubOptions?.apiKey || publishOptions.apiKey;\n    publishOptions.authToken = pubOptions?.authToken || publishOptions.authToken;\n    return AppSyncEventProvider.publish(publishOptions);\n  };\n  const close = async () => {\n    _subscription && _subscription.unsubscribe();\n    openChannels.delete(channelId);\n    setTimeout(() => {\n      if (openChannels.size === 0) {\n        AppSyncEventProvider.closeIfNoActiveSubscription();\n      }\n    }, 1000);\n  };\n  return {\n    subscribe: sub,\n    close,\n    publish: pub\n  };\n}\n/**\n * @experimental API may change in future versions\n *\n * Publish events to a channel via HTTP request\n *\n * @example\n * await events.post(\"default/channel\", { some: \"event\" })\n *\n * @example // event batching\n * await events.post(\"default/channel\", [{ some: \"event\" }, { some: \"event2\" }])\n *\n * @example // authMode override\n * await events.post(\"default/channel\", { some: \"event\" }, { authMode: \"userPool\" })\n *\n * @param channel - channel path; `<namespace>/<channel>`\n * @param event - JSON-serializable value or an array of values\n * @param options - request overrides: `authMode`, `authToken`\n *\n * @returns void on success\n * @throws on error\n */\nasync function post(channel, event, options) {\n  const providerOptions = configure();\n  providerOptions.authenticationType = normalizeAuth(options?.authMode, providerOptions.authenticationType);\n  providerOptions.apiKey = options?.apiKey || providerOptions.apiKey;\n  providerOptions.authToken = options?.authToken || providerOptions.authToken;\n  // trailing slash required in publish\n  const normalizedChannelName = channel[0] === '/' ? channel : `/${channel}`;\n  const publishOptions = {\n    ...providerOptions,\n    query: normalizedChannelName,\n    variables: serializeEvents(event)\n  };\n  const abortController = new AbortController();\n  const res = await appsyncRequest(Amplify, publishOptions, {}, abortController);\n  if (res.failed?.length > 0) {\n    return res.failed;\n  }\n}\n/**\n * @experimental API may change in future versions\n *\n * Close WebSocket connection, disconnect listeners and reconnect observers\n *\n * @example\n * await events.closeAll()\n *\n * @returns void on success\n * @throws on error\n */\nasync function closeAll() {\n  await AppSyncEventProvider.close();\n}\nexport { closeAll, connect, post };","map":{"version":3,"names":["openChannels","Set","connect","channel","options","providerOptions","configure","authenticationType","normalizeAuth","authMode","apiKey","authToken","AppSyncEventProvider","channelId","amplifyUuid","add","_subscription","sub","observer","subOptions","has","Error","subscribeOptions","query","subscribe","pub","event","pubOptions","publishOptions","variables","publish","close","unsubscribe","delete","setTimeout","size","closeIfNoActiveSubscription","post","normalizedChannelName","serializeEvents","abortController","AbortController","res","appsyncRequest","Amplify","failed","length","closeAll"],"sources":["C:\\Users\\vinzl\\workspace\\machicoulis\\daily-image-collector\\node_modules\\@aws-amplify\\api-graphql\\src\\internals\\events\\index.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { Amplify } from '@aws-amplify/core';\nimport { amplifyUuid } from '@aws-amplify/core/internals/utils';\nimport { AppSyncEventProvider as eventProvider } from '../../Providers/AWSAppSyncEventsProvider';\nimport { appsyncRequest } from './appsyncRequest';\nimport { configure, normalizeAuth, serializeEvents } from './utils';\n// Keeps a list of open channels in the websocket\nconst openChannels = new Set();\n/**\n * @experimental API may change in future versions\n *\n * Establish a WebSocket connection to an Events channel\n *\n * @example\n * const channel = await events.connect(\"default/channel\")\n *\n * channel.subscribe({\n *   next: (data) => { console.log(data) },\n *   error: (err) => { console.error(err) },\n * })\n *\n * @example // authMode override\n * const channel = await events.connect(\"default/channel\", { authMode: \"userPool\" })\n *\n * @param channel - channel path; `<namespace>/<channel>`\n * @param options - request overrides: `authMode`, `authToken`\n *\n */\nasync function connect(channel, options) {\n    const providerOptions = configure();\n    providerOptions.authenticationType = normalizeAuth(options?.authMode, providerOptions.authenticationType);\n    providerOptions.apiKey = options?.apiKey || providerOptions.apiKey;\n    providerOptions.authToken = options?.authToken || providerOptions.authToken;\n    await eventProvider.connect(providerOptions);\n    const channelId = amplifyUuid();\n    openChannels.add(channelId);\n    let _subscription;\n    const sub = (observer, subOptions) => {\n        if (!openChannels.has(channelId)) {\n            throw new Error('Channel is closed');\n        }\n        const subscribeOptions = { ...providerOptions, query: channel };\n        subscribeOptions.authenticationType = normalizeAuth(subOptions?.authMode, subscribeOptions.authenticationType);\n        subscribeOptions.apiKey = subOptions?.apiKey || subscribeOptions.apiKey;\n        subscribeOptions.authToken =\n            subOptions?.authToken || subscribeOptions.authToken;\n        _subscription = eventProvider\n            .subscribe(subscribeOptions)\n            .subscribe(observer);\n        return _subscription;\n    };\n    const pub = async (event, pubOptions) => {\n        if (!openChannels.has(channelId)) {\n            throw new Error('Channel is closed');\n        }\n        const publishOptions = {\n            ...providerOptions,\n            query: channel,\n            variables: event,\n        };\n        publishOptions.authenticationType = normalizeAuth(pubOptions?.authMode, publishOptions.authenticationType);\n        publishOptions.apiKey = pubOptions?.apiKey || publishOptions.apiKey;\n        publishOptions.authToken =\n            pubOptions?.authToken || publishOptions.authToken;\n        return eventProvider.publish(publishOptions);\n    };\n    const close = async () => {\n        _subscription && _subscription.unsubscribe();\n        openChannels.delete(channelId);\n        setTimeout(() => {\n            if (openChannels.size === 0) {\n                eventProvider.closeIfNoActiveSubscription();\n            }\n        }, 1000);\n    };\n    return {\n        subscribe: sub,\n        close,\n        publish: pub,\n    };\n}\n/**\n * @experimental API may change in future versions\n *\n * Publish events to a channel via HTTP request\n *\n * @example\n * await events.post(\"default/channel\", { some: \"event\" })\n *\n * @example // event batching\n * await events.post(\"default/channel\", [{ some: \"event\" }, { some: \"event2\" }])\n *\n * @example // authMode override\n * await events.post(\"default/channel\", { some: \"event\" }, { authMode: \"userPool\" })\n *\n * @param channel - channel path; `<namespace>/<channel>`\n * @param event - JSON-serializable value or an array of values\n * @param options - request overrides: `authMode`, `authToken`\n *\n * @returns void on success\n * @throws on error\n */\nasync function post(channel, event, options) {\n    const providerOptions = configure();\n    providerOptions.authenticationType = normalizeAuth(options?.authMode, providerOptions.authenticationType);\n    providerOptions.apiKey = options?.apiKey || providerOptions.apiKey;\n    providerOptions.authToken = options?.authToken || providerOptions.authToken;\n    // trailing slash required in publish\n    const normalizedChannelName = channel[0] === '/' ? channel : `/${channel}`;\n    const publishOptions = {\n        ...providerOptions,\n        query: normalizedChannelName,\n        variables: serializeEvents(event),\n    };\n    const abortController = new AbortController();\n    const res = await appsyncRequest(Amplify, publishOptions, {}, abortController);\n    if (res.failed?.length > 0) {\n        return res.failed;\n    }\n}\n/**\n * @experimental API may change in future versions\n *\n * Close WebSocket connection, disconnect listeners and reconnect observers\n *\n * @example\n * await events.closeAll()\n *\n * @returns void on success\n * @throws on error\n */\nasync function closeAll() {\n    await eventProvider.close();\n}\nexport { connect, post, closeAll };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}