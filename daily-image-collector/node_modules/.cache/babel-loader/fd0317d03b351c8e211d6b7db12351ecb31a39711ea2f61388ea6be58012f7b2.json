{"ast":null,"code":"import { StorageAction } from '@aws-amplify/core/internals/utils';\nimport '@smithy/md5-js';\nimport '@aws-amplify/core/internals/aws-client-utils';\nimport '../../utils/client/runtime/s3TransferHandler/fetch.mjs';\nimport 'fast-xml-parser';\nimport '../../utils/client/runtime/s3TransferHandler/xhr.mjs';\nimport 'buffer';\nimport { resolveS3ConfigAndInput } from '../../utils/resolveS3ConfigAndInput.mjs';\nimport { assertValidationError } from '../../../../errors/utils/assertValidationError.mjs';\nimport { StorageValidationErrorCode } from '../../../../errors/types/validation.mjs';\nimport { logger } from '../../../../utils/logger.mjs';\nimport { validateBucketOwnerID } from '../../utils/validateBucketOwnerID.mjs';\nimport { validateStorageOperationInput } from '../../utils/validateStorageOperationInput.mjs';\nimport { isInputWithPath } from '../../utils/isInputWithPath.mjs';\nimport '../../utils/client/s3data/base.mjs';\nimport '../../utils/client/s3data/getObject.mjs';\nimport '../../utils/client/s3data/listObjectsV2.mjs';\nimport '../../utils/client/s3data/putObject.mjs';\nimport '../../utils/client/s3data/createMultipartUpload.mjs';\nimport '../../utils/client/s3data/uploadPart.mjs';\nimport '../../utils/client/s3data/completeMultipartUpload.mjs';\nimport '../../utils/client/s3data/listParts.mjs';\nimport '../../utils/client/s3data/abortMultipartUpload.mjs';\nimport { copyObject } from '../../utils/client/s3data/copyObject.mjs';\nimport '../../utils/client/s3data/headObject.mjs';\nimport '../../utils/client/s3data/deleteObject.mjs';\nimport { getStorageUserAgentValue } from '../../utils/userAgent.mjs';\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nconst isCopyInputWithPath = input => isInputWithPath(input.source);\nconst storageBucketAssertion = (sourceBucket, destBucket) => {\n  /**  For multi-bucket, both source and destination bucket needs to be passed in\n   *   or both can be undefined and we fallback to singleton's default value\n   */\n  assertValidationError(\n  // Both src & dest bucket option is present is acceptable\n  sourceBucket !== undefined && destBucket !== undefined ||\n  // or both are undefined is also acceptable\n  !destBucket && !sourceBucket, StorageValidationErrorCode.InvalidCopyOperationStorageBucket);\n};\nconst copy = async (amplify, input) => {\n  return isCopyInputWithPath(input) ? copyWithPath(amplify, input) : copyWithKey(amplify, input);\n};\nconst copyWithPath = async (amplify, input) => {\n  const {\n    source,\n    destination\n  } = input;\n  storageBucketAssertion(source.bucket, destination.bucket);\n  const {\n    bucket: sourceBucket\n  } = await resolveS3ConfigAndInput(amplify, {\n    path: input.source.path,\n    options: {\n      locationCredentialsProvider: input.options?.locationCredentialsProvider,\n      ...input.source\n    }\n  });\n  // The bucket, region, credentials of s3 client are resolved from destination.\n  // Whereas the source bucket and path are a input parameter of S3 copy operation.\n  const {\n    s3Config,\n    bucket: destBucket,\n    identityId\n  } = await resolveS3ConfigAndInput(amplify, {\n    path: input.destination.path,\n    options: {\n      locationCredentialsProvider: input.options?.locationCredentialsProvider,\n      customEndpoint: input.options?.customEndpoint,\n      ...input.destination\n    }\n  }); // resolveS3ConfigAndInput does not make extra API calls or storage access if called repeatedly.\n  assertValidationError(!!source.path, StorageValidationErrorCode.NoSourcePath);\n  assertValidationError(!!destination.path, StorageValidationErrorCode.NoDestinationPath);\n  const {\n    objectKey: sourcePath\n  } = validateStorageOperationInput(source, identityId);\n  const {\n    objectKey: destinationPath\n  } = validateStorageOperationInput(destination, identityId);\n  validateBucketOwnerID(source.expectedBucketOwner);\n  validateBucketOwnerID(destination.expectedBucketOwner);\n  const finalCopySource = `${sourceBucket}/${sourcePath}`;\n  const finalCopyDestination = destinationPath;\n  logger.debug(`copying \"${finalCopySource}\" to \"${finalCopyDestination}\".`);\n  await serviceCopy({\n    source: finalCopySource,\n    destination: finalCopyDestination,\n    bucket: destBucket,\n    s3Config,\n    notModifiedSince: input.source.notModifiedSince,\n    eTag: input.source.eTag,\n    expectedSourceBucketOwner: input.source?.expectedBucketOwner,\n    expectedBucketOwner: input.destination?.expectedBucketOwner\n  });\n  return {\n    path: finalCopyDestination\n  };\n};\n/** @deprecated Use {@link copyWithPath} instead. */\nconst copyWithKey = async (amplify, input) => {\n  const {\n    source,\n    destination\n  } = input;\n  storageBucketAssertion(source.bucket, destination.bucket);\n  assertValidationError(!!source.key, StorageValidationErrorCode.NoSourceKey);\n  assertValidationError(!!destination.key, StorageValidationErrorCode.NoDestinationKey);\n  validateBucketOwnerID(source.expectedBucketOwner);\n  validateBucketOwnerID(destination.expectedBucketOwner);\n  const {\n    bucket: sourceBucket,\n    keyPrefix: sourceKeyPrefix\n  } = await resolveS3ConfigAndInput(amplify, {\n    ...input,\n    options: {\n      // @ts-expect-error: 'options' does not exist on type 'CopyInput'. In case of JS users set the location\n      // credentials provider option, resolveS3ConfigAndInput will throw validation error.\n      locationCredentialsProvider: input.options?.locationCredentialsProvider,\n      ...input.source\n    }\n  });\n  // The bucket, region, credentials of s3 client are resolved from destination.\n  // Whereas the source bucket and path are a input parameter of S3 copy operation.\n  const {\n    s3Config,\n    bucket: destBucket,\n    keyPrefix: destinationKeyPrefix\n  } = await resolveS3ConfigAndInput(amplify, {\n    ...input,\n    options: {\n      // @ts-expect-error: 'options' does not exist on type 'CopyInput'. In case of JS users set the location\n      // credentials provider option, resolveS3ConfigAndInput will throw validation error.\n      locationCredentialsProvider: input.options?.locationCredentialsProvider,\n      ...input.destination\n    }\n  }); // resolveS3ConfigAndInput does not make extra API calls or storage access if called repeatedly.\n  // TODO(ashwinkumar6) V6-logger: warn `You may copy files from another user if the source level is \"protected\", currently it's ${srcLevel}`\n  const finalCopySource = `${sourceBucket}/${sourceKeyPrefix}${source.key}`;\n  const finalCopyDestination = `${destinationKeyPrefix}${destination.key}`;\n  logger.debug(`copying \"${finalCopySource}\" to \"${finalCopyDestination}\".`);\n  await serviceCopy({\n    source: finalCopySource,\n    destination: finalCopyDestination,\n    bucket: destBucket,\n    s3Config,\n    notModifiedSince: input.source.notModifiedSince,\n    eTag: input.source.eTag,\n    expectedSourceBucketOwner: input.source?.expectedBucketOwner,\n    expectedBucketOwner: input.destination?.expectedBucketOwner\n  });\n  return {\n    key: destination.key\n  };\n};\nconst serviceCopy = async ({\n  source,\n  destination,\n  bucket,\n  s3Config,\n  notModifiedSince,\n  eTag,\n  expectedSourceBucketOwner,\n  expectedBucketOwner\n}) => {\n  await copyObject({\n    ...s3Config,\n    userAgentValue: getStorageUserAgentValue(StorageAction.Copy)\n  }, {\n    Bucket: bucket,\n    CopySource: source,\n    Key: destination,\n    MetadataDirective: 'COPY',\n    // Copies over metadata like contentType as well\n    CopySourceIfMatch: eTag,\n    CopySourceIfUnmodifiedSince: notModifiedSince,\n    ExpectedSourceBucketOwner: expectedSourceBucketOwner,\n    ExpectedBucketOwner: expectedBucketOwner\n  });\n};\nexport { copy, copyWithKey };","map":{"version":3,"names":["isCopyInputWithPath","input","isInputWithPath","source","storageBucketAssertion","sourceBucket","destBucket","assertValidationError","undefined","StorageValidationErrorCode","InvalidCopyOperationStorageBucket","copy","amplify","copyWithPath","copyWithKey","destination","bucket","resolveS3ConfigAndInput","path","options","locationCredentialsProvider","s3Config","identityId","customEndpoint","NoSourcePath","NoDestinationPath","objectKey","sourcePath","validateStorageOperationInput","destinationPath","validateBucketOwnerID","expectedBucketOwner","finalCopySource","finalCopyDestination","logger","debug","serviceCopy","notModifiedSince","eTag","expectedSourceBucketOwner","key","NoSourceKey","NoDestinationKey","keyPrefix","sourceKeyPrefix","destinationKeyPrefix","copyObject","userAgentValue","getStorageUserAgentValue","StorageAction","Copy","Bucket","CopySource","Key","MetadataDirective","CopySourceIfMatch","CopySourceIfUnmodifiedSince","ExpectedSourceBucketOwner","ExpectedBucketOwner"],"sources":["C:\\Users\\vinzl\\workspace\\machicoulis\\daily-image-collector\\node_modules\\@aws-amplify\\storage\\src\\providers\\s3\\apis\\internal\\copy.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { StorageAction } from '@aws-amplify/core/internals/utils';\nimport { isInputWithPath, resolveS3ConfigAndInput, validateBucketOwnerID, validateStorageOperationInput, } from '../../utils';\nimport { StorageValidationErrorCode } from '../../../../errors/types/validation';\nimport { assertValidationError } from '../../../../errors/utils/assertValidationError';\nimport { copyObject } from '../../utils/client/s3data';\nimport { getStorageUserAgentValue } from '../../utils/userAgent';\nimport { logger } from '../../../../utils';\nconst isCopyInputWithPath = (input) => isInputWithPath(input.source);\nconst storageBucketAssertion = (sourceBucket, destBucket) => {\n    /**  For multi-bucket, both source and destination bucket needs to be passed in\n     *   or both can be undefined and we fallback to singleton's default value\n     */\n    assertValidationError(\n    // Both src & dest bucket option is present is acceptable\n    (sourceBucket !== undefined && destBucket !== undefined) ||\n        // or both are undefined is also acceptable\n        (!destBucket && !sourceBucket), StorageValidationErrorCode.InvalidCopyOperationStorageBucket);\n};\nexport const copy = async (amplify, input) => {\n    return isCopyInputWithPath(input)\n        ? copyWithPath(amplify, input)\n        : copyWithKey(amplify, input);\n};\nconst copyWithPath = async (amplify, input) => {\n    const { source, destination } = input;\n    storageBucketAssertion(source.bucket, destination.bucket);\n    const { bucket: sourceBucket } = await resolveS3ConfigAndInput(amplify, {\n        path: input.source.path,\n        options: {\n            locationCredentialsProvider: input.options?.locationCredentialsProvider,\n            ...input.source,\n        },\n    });\n    // The bucket, region, credentials of s3 client are resolved from destination.\n    // Whereas the source bucket and path are a input parameter of S3 copy operation.\n    const { s3Config, bucket: destBucket, identityId, } = await resolveS3ConfigAndInput(amplify, {\n        path: input.destination.path,\n        options: {\n            locationCredentialsProvider: input.options?.locationCredentialsProvider,\n            customEndpoint: input.options?.customEndpoint,\n            ...input.destination,\n        },\n    }); // resolveS3ConfigAndInput does not make extra API calls or storage access if called repeatedly.\n    assertValidationError(!!source.path, StorageValidationErrorCode.NoSourcePath);\n    assertValidationError(!!destination.path, StorageValidationErrorCode.NoDestinationPath);\n    const { objectKey: sourcePath } = validateStorageOperationInput(source, identityId);\n    const { objectKey: destinationPath } = validateStorageOperationInput(destination, identityId);\n    validateBucketOwnerID(source.expectedBucketOwner);\n    validateBucketOwnerID(destination.expectedBucketOwner);\n    const finalCopySource = `${sourceBucket}/${sourcePath}`;\n    const finalCopyDestination = destinationPath;\n    logger.debug(`copying \"${finalCopySource}\" to \"${finalCopyDestination}\".`);\n    await serviceCopy({\n        source: finalCopySource,\n        destination: finalCopyDestination,\n        bucket: destBucket,\n        s3Config,\n        notModifiedSince: input.source.notModifiedSince,\n        eTag: input.source.eTag,\n        expectedSourceBucketOwner: input.source?.expectedBucketOwner,\n        expectedBucketOwner: input.destination?.expectedBucketOwner,\n    });\n    return { path: finalCopyDestination };\n};\n/** @deprecated Use {@link copyWithPath} instead. */\nexport const copyWithKey = async (amplify, input) => {\n    const { source, destination } = input;\n    storageBucketAssertion(source.bucket, destination.bucket);\n    assertValidationError(!!source.key, StorageValidationErrorCode.NoSourceKey);\n    assertValidationError(!!destination.key, StorageValidationErrorCode.NoDestinationKey);\n    validateBucketOwnerID(source.expectedBucketOwner);\n    validateBucketOwnerID(destination.expectedBucketOwner);\n    const { bucket: sourceBucket, keyPrefix: sourceKeyPrefix } = await resolveS3ConfigAndInput(amplify, {\n        ...input,\n        options: {\n            // @ts-expect-error: 'options' does not exist on type 'CopyInput'. In case of JS users set the location\n            // credentials provider option, resolveS3ConfigAndInput will throw validation error.\n            locationCredentialsProvider: input.options?.locationCredentialsProvider,\n            ...input.source,\n        },\n    });\n    // The bucket, region, credentials of s3 client are resolved from destination.\n    // Whereas the source bucket and path are a input parameter of S3 copy operation.\n    const { s3Config, bucket: destBucket, keyPrefix: destinationKeyPrefix, } = await resolveS3ConfigAndInput(amplify, {\n        ...input,\n        options: {\n            // @ts-expect-error: 'options' does not exist on type 'CopyInput'. In case of JS users set the location\n            // credentials provider option, resolveS3ConfigAndInput will throw validation error.\n            locationCredentialsProvider: input.options?.locationCredentialsProvider,\n            ...input.destination,\n        },\n    }); // resolveS3ConfigAndInput does not make extra API calls or storage access if called repeatedly.\n    // TODO(ashwinkumar6) V6-logger: warn `You may copy files from another user if the source level is \"protected\", currently it's ${srcLevel}`\n    const finalCopySource = `${sourceBucket}/${sourceKeyPrefix}${source.key}`;\n    const finalCopyDestination = `${destinationKeyPrefix}${destination.key}`;\n    logger.debug(`copying \"${finalCopySource}\" to \"${finalCopyDestination}\".`);\n    await serviceCopy({\n        source: finalCopySource,\n        destination: finalCopyDestination,\n        bucket: destBucket,\n        s3Config,\n        notModifiedSince: input.source.notModifiedSince,\n        eTag: input.source.eTag,\n        expectedSourceBucketOwner: input.source?.expectedBucketOwner,\n        expectedBucketOwner: input.destination?.expectedBucketOwner,\n    });\n    return {\n        key: destination.key,\n    };\n};\nconst serviceCopy = async ({ source, destination, bucket, s3Config, notModifiedSince, eTag, expectedSourceBucketOwner, expectedBucketOwner, }) => {\n    await copyObject({\n        ...s3Config,\n        userAgentValue: getStorageUserAgentValue(StorageAction.Copy),\n    }, {\n        Bucket: bucket,\n        CopySource: source,\n        Key: destination,\n        MetadataDirective: 'COPY', // Copies over metadata like contentType as well\n        CopySourceIfMatch: eTag,\n        CopySourceIfUnmodifiedSince: notModifiedSince,\n        ExpectedSourceBucketOwner: expectedSourceBucketOwner,\n        ExpectedBucketOwner: expectedBucketOwner,\n    });\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}